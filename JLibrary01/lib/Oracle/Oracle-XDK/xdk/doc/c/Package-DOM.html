<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- WARNING!  THIS IS A GENERATED FILE!!  DO NOT EDIT!!! -->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>DOM APIs</title>
</head>
<body bgcolor=white>
<a name="_top_"></a>
<center><table width="90%"><tr><td align=left>
<b>Packages: <a href="packages.html">All</a></b>
 | <b><a href="Package-Callback.html">Callback</a></b>
 | <b><a href="Package-DOM.html">DOM</a></b>
 | <b><a href="Package-Range.html">Range</a></b>
 | <b><a href="Package-SAX.html">SAX</a></b>
 | <b><a href="Package-Schema.html">Schema</a></b>
 | <b><a href="Package-Traversal.html">Traversal</a></b>
 | <b><a href="Package-XML.html">XML</a></b>
 | <b><a href="Package-XPath.html">XPath</a></b>
 | <b><a href="Package-XPointer.html">XPointer</a></b>
 | <b><a href="Package-XSLT.html">XSLT</a></b>
 | <b><a href="Package-XSLTVM.html">XSLTVM</a></b>
</td><td align=right><b><a href="Functions.html">Functions</a></b>
 | <b><a href="Datatypes.html">Datatypes</a></b></td></tr></table>
</center><hr noshade size=1>
<center><h1>Package DOM</h1></center>

    Since the DOM standard is object-oriented, for this C adaptation, some
    changes had to be made:<p>    Reused function names had to be expanded, e.g. <tt>getValue</tt> in the
    attribute class is given the unique name XmlDomGetAttrValue, matching
    the pattern established by DOM 2's "<tt>getNodeValue</tt>".<p>    Also, some functions were added to extend the DOM.  For example,
    there is no function defined which returns the number of children
    of a node, so XmlDomNumChildNodes was invented, etc.<p>    The implementation of this DOM interface follows REC-DOM-Level-1-19981001.<p>
<ul>
    <li><a href="#functions"><b>Function Index</b></a>
    <li><a href="#Attr">Interface <b>Attr</b></a> (XML Attribute functions)
    <li><a href="#CharacterData">Interface <b>CharacterData</b></a>
    <li><a href="#Document">Interface <b>Document</b></a>
    <li><a href="#DocumentType">Interface <b>DocumentType</b></a>
    <li><a href="#Element">Interface <b>Element</b></a>
    <li><a href="#Entity">Interface <b>Entity</b></a>
    <li><a href="#NamedNodeMap">Interface <b>NamedNodeMap</b></a>
    <li><a href="#Node">Interface <b>Node</b></a>
    <li><a href="#NodeList">Interface <b>NodeList</b></a>
    <li><a href="#Notation">Interface <b>Notation</b></a>
    <li><a href="#ProcessingInstruction">Interface <b>ProcessingInstruction</b></a>
    <li><a href="#Text">Interface <b>Text</b></a>
</ul>

<hr noshade size=1><center><h2><a name="functions">Function Index</a></h2></center>
<center><table summary="Package 'DOM' function index" cellspacing=0 cellpadding=0>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Interface<th scope=col>Description</tr>
  <tr>
    <td width=200><a href="#XmlDomAppendChild"><b>XmlDomAppendChild</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Append new child to node's list of children</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomAppendData"><b>XmlDomAppendData</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Append data to end of node's current data</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCleanNode"><b>XmlDomCleanNode</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>"Clean" a node (free DOM allocations)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCloneNode"><b>XmlDomCloneNode</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Clone a node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateAttr"><b>XmlDomCreateAttr</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create attribute node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateAttrNS"><b>XmlDomCreateAttrNS</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create attribute node with namespace information</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateCDATA"><b>XmlDomCreateCDATA</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create CDATA node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateComment"><b>XmlDomCreateComment</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create comment node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateElem"><b>XmlDomCreateElem</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create an element node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateElemNS"><b>XmlDomCreateElemNS</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create an element node with namespace information</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateEntityRef"><b>XmlDomCreateEntityRef</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create entity reference node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateFragment"><b>XmlDomCreateFragment</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create a document fragment</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreatePI"><b>XmlDomCreatePI</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create PI node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomCreateText"><b>XmlDomCreateText</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Create text node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomDeleteData"><b>XmlDomDeleteData</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Remove part of node's data</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomFreeNode"><b>XmlDomFreeNode</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Free a node allocated with XmlDomCreateXXX</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomFreeNodeList"><b>XmlDomFreeNodeList</b></a></td>

    <td><a href="#NodeList"><b>NodeList</b></a></td>
    <td>Free a node list returned by XmlDomGetElemsByTag etc</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomFreeString"><b>XmlDomFreeString</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Frees a string allocate by XmlDomSubstringData etc</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttr"><b>XmlDomGetAttr</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Return attribute's value given its name</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrLocal"><b>XmlDomGetAttrLocal</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Returns an attribute's namespace local name as NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrLocalLen"><b>XmlDomGetAttrLocalLen</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Returns an attribute's namespace local name as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrNS"><b>XmlDomGetAttrNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Return attribute's value given its URI and localname</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrName"><b>XmlDomGetAttrName</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Return attribute's name as NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrNameLen"><b>XmlDomGetAttrNameLen</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Return attribute's name as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrNode"><b>XmlDomGetAttrNode</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Get attribute by name</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrNodeNS"><b>XmlDomGetAttrNodeNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Get attribute by name (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrPrefix"><b>XmlDomGetAttrPrefix</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Returns an attribute's namespace prefix</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrSpecified"><b>XmlDomGetAttrSpecified</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Return flag saying whether an attribute was explicitly created</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrURI"><b>XmlDomGetAttrURI</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Returns an attribute's namespace URI as NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrURILen"><b>XmlDomGetAttrURILen</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Returns an attribute's namespace URI as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrValue"><b>XmlDomGetAttrValue</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Return attribute's value as NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrValueLen"><b>XmlDomGetAttrValueLen</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Return attribute's value as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetAttrs"><b>XmlDomGetAttrs</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return attributes of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetBaseURI"><b>XmlDomGetBaseURI</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Returns the base URI for a document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetCharData"><b>XmlDomGetCharData</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Return data for node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetCharDataLength"><b>XmlDomGetCharDataLength</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Return length of data for node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetChildNodes"><b>XmlDomGetChildNodes</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return children of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetChildrenByTag"><b>XmlDomGetChildrenByTag</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Get children of element with given tag name [non-namespace-aware]</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetChildrenByTagNS"><b>XmlDomGetChildrenByTagNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Get children of element with tag name [namespace-aware version]</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDTD"><b>XmlDomGetDTD</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Get DTD (Document Type) for document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDTDEntities"><b>XmlDomGetDTDEntities</b></a></td>

    <td><a href="#DocumentType"><b>DocumentType</b></a></td>
    <td>Get entities of DTD</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDTDInternalSubset"><b>XmlDomGetDTDInternalSubset</b></a></td>

    <td><a href="#DocumentType"><b>DocumentType</b></a></td>
    <td>Get DTD's internal subset</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDTDName"><b>XmlDomGetDTDName</b></a></td>

    <td><a href="#DocumentType"><b>DocumentType</b></a></td>
    <td>Get name of DTD</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDTDNotations"><b>XmlDomGetDTDNotations</b></a></td>

    <td><a href="#DocumentType"><b>DocumentType</b></a></td>
    <td>Get notations of DTD</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDTDPubID"><b>XmlDomGetDTDPubID</b></a></td>

    <td><a href="#DocumentType"><b>DocumentType</b></a></td>
    <td>Get DTD's public ID</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDTDSysID"><b>XmlDomGetDTDSysID</b></a></td>

    <td><a href="#DocumentType"><b>DocumentType</b></a></td>
    <td>Get DTD's system ID</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDecl"><b>XmlDomGetDecl</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Returns a document's XMLDecl information</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDefaultNS"><b>XmlDomGetDefaultNS</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get default namespace for node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDocElem"><b>XmlDomGetDocElem</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Get top-level element for document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDocElemByID"><b>XmlDomGetDocElemByID</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Get document element given ID</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDocElemsByTag"><b>XmlDomGetDocElemsByTag</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Obtain doc elements</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetDocElemsByTagNS"><b>XmlDomGetDocElemsByTagNS</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Obtain doc elements (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetElemsByTag"><b>XmlDomGetElemsByTag</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Get elements with given tag name [non-namespace-aware version]</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetElemsByTagNS"><b>XmlDomGetElemsByTagNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Get elements with given URI and localname [namespace aware version]</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetEntityNotation"><b>XmlDomGetEntityNotation</b></a></td>

    <td><a href="#Entity"><b>Entity</b></a></td>
    <td>Get entity's notation</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetEntityPubID"><b>XmlDomGetEntityPubID</b></a></td>

    <td><a href="#Entity"><b>Entity</b></a></td>
    <td>Get entity's public ID</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetEntitySysID"><b>XmlDomGetEntitySysID</b></a></td>

    <td><a href="#Entity"><b>Entity</b></a></td>
    <td>Get entity's system ID</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetEntityType"><b>XmlDomGetEntityType</b></a></td>

    <td><a href="#Entity"><b>Entity</b></a></td>
    <td>Get entity's type</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetFirstChild"><b>XmlDomGetFirstChild</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Returns first child of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetFirstPfnsPair"><b>XmlDomGetFirstPfnsPair</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get first prefix namespace pair</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetLastChild"><b>XmlDomGetLastChild</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Returns last child of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetLastError"><b>XmlDomGetLastError</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Return last error code for document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNamedItem"><b>XmlDomGetNamedItem</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Return named node from list</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNamedItemNS"><b>XmlDomGetNamedItemNS</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Return named node from list (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNextPfnsPair"><b>XmlDomGetNextPfnsPair</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get subsequent prefix namespace pair</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNextSibling"><b>XmlDomGetNextSibling</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return next sibling of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeListItem"><b>XmlDomGetNodeListItem</b></a></td>

    <td><a href="#NodeList"><b>NodeList</b></a></td>
    <td>Return nth node in list</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeListLength"><b>XmlDomGetNodeListLength</b></a></td>

    <td><a href="#NodeList"><b>NodeList</b></a></td>
    <td>Return length of node list</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeLocal"><b>XmlDomGetNodeLocal</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get local part of node's qualified name as NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeLocalLen"><b>XmlDomGetNodeLocalLen</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get local part of node's qualified name as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeMapItem"><b>XmlDomGetNodeMapItem</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Return nth node in list</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeMapLength"><b>XmlDomGetNodeMapLength</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Return length of named node map</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeName"><b>XmlDomGetNodeName</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get node's name as NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeNameLen"><b>XmlDomGetNodeNameLen</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get node's name as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodePrefix"><b>XmlDomGetNodePrefix</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return namespace prefix of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeType"><b>XmlDomGetNodeType</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get node's numeric type code</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeURI"><b>XmlDomGetNodeURI</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return namespace URI of node as a NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeURILen"><b>XmlDomGetNodeURILen</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return namespace URI of node as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeValue"><b>XmlDomGetNodeValue</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get node's value as NULL-terminated string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNodeValueLen"><b>XmlDomGetNodeValueLen</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get node value as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNotationPubID"><b>XmlDomGetNotationPubID</b></a></td>

    <td><a href="#Notation"><b>Notation</b></a></td>
    <td>Get notation's public ID</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetNotationSysID"><b>XmlDomGetNotationSysID</b></a></td>

    <td><a href="#Notation"><b>Notation</b></a></td>
    <td>Get notation's system ID</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetOwnerDocument"><b>XmlDomGetOwnerDocument</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get the owner document of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetOwnerElem"><b>XmlDomGetOwnerElem</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Return an attribute's owning element</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetPIData"><b>XmlDomGetPIData</b></a></td>

    <td><a href="#ProcessingInstruction"><b>ProcessingInstruction</b></a></td>
    <td>Get processing instruction's data</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetPITarget"><b>XmlDomGetPITarget</b></a></td>

    <td><a href="#ProcessingInstruction"><b>ProcessingInstruction</b></a></td>
    <td>Get PI's target</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetParentNode"><b>XmlDomGetParentNode</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get parent node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetPrevSibling"><b>XmlDomGetPrevSibling</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return previous sibling of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetSchema"><b>XmlDomGetSchema</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Returns URI of schema associated with document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetSourceEntity"><b>XmlDomGetSourceEntity</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return the entity node if the input file is an external entity</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetSourceLine"><b>XmlDomGetSourceLine</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return source line# of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetSourceLocation"><b>XmlDomGetSourceLocation</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return source location (path, URI, etc) of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomGetTag"><b>XmlDomGetTag</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Return an element node's tagname</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomHasAttr"><b>XmlDomHasAttr</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Does named attribute exist?</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomHasAttrNS"><b>XmlDomHasAttrNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Does named attribute exist?  (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomHasAttrs"><b>XmlDomHasAttrs</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Test if element has attributes</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomHasChildNodes"><b>XmlDomHasChildNodes</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Test if node has children</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomImportNode"><b>XmlDomImportNode</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Import a node from another DOM</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomInsertBefore"><b>XmlDomInsertBefore</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Insert new child into node's list of children</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomInsertData"><b>XmlDomInsertData</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Insert string into node's current data</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomIsSchemaBased"><b>XmlDomIsSchemaBased</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Indicate whether a schema is associated with a document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomNormalize"><b>XmlDomNormalize</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>"Normalize" a node, that is, merge adjacent text nodes</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomNumAttrs"><b>XmlDomNumAttrs</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return number of attributes of element</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomNumChildNodes"><b>XmlDomNumChildNodes</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Return number of children of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomPrefixToURI"><b>XmlDomPrefixToURI</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Get namespace URI for prefix</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomRemoveAttr"><b>XmlDomRemoveAttr</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Remove attribute with specified name</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomRemoveAttrNS"><b>XmlDomRemoveAttrNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Remove attribute with specified URI and local name</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomRemoveAttrNode"><b>XmlDomRemoveAttrNode</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Remove attribute node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomRemoveChild"><b>XmlDomRemoveChild</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Remove an existing child node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomRemoveNamedItem"><b>XmlDomRemoveNamedItem</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Remove node from named node map</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomRemoveNamedItemNS"><b>XmlDomRemoveNamedItemNS</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Remove node from named node map (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomReplaceChild"><b>XmlDomReplaceChild</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Replace an existing child of a node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomReplaceData"><b>XmlDomReplaceData</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Replace part of node's data</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSaveString"><b>XmlDomSaveString</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Saves a string permanently in a document's memory pool </td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSaveString2"><b>XmlDomSaveString2</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Saves a Unicode string permanently in a document's memory pool </td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetAttr"><b>XmlDomSetAttr</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Set new attribute for element</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetAttrNS"><b>XmlDomSetAttrNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Set new attribute for element (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetAttrNode"><b>XmlDomSetAttrNode</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Set attribute node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetAttrNodeNS"><b>XmlDomSetAttrNodeNS</b></a></td>

    <td><a href="#Element"><b>Element</b></a></td>
    <td>Set attribute node (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetAttrValue"><b>XmlDomSetAttrValue</b></a></td>

    <td><a href="#Attr"><b>Attr</b></a></td>
    <td>Set an attribute's value</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetBaseURI"><b>XmlDomSetBaseURI</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Sets base URI for document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetCharData"><b>XmlDomSetCharData</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Set data for node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetDTD"><b>XmlDomSetDTD</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Sets DTD (Document Type Definition) for document</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetDefaultNS"><b>XmlDomSetDefaultNS</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Set default namespace for node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetDocOrder"><b>XmlDomSetDocOrder</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Set document order for all nodes</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetNamedItem"><b>XmlDomSetNamedItem</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Set node in named node list</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetNamedItemNS"><b>XmlDomSetNamedItemNS</b></a></td>

    <td><a href="#NamedNodeMap"><b>NamedNodeMap</b></a></td>
    <td>Set node in named node list (namespace aware version)</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetNodePrefix"><b>XmlDomSetNodePrefix</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Set namespace prefix of node</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetNodeValue"><b>XmlDomSetNodeValue</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Set node value</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetNodeValueLen"><b>XmlDomSetNodeValueLen</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Set node value as length-encoded string</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSetPIData"><b>XmlDomSetPIData</b></a></td>

    <td><a href="#ProcessingInstruction"><b>ProcessingInstruction</b></a></td>
    <td>Set processing instruction's data</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSplitText"><b>XmlDomSplitText</b></a></td>

    <td><a href="#Text"><b>Text</b></a></td>
    <td>Split text node into two</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSubstringData"><b>XmlDomSubstringData</b></a></td>

    <td><a href="#CharacterData"><b>CharacterData</b></a></td>
    <td>Return substring of node's data</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomSync"><b>XmlDomSync</b></a></td>

    <td><a href="#Document"><b>Document</b></a></td>
    <td>Synchronizes the persistent version of a document with its DOM.</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlDomValidate"><b>XmlDomValidate</b></a></td>

    <td><a href="#Node"><b>Node</b></a></td>
    <td>Validate a node against current DTD</td>
  </tr>
</table></center>

<br><hr noshade size=1><center><h2><a name="Attr">Interface Attr</a> (XML Attribute functions)</h2></center>
<p>
    First paragraph is extra documentation that's not really necessary but
    is just here to test the doc stripper.<p>    Second paragraph is not any more exciting.  Read a book!<p><p>
<h3>Example</h3>
<pre>	<foo xmlns:pfx="example_namespace" pfx:bar="bar_value"/>
	XmlDomGetAttrLocal(attr pfx:bar) --> "bar\0"

</pre><p>
	   <center><h3>Function Index</h3>
<table summary="Interface 'Attr' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrLocal"><b>XmlDomGetAttrLocal</b></a></td>
	       <td>Returns an attribute's namespace local name as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrLocalLen"><b>XmlDomGetAttrLocalLen</b></a></td>
	       <td>Returns an attribute's namespace local name as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrName"><b>XmlDomGetAttrName</b></a></td>
	       <td>Return attribute's name as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrNameLen"><b>XmlDomGetAttrNameLen</b></a></td>
	       <td>Return attribute's name as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrPrefix"><b>XmlDomGetAttrPrefix</b></a></td>
	       <td>Returns an attribute's namespace prefix</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrSpecified"><b>XmlDomGetAttrSpecified</b></a></td>
	       <td>Return flag saying whether an attribute was explicitly created</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrURI"><b>XmlDomGetAttrURI</b></a></td>
	       <td>Returns an attribute's namespace URI as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrURILen"><b>XmlDomGetAttrURILen</b></a></td>
	       <td>Returns an attribute's namespace URI as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrValue"><b>XmlDomGetAttrValue</b></a></td>
	       <td>Return attribute's value as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrValueLen"><b>XmlDomGetAttrValueLen</b></a></td>
	       <td>Return attribute's value as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetOwnerElem"><b>XmlDomGetOwnerElem</b></a></td>
	       <td>Return an attribute's owning element</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetAttrValue"><b>XmlDomSetAttrValue</b></a></td>
	       <td>Set an attribute's value</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="CharacterData">Interface CharacterData</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'CharacterData' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomAppendData"><b>XmlDomAppendData</b></a></td>
	       <td>Append data to end of node's current data</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomDeleteData"><b>XmlDomDeleteData</b></a></td>
	       <td>Remove part of node's data</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetCharData"><b>XmlDomGetCharData</b></a></td>
	       <td>Return data for node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetCharDataLength"><b>XmlDomGetCharDataLength</b></a></td>
	       <td>Return length of data for node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomInsertData"><b>XmlDomInsertData</b></a></td>
	       <td>Insert string into node's current data</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomReplaceData"><b>XmlDomReplaceData</b></a></td>
	       <td>Replace part of node's data</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetCharData"><b>XmlDomSetCharData</b></a></td>
	       <td>Set data for node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSubstringData"><b>XmlDomSubstringData</b></a></td>
	       <td>Return substring of node's data</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="Document">Interface Document</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'Document' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomCreateAttr"><b>XmlDomCreateAttr</b></a></td>
	       <td>Create attribute node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateAttrNS"><b>XmlDomCreateAttrNS</b></a></td>
	       <td>Create attribute node with namespace information</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateCDATA"><b>XmlDomCreateCDATA</b></a></td>
	       <td>Create CDATA node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateComment"><b>XmlDomCreateComment</b></a></td>
	       <td>Create comment node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateElem"><b>XmlDomCreateElem</b></a></td>
	       <td>Create an element node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateElemNS"><b>XmlDomCreateElemNS</b></a></td>
	       <td>Create an element node with namespace information</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateEntityRef"><b>XmlDomCreateEntityRef</b></a></td>
	       <td>Create entity reference node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateFragment"><b>XmlDomCreateFragment</b></a></td>
	       <td>Create a document fragment</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreatePI"><b>XmlDomCreatePI</b></a></td>
	       <td>Create PI node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCreateText"><b>XmlDomCreateText</b></a></td>
	       <td>Create text node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomFreeString"><b>XmlDomFreeString</b></a></td>
	       <td>Frees a string allocate by XmlDomSubstringData etc</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetBaseURI"><b>XmlDomGetBaseURI</b></a></td>
	       <td>Returns the base URI for a document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDTD"><b>XmlDomGetDTD</b></a></td>
	       <td>Get DTD (Document Type) for document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDecl"><b>XmlDomGetDecl</b></a></td>
	       <td>Returns a document's XMLDecl information</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDocElem"><b>XmlDomGetDocElem</b></a></td>
	       <td>Get top-level element for document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDocElemByID"><b>XmlDomGetDocElemByID</b></a></td>
	       <td>Get document element given ID</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDocElemsByTag"><b>XmlDomGetDocElemsByTag</b></a></td>
	       <td>Obtain doc elements</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDocElemsByTagNS"><b>XmlDomGetDocElemsByTagNS</b></a></td>
	       <td>Obtain doc elements (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetLastError"><b>XmlDomGetLastError</b></a></td>
	       <td>Return last error code for document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetSchema"><b>XmlDomGetSchema</b></a></td>
	       <td>Returns URI of schema associated with document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomImportNode"><b>XmlDomImportNode</b></a></td>
	       <td>Import a node from another DOM</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomIsSchemaBased"><b>XmlDomIsSchemaBased</b></a></td>
	       <td>Indicate whether a schema is associated with a document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSaveString"><b>XmlDomSaveString</b></a></td>
	       <td>Saves a string permanently in a document's memory pool </td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSaveString2"><b>XmlDomSaveString2</b></a></td>
	       <td>Saves a Unicode string permanently in a document's memory pool </td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetBaseURI"><b>XmlDomSetBaseURI</b></a></td>
	       <td>Sets base URI for document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetDTD"><b>XmlDomSetDTD</b></a></td>
	       <td>Sets DTD (Document Type Definition) for document</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetDocOrder"><b>XmlDomSetDocOrder</b></a></td>
	       <td>Set document order for all nodes</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSync"><b>XmlDomSync</b></a></td>
	       <td>Synchronizes the persistent version of a document with its DOM.</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DocumentType">Interface DocumentType</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'DocumentType' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomGetDTDEntities"><b>XmlDomGetDTDEntities</b></a></td>
	       <td>Get entities of DTD</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDTDInternalSubset"><b>XmlDomGetDTDInternalSubset</b></a></td>
	       <td>Get DTD's internal subset</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDTDName"><b>XmlDomGetDTDName</b></a></td>
	       <td>Get name of DTD</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDTDNotations"><b>XmlDomGetDTDNotations</b></a></td>
	       <td>Get notations of DTD</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDTDPubID"><b>XmlDomGetDTDPubID</b></a></td>
	       <td>Get DTD's public ID</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDTDSysID"><b>XmlDomGetDTDSysID</b></a></td>
	       <td>Get DTD's system ID</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="Element">Interface Element</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'Element' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomGetAttr"><b>XmlDomGetAttr</b></a></td>
	       <td>Return attribute's value given its name</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrNS"><b>XmlDomGetAttrNS</b></a></td>
	       <td>Return attribute's value given its URI and localname</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrNode"><b>XmlDomGetAttrNode</b></a></td>
	       <td>Get attribute by name</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrNodeNS"><b>XmlDomGetAttrNodeNS</b></a></td>
	       <td>Get attribute by name (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetChildrenByTag"><b>XmlDomGetChildrenByTag</b></a></td>
	       <td>Get children of element with given tag name [non-namespace-aware]</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetChildrenByTagNS"><b>XmlDomGetChildrenByTagNS</b></a></td>
	       <td>Get children of element with tag name [namespace-aware version]</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetElemsByTag"><b>XmlDomGetElemsByTag</b></a></td>
	       <td>Get elements with given tag name [non-namespace-aware version]</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetElemsByTagNS"><b>XmlDomGetElemsByTagNS</b></a></td>
	       <td>Get elements with given URI and localname [namespace aware version]</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetTag"><b>XmlDomGetTag</b></a></td>
	       <td>Return an element node's tagname</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomHasAttr"><b>XmlDomHasAttr</b></a></td>
	       <td>Does named attribute exist?</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomHasAttrNS"><b>XmlDomHasAttrNS</b></a></td>
	       <td>Does named attribute exist?  (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomRemoveAttr"><b>XmlDomRemoveAttr</b></a></td>
	       <td>Remove attribute with specified name</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomRemoveAttrNS"><b>XmlDomRemoveAttrNS</b></a></td>
	       <td>Remove attribute with specified URI and local name</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomRemoveAttrNode"><b>XmlDomRemoveAttrNode</b></a></td>
	       <td>Remove attribute node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetAttr"><b>XmlDomSetAttr</b></a></td>
	       <td>Set new attribute for element</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetAttrNS"><b>XmlDomSetAttrNS</b></a></td>
	       <td>Set new attribute for element (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetAttrNode"><b>XmlDomSetAttrNode</b></a></td>
	       <td>Set attribute node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetAttrNodeNS"><b>XmlDomSetAttrNodeNS</b></a></td>
	       <td>Set attribute node (namespace aware version)</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="Entity">Interface Entity</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'Entity' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomGetEntityNotation"><b>XmlDomGetEntityNotation</b></a></td>
	       <td>Get entity's notation</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetEntityPubID"><b>XmlDomGetEntityPubID</b></a></td>
	       <td>Get entity's public ID</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetEntitySysID"><b>XmlDomGetEntitySysID</b></a></td>
	       <td>Get entity's system ID</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetEntityType"><b>XmlDomGetEntityType</b></a></td>
	       <td>Get entity's type</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NamedNodeMap">Interface NamedNodeMap</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'NamedNodeMap' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomGetNamedItem"><b>XmlDomGetNamedItem</b></a></td>
	       <td>Return named node from list</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNamedItemNS"><b>XmlDomGetNamedItemNS</b></a></td>
	       <td>Return named node from list (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeMapItem"><b>XmlDomGetNodeMapItem</b></a></td>
	       <td>Return nth node in list</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeMapLength"><b>XmlDomGetNodeMapLength</b></a></td>
	       <td>Return length of named node map</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomRemoveNamedItem"><b>XmlDomRemoveNamedItem</b></a></td>
	       <td>Remove node from named node map</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomRemoveNamedItemNS"><b>XmlDomRemoveNamedItemNS</b></a></td>
	       <td>Remove node from named node map (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetNamedItem"><b>XmlDomSetNamedItem</b></a></td>
	       <td>Set node in named node list</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetNamedItemNS"><b>XmlDomSetNamedItemNS</b></a></td>
	       <td>Set node in named node list (namespace aware version)</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="Node">Interface Node</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'Node' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomAppendChild"><b>XmlDomAppendChild</b></a></td>
	       <td>Append new child to node's list of children</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCleanNode"><b>XmlDomCleanNode</b></a></td>
	       <td>"Clean" a node (free DOM allocations)</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomCloneNode"><b>XmlDomCloneNode</b></a></td>
	       <td>Clone a node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomFreeNode"><b>XmlDomFreeNode</b></a></td>
	       <td>Free a node allocated with XmlDomCreateXXX</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetAttrs"><b>XmlDomGetAttrs</b></a></td>
	       <td>Return attributes of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetChildNodes"><b>XmlDomGetChildNodes</b></a></td>
	       <td>Return children of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetDefaultNS"><b>XmlDomGetDefaultNS</b></a></td>
	       <td>Get default namespace for node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetFirstChild"><b>XmlDomGetFirstChild</b></a></td>
	       <td>Returns first child of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetFirstPfnsPair"><b>XmlDomGetFirstPfnsPair</b></a></td>
	       <td>Get first prefix namespace pair</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetLastChild"><b>XmlDomGetLastChild</b></a></td>
	       <td>Returns last child of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNextPfnsPair"><b>XmlDomGetNextPfnsPair</b></a></td>
	       <td>Get subsequent prefix namespace pair</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNextSibling"><b>XmlDomGetNextSibling</b></a></td>
	       <td>Return next sibling of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeLocal"><b>XmlDomGetNodeLocal</b></a></td>
	       <td>Get local part of node's qualified name as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeLocalLen"><b>XmlDomGetNodeLocalLen</b></a></td>
	       <td>Get local part of node's qualified name as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeName"><b>XmlDomGetNodeName</b></a></td>
	       <td>Get node's name as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeNameLen"><b>XmlDomGetNodeNameLen</b></a></td>
	       <td>Get node's name as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodePrefix"><b>XmlDomGetNodePrefix</b></a></td>
	       <td>Return namespace prefix of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeType"><b>XmlDomGetNodeType</b></a></td>
	       <td>Get node's numeric type code</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeURI"><b>XmlDomGetNodeURI</b></a></td>
	       <td>Return namespace URI of node as a NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeURILen"><b>XmlDomGetNodeURILen</b></a></td>
	       <td>Return namespace URI of node as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeValue"><b>XmlDomGetNodeValue</b></a></td>
	       <td>Get node's value as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeValueLen"><b>XmlDomGetNodeValueLen</b></a></td>
	       <td>Get node value as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetOwnerDocument"><b>XmlDomGetOwnerDocument</b></a></td>
	       <td>Get the owner document of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetParentNode"><b>XmlDomGetParentNode</b></a></td>
	       <td>Get parent node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetPrevSibling"><b>XmlDomGetPrevSibling</b></a></td>
	       <td>Return previous sibling of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetSourceEntity"><b>XmlDomGetSourceEntity</b></a></td>
	       <td>Return the entity node if the input file is an external entity</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetSourceLine"><b>XmlDomGetSourceLine</b></a></td>
	       <td>Return source line# of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetSourceLocation"><b>XmlDomGetSourceLocation</b></a></td>
	       <td>Return source location (path, URI, etc) of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomHasAttrs"><b>XmlDomHasAttrs</b></a></td>
	       <td>Test if element has attributes</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomHasChildNodes"><b>XmlDomHasChildNodes</b></a></td>
	       <td>Test if node has children</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomInsertBefore"><b>XmlDomInsertBefore</b></a></td>
	       <td>Insert new child into node's list of children</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomNormalize"><b>XmlDomNormalize</b></a></td>
	       <td>"Normalize" a node, that is, merge adjacent text nodes</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomNumAttrs"><b>XmlDomNumAttrs</b></a></td>
	       <td>Return number of attributes of element</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomNumChildNodes"><b>XmlDomNumChildNodes</b></a></td>
	       <td>Return number of children of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomPrefixToURI"><b>XmlDomPrefixToURI</b></a></td>
	       <td>Get namespace URI for prefix</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomRemoveChild"><b>XmlDomRemoveChild</b></a></td>
	       <td>Remove an existing child node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomReplaceChild"><b>XmlDomReplaceChild</b></a></td>
	       <td>Replace an existing child of a node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetDefaultNS"><b>XmlDomSetDefaultNS</b></a></td>
	       <td>Set default namespace for node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetNodePrefix"><b>XmlDomSetNodePrefix</b></a></td>
	       <td>Set namespace prefix of node</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetNodeValue"><b>XmlDomSetNodeValue</b></a></td>
	       <td>Set node value</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetNodeValueLen"><b>XmlDomSetNodeValueLen</b></a></td>
	       <td>Set node value as length-encoded string</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomValidate"><b>XmlDomValidate</b></a></td>
	       <td>Validate a node against current DTD</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NodeList">Interface NodeList</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'NodeList' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomFreeNodeList"><b>XmlDomFreeNodeList</b></a></td>
	       <td>Free a node list returned by XmlDomGetElemsByTag etc</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeListItem"><b>XmlDomGetNodeListItem</b></a></td>
	       <td>Return nth node in list</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNodeListLength"><b>XmlDomGetNodeListLength</b></a></td>
	       <td>Return length of node list</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="Notation">Interface Notation</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'Notation' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomGetNotationPubID"><b>XmlDomGetNotationPubID</b></a></td>
	       <td>Get notation's public ID</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetNotationSysID"><b>XmlDomGetNotationSysID</b></a></td>
	       <td>Get notation's system ID</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="ProcessingInstruction">Interface ProcessingInstruction</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'ProcessingInstruction' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomGetPIData"><b>XmlDomGetPIData</b></a></td>
	       <td>Get processing instruction's data</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomGetPITarget"><b>XmlDomGetPITarget</b></a></td>
	       <td>Get PI's target</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlDomSetPIData"><b>XmlDomSetPIData</b></a></td>
	       <td>Set processing instruction's data</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="Text">Interface Text</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'Text' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlDomSplitText"><b>XmlDomSplitText</b></a></td>
	       <td>Split text node into two</td>
	       </tr>
	   </table></center>
<hr noshade size=1>

<h2 align=center><a name="XmlDomAppendChild">XmlDomAppendChild</a></h2>

<table summary="Function 'XmlDomAppendChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomAppendChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.appendChild()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Append new child to node's list of children</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomAppendChild(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*parent,&nbsp;xmlnode&nbsp;*newChild)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomAppendChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>parent</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> parent to receive new node</td></tr>
<tr><td scope=row><tt>newChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to add</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node added</tr>
<tr><th scope=row><i>Description</i>
<td>        Appends the node to the end of the parent's list of children and
        returns the new node.  If newChild is a DocumentFragment, all of
        its children are appended in original order; the DocumentFragment
        node itself is not.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomInsertBefore"><tt>XmlDomInsertBefore</tt></a>, <a href="Package-DOM.html#XmlDomReplaceChild"><tt>XmlDomReplaceChild</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomAppendData">XmlDomAppendData</a></h2>

<table summary="Function 'XmlDomAppendData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomAppendData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: Node.appendData()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Append data to end of node's current data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomAppendData(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*data,&nbsp;oratext&nbsp;**old)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomAppendData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  CharacterData node [<i>text, comment, or CDATA</i>]</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  data to append [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>old</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> previous data for node [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Append a string to the end of a CharacterData node's data.  If the
        node is not text, comment or CDATA, or if the string to append
        is NULL, does nothing.  The appended data should be in the data
        encoding.  It will not be verified, converted, or checked.  If bad
        data is appended, bad things will happen-- GIGO!<p>
        The new node data will be allocated and managed by DOM, but if the
        previous node value was allocated and manager by the user, they
        are responsible for freeing it (which is why it's returned).<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a>, <a href="Package-DOM.html#XmlDomInsertData"><tt>XmlDomInsertData</tt></a>, <a href="Package-DOM.html#XmlDomDeleteData"><tt>XmlDomDeleteData</tt></a>, <a href="Package-DOM.html#XmlDomReplaceData"><tt>XmlDomReplaceData</tt></a>, <a href="Package-DOM.html#XmlDomSplitText"><tt>XmlDomSplitText</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCleanNode">XmlDomCleanNode</a></h2>

<table summary="Function 'XmlDomCleanNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCleanNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>"Clean" a node (free DOM allocations)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomCleanNode(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCleanNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to clean</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Frees parts of the node which were allocated by DOM itself, but does
        not recurse to children or touch the node's attributes.  After
        freeing part of the node (e.g. name), a DOM call to get that part
        (e.g. XmlDomGetNodeName) should return a NULL pointer.  Used to
        manage the allocations of a node parts of which are controlled by
        DOM, and part by the user.  Calling clean frees all allocations
        may by DOM and leaves the user's allocations alone.  The user is
        responsible for freeing their own allocations.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCloneNode">XmlDomCloneNode</a></h2>

<table summary="Function 'XmlDomCloneNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCloneNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.cloneNode()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Clone a node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomCloneNode(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;boolean&nbsp;deep)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCloneNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
<tr><td scope=row><tt>deep</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> recursively clone children?</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> duplicate (cloned) node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates and returns a duplicate of a node.  The duplicate node has
        no parent.  Cloning an element copies all attributes and their values,
        including those generated by the XML processor to represent defaulted
        attributes, but it does not copy any text it contains unless it is a
        deep clone, since the text is contained in a child text node.  Cloning
        any other type of node simply returns a copy of the node.  Note that a
        clone of an unspecified attribute node is specified.  If deep is TRUE,
        all children of the node are recursively cloned, and the cloned node
        will have cloned children; a non-deep clone will have no children.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomImportNode"><tt>XmlDomImportNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateAttr">XmlDomCreateAttr</a></h2>

<table summary="Function 'XmlDomCreateAttr' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateAttr</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createAttribute()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create attribute node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlattrnode*&nbsp;XmlDomCreateAttr(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*name,&nbsp;oratext&nbsp;*value)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateAttr' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's name [<i>data encoding; user control</i>]</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's value [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlattrnode *)</b></tt> new Attr node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an attribute node with the given name and value (in the
        data encoding).  Note this function differs from the DOM
        specification, which does not allow the initial value of the
        attribute to be set (see XmlDomSetAttrValue).  The name is required,
        but the value may be NULL; neither is verified, converted, or
        checked.  If bad data is set, bad things will happen-- GIGO!<p>
        This is the non-namespace aware function (see XmlDomCreateAttrNS):
        the new attribute will have NULL namespace URI and prefix, and
        its local name will be the same as its name, even if the name
        specified is a QName.<p>
        If given an initial value, the attribute's specified flag will
        be TRUE.<p>
        The new node is an orphan with no parent; it must be added to the
        DOM tree with XmlDomAppendChild etc.<p>
        See XmlDomSetAttr which creates and adds an attribute in a
        single operation.<p>
        The name and value are NOT copied, their pointers are just stored.
        The user is responsible for persistence and freeing of that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a>, <a href="Package-DOM.html#XmlDomCreateAttrNS"><tt>XmlDomCreateAttrNS</tt></a>, <a href="Package-DOM.html#XmlDomSetAttr"><tt>XmlDomSetAttr</tt></a>, <a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateAttrNS">XmlDomCreateAttrNS</a></h2>

<table summary="Function 'XmlDomCreateAttrNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateAttrNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createAttributeNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create attribute node with namespace information</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlattrnode*&nbsp;XmlDomCreateAttrNS(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*uri,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*qname,&nbsp;oratext&nbsp;*value)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateAttrNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node's namespace URI [<i>data encoding; user control</i>]</td></tr>
<tr><td scope=row><tt>qname</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node's qualified name [<i>data encoding; user control</i>]</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node's value [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlattrnode *)</b></tt> new Attr node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an attribute node with the given namespace URI and QName;
        this is the namespace-aware version of XmlDomCreateAttr.  Note
        this function differs from the DOM specification, which does not allow
        the initial value of the attribute to be set (see XmlDomSetAttrValue).
        The name is required, but the value may be NULL; neither is verified,
        converted, or checked.  If bad data is set, bad things will happen--
        GIGO!<p>
        If given an initial value, the attribute's specified flag will be
        TRUE.<p>
        The new node is an orphan with no parent; it must be added to the
        DOM tree with XmlDomAppendChild, etc.  See XmlDomSetAttr which
        creates and adds an attribute in a single operation.<p>
        The URI, QName and value are NOT copied, their pointers are just
        stored.  The user is responsible for persistence and freeing of
        that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a>, <a href="Package-DOM.html#XmlDomCreateAttr"><tt>XmlDomCreateAttr</tt></a>, <a href="Package-DOM.html#XmlDomSetAttr"><tt>XmlDomSetAttr</tt></a>, <a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateCDATA">XmlDomCreateCDATA</a></h2>

<table summary="Function 'XmlDomCreateCDATA' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateCDATA</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createCDATASection()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create CDATA node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlcdatanode*&nbsp;XmlDomCreateCDATA(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*data)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateCDATA' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's CDATA [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlcdatanode *)</b></tt> new CDATA node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a CDATASection node with the given initial data (which
        should be in the data encoding).  A CDATA section is considered
        verbatim and is never parsed; it will not be joined with adjacent
        Text nodes by the normalize operation.  The initial data may be
        NULL; if provided, it is not verified, converted, or checked.  If
        bad data is set, bad things will happen-- GIGO!  The name of a
        CDATA node is always "#cdata-section".<p>
        The new node is an orphan with no parent; it must be added to the
        DOM tree with XmlDomAppendChild etc.<p>
        The CDATA is NOT copied, its pointer is just stored.  The user is
        responsible for persistence and freeing of that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCreateText"><tt>XmlDomCreateText</tt></a>, <a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateComment">XmlDomCreateComment</a></h2>

<table summary="Function 'XmlDomCreateComment' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateComment</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createComment()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create comment node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlcommentnode*&nbsp;XmlDomCreateComment(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*data)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateComment' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's comment [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlcommentnode *)</b></tt> new Comment node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a Comment node with the given initial data (which must be
        in the data encoding).  The data may be NULL; if provided, it is not
        verified, converted, or checked.  If bad data is set, bad things may
        happen-- GIGO!  The name of a Comment node is always "#comment".<p>
        The new node is an orphan with no parent; it must be added to the DOM
        tree with XmlDomAppendChild etc.<p>
        The comment data is NOT copied, its pointer is just stored.  The user
        is responsible for persistence and freeing of that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateElem">XmlDomCreateElem</a></h2>

<table summary="Function 'XmlDomCreateElem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateElem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createElement()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an element node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlelemnode*&nbsp;XmlDomCreateElem(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*tagname)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateElem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>tagname</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's name [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlelemnode *)</b></tt> new Element node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an element node with the given tag name (which should be in
        the data encoding).  Note that the tag name of an element is CASE
        SENSITIVE.  This is the non-namespace aware function: the new node
        will have NULL namespace URI and prefix, and its local name will be
        the same as its tag name, even if the tag name specified is a QName.<p>
        The new node is an orphan with no parent; it must be added to the DOM
        tree with XmlDomAppendChild etc.<p>
        The tagname is NOT copied, its pointer is just stored.  The user is
        responsible for persistence and freeing of that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCreateElemNS"><tt>XmlDomCreateElemNS</tt></a>, <a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateElemNS">XmlDomCreateElemNS</a></h2>

<table summary="Function 'XmlDomCreateElemNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateElemNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createElementNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an element node with namespace information</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlelemnode*&nbsp;XmlDomCreateElemNS(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*qname)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateElemNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's namespace URI [<i>data encoding; user control</i>]</td></tr>
<tr><td scope=row><tt>qname</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's qualified name [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlelemnode *)</b></tt> new Element node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an element with the given namespace URI and QName.  Note
        that element names are CASE SENSITIVE, and the QName is required
        though the URI may be NULL.  The QName will be split into prefix and
        local parts, retrievable with XmlDomGetNodePrefix, XmlDomGetNodeLocal,
        etc; the tagName will be the full QName.<p>
        The new node is an orphan with no parent; it must be added to the
        DOM tree with XmlDomAppendChild etc.<p>
        The URI and QName are NOT copied, their pointers are just stored.
        The user is responsible for persistence and freeing of that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCreateElem"><tt>XmlDomCreateElem</tt></a>, <a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateEntityRef">XmlDomCreateEntityRef</a></h2>

<table summary="Function 'XmlDomCreateEntityRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateEntityRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createEntityReference()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create entity reference node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlentrefnode*&nbsp;XmlDomCreateEntityRef(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateEntityRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name of referenced entity [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlentrefnode *)</b></tt> new EntityReference node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an Entity Reference node; the name (which should be in the
        data encoding) is the name of the entity to be referenced.  The named
        entity does not have to exist.  The name is not verified, converted,
        or checked.  If bad data is set, bad things will happen-- GIGO!<p>
        Entity Reference nodes are never generated by the parser; instead,
        entity references are expanded as encountered.  On output, an entity
        reference node will turn into a "&amp;name;" style reference.<p>
        The new node is an orphan with no parent; it must be added to the
        DOM tree with XmlDomAppendChild etc.<p>
        The entity reference name is NOT copied, its pointer is just stored.
        The user is responsible for persistence and freeing of that data.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomCreateFragment">XmlDomCreateFragment</a></h2>

<table summary="Function 'XmlDomCreateFragment' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateFragment</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createDocumentFragment()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create a document fragment</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlfragnode*&nbsp;XmlDomCreateFragment(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateFragment' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlfragnode *)</b></tt> new empty DocumentFragment node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an empty Document Fragment node.  A document fragment is
        treated specially when it is inserted into a DOM tree: the children
        of the fragment are inserted in order instead of the fragment node
        itself.  After insertion, the fragment node will still exist, but
        have no children.  See XmlDomInsertBefore, XmlDomReplaceChild,
        XmlDomAppendChild, etc.  The name of a fragment node is always
        "#document-fragment".<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomInsertBefore"><tt>XmlDomInsertBefore</tt></a>, <a href="Package-DOM.html#XmlDomReplaceChild"><tt>XmlDomReplaceChild</tt></a>, <a href="Package-DOM.html#XmlDomAppendChild"><tt>XmlDomAppendChild</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreatePI">XmlDomCreatePI</a></h2>

<table summary="Function 'XmlDomCreatePI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreatePI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createProcessingInstruction()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create PI node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlpinode*&nbsp;XmlDomCreatePI(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*target,&nbsp;oratext&nbsp;*data)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreatePI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>target</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's target [<i>data encoding; user control</i>]</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's data [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlpinode *)</b></tt> new PI node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a Processing Instruction node with the given target and
        data (which should be in the data encoding).  The data may be NULL
        initially, and may be changed later (with XmlDomSetPIData), but the
        target is required and cannot be changed.  Note the target and data
        are not verified, converted, or checked.  If bad data is set, bad
        things will happen-- GIGO!  The name of a PI node is the same as the
        target.<p>
        The new node is an orphan with no parent; it must be added to the
        DOM tree with XmlDomAppendChild etc.<p>
        The PI's target and data are NOT copied, their pointers are just
        stored.  The user is responsible for persistence and freeing of
        that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetPITarget"><tt>XmlDomGetPITarget</tt></a>, <a href="Package-DOM.html#XmlDomGetPIData"><tt>XmlDomGetPIData</tt></a>, <a href="Package-DOM.html#XmlDomSetPIData"><tt>XmlDomSetPIData</tt></a>, <a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomCreateText">XmlDomCreateText</a></h2>

<table summary="Function 'XmlDomCreateText' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomCreateText</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.createTextNode()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Create text node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmltextnode*&nbsp;XmlDomCreateText(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*data)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomCreateText' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's text [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmltextnode *)</b></tt> new Text node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a Text node with the given initial data (which must be
        non-NULL and in the data encoding).  The data may be NULL; if
        provided, it is not verified, converted, checked, or parsed
        (entities will not be expanded).  If bad data is set, bad things
        will happen-- GIGO!  The name of a fragment node is always "#text".
        New data for a Text node can be set with XmlDomSetNodeValue; see
        the CharacterData interface for editing methods.<p>
        The new node is an orphan with no parent; it must be added to
        the DOM tree with XmlDomAppendChild etc.<p>
        The text data is NOT copied, its pointer is just stored.  The user
        is responsible for persistence and freeing of that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCreateCDATA"><tt>XmlDomCreateCDATA</tt></a>, <a href="Package-DOM.html#XmlDomSetNodeValue"><tt>XmlDomSetNodeValue</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeValue"><tt>XmlDomGetNodeValue</tt></a>, <a href="Package-DOM.html#XmlDomSetCharData"><tt>XmlDomSetCharData</tt></a>, <a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a>, <a href="Package-DOM.html#XmlDomGetCharDataLength"><tt>XmlDomGetCharDataLength</tt></a>, <a href="Package-DOM.html#XmlDomSubstringData"><tt>XmlDomSubstringData</tt></a>, <a href="Package-DOM.html#XmlDomAppendData"><tt>XmlDomAppendData</tt></a>, <a href="Package-DOM.html#XmlDomInsertData"><tt>XmlDomInsertData</tt></a>, <a href="Package-DOM.html#XmlDomDeleteData"><tt>XmlDomDeleteData</tt></a>, <a href="Package-DOM.html#XmlDomReplaceData"><tt>XmlDomReplaceData</tt></a>, <a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a>, <a href="Package-DOM.html#XmlDomFreeNode"><tt>XmlDomFreeNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomDeleteData">XmlDomDeleteData</a></h2>

<table summary="Function 'XmlDomDeleteData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomDeleteData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: CharacterData.deleteData()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove part of node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomDeleteData(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;ub4&nbsp;offset,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;count,&nbsp;oratext&nbsp;**old)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomDeleteData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  CharacterData node [<i>Text, Comment, or CDATA</i>]</td></tr>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  character offset from which to start removing</td></tr>
<tr><td scope=row><tt>count</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  number of characters to delete</td></tr>
<tr><td scope=row><tt>out</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> previous data for node [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Remove a range of characters from a CharacterData node's data.
        If the node is not text, comment or CDATA, or if the offset is
        outside of the original data, does nothing.  The offset is
        zero-based, so offset zero refers to the start of the data.
        Both offset and count are in characters, not bytes.  If the sum
        of offset and count exceeds the data length then all characters
        from offset to the end of the data are deleted.<p>
        The new node data will be allocated and managed by DOM, but if the
        previous node value was allocated and managed by the user, they
        are responsible for freeing it (which is why it's returned).<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt></tt><i>Given&nbsp;a&nbsp;node&nbsp;with&nbsp;data</i><tt>&nbsp;"abcdefgh",<br>
DeleteData(offset=0,&nbsp;count=2)&nbsp;--&gt;&nbsp;"cdefgh"<br>
DeleteData(offset=5,&nbsp;count=5)&nbsp;--&gt;&nbsp;"abcde"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a>, <a href="Package-DOM.html#XmlDomAppendData"><tt>XmlDomAppendData</tt></a>, <a href="Package-DOM.html#XmlDomInsertData"><tt>XmlDomInsertData</tt></a>, <a href="Package-DOM.html#XmlDomReplaceData"><tt>XmlDomReplaceData</tt></a>, <a href="Package-DOM.html#XmlDomSplitText"><tt>XmlDomSplitText</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomFreeNode">XmlDomFreeNode</a></h2>

<table summary="Function 'XmlDomFreeNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomFreeNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Free a node allocated with XmlDomCreateXXX</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomFreeNode(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomFreeNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to free</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Free a node allocated with XmlDomCreateXXX.  Frees all resources
        associated with a node, then frees the node itself.  Certain parts
        of the node are under DOM control, and some parts may be under
        user control.  DOM keeps flags tracking who owns what, and only
        frees its own allocations.  The user is responsible for freeing
        their own parts of the node before calling XmlDomFreeNode.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCleanNode"><tt>XmlDomCleanNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomFreeNodeList">XmlDomFreeNodeList</a></h2>

<table summary="Function 'XmlDomFreeNodeList' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomFreeNodeList</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeList">NodeList</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Free a node list returned by XmlDomGetElemsByTag etc</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomFreeNodeList(xmlctx&nbsp;*xctx,&nbsp;xmlnodelist&nbsp;*list)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomFreeNodeList' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>list</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node list to free</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Free a node list returned by XmlDomGetElemsByTag or related
        functions, releasing all resources associated with it.  If
        given a node list that is part of the DOM proper (such as
        the children of a node), does nothing.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetElemsByTag"><tt>XmlDomGetElemsByTag</tt></a>, <a href="Package-DOM.html#XmlDomGetElemsByTagNS"><tt>XmlDomGetElemsByTagNS</tt></a>, <a href="Package-DOM.html#XmlDomGetChildrenByTag"><tt>XmlDomGetChildrenByTag</tt></a>, <a href="Package-DOM.html#XmlDomGetChildrenByTagNS"><tt>XmlDomGetChildrenByTagNS</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomFreeString">XmlDomFreeString</a></h2>

<table summary="Function 'XmlDomFreeString' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomFreeString</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Frees a string allocate by XmlDomSubstringData etc</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomFreeString(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*str)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomFreeString' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> document string belongs to</td></tr>
<tr><td scope=row><tt>str</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> string to free</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Frees the string allocated by XmlDomSubstringData or similar
        functions.  Note that strings explicitly saved with XmlDomSaveString
        et al are NOT freeable individually.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSaveString"><tt>XmlDomSaveString</tt></a>, <a href="Package-DOM.html#XmlDomSaveString2"><tt>XmlDomSaveString2</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttr">XmlDomGetAttr</a></h2>

<table summary="Function 'XmlDomGetAttr' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttr</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.getAttribute()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's value given its name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttr(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttr' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> named attribute's value [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the value of an element's attribute (specified by name).
        Note that an attribute may have the empty string as its value,
        but cannot be NULL.  If the element does not have an attribute
        with the given name, NULL is returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrNS"><tt>XmlDomGetAttrNS</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrs"><tt>XmlDomGetAttrs</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrNode"><tt>XmlDomGetAttrNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrLocal">XmlDomGetAttrLocal</a></h2>

<table summary="Function 'XmlDomGetAttrLocal' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrLocal</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Node.localName</tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns an attribute's namespace local name as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrLocal(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrLocal' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> attribute's local name [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an attribute's namespace local name (in the data encoding).
        If the attribute's name is not fully qualified (has no prefix), then
        the local name is the same as the name.<p>
        A length-encoded version is available as XmlDomGetAttrURILen which
        returns the local name as a pointer and length, for use if the 
        data is known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;foo&nbsp;xmlns:pfx="example_namespace"&nbsp;pfx:bar="bar_value"/&gt;<br>
XmlDomGetAttrLocal(attr&nbsp;pfx:bar)&nbsp;--&gt;&nbsp;"bar\0"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrLocalLen"><tt>XmlDomGetAttrLocalLen</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrName"><tt>XmlDomGetAttrName</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrURI"><tt>XmlDomGetAttrURI</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrPrefix"><tt>XmlDomGetAttrPrefix</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrLocalLen">XmlDomGetAttrLocalLen</a></h2>

<table summary="Function 'XmlDomGetAttrLocalLen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrLocalLen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns an attribute's namespace local name as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrLocalLen(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrLocalLen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  attribute node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of local name [<i>in characters</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> attr's local name [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an attribute's namespace local name (in the data encoding).
        If the attribute's name is not fully qualified (has no prefix), then
        the local name is the same as the name.<p>
        A NULL-terminated version is available as XmlDomGetAttrLocal which
        returns the local name as NULL-terminated string.  If the backing
        store is known to be XMLType, then the attribute's data will be stored
        internally as length-encoded.  Using the length-based Get functions
        will avoid having to copy and NULL-terminate the data.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;foo&nbsp;xmlns:pfx="example_namespace"&nbsp;pfx:bar="bar_value"/&gt;<br>
XmlDomGetAttrLocalLen(attr&nbsp;pfx:bar)&nbsp;--&gt;&nbsp;("bar",&nbsp;3)</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrLocal"><tt>XmlDomGetAttrLocal</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrName"><tt>XmlDomGetAttrName</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrURI"><tt>XmlDomGetAttrURI</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrPrefix"><tt>XmlDomGetAttrPrefix</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrNS">XmlDomGetAttrNS</a></h2>

<table summary="Function 'XmlDomGetAttrNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.getAttributeNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's value given its URI and localname</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's local name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> named attribute's value [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the value of an element's attribute (specified by URI and
        localname).  Note that an attribute may have the empty string as
        its value, but cannot be NULL.  If the element does not have an
        attribute with the given name, NULL is returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttr"><tt>XmlDomGetAttr</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrs"><tt>XmlDomGetAttrs</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrNode"><tt>XmlDomGetAttrNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrName">XmlDomGetAttrName</a></h2>

<table summary="Function 'XmlDomGetAttrName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Attr.name</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's name as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrName(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrName' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> name of attribute [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the fully-qualified name of an attribute (in the data
        encoding) as a NULL-terminated string, for example "bar\0" or
        "foo:bar\0".<p>
        A length-encoded version is available as XmlDomGetAttrNameLen which
        returns the attribute name as a pointer and length, for use if the 
        data is known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrNameLen"><tt>XmlDomGetAttrNameLen</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrURI"><tt>XmlDomGetAttrURI</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrPrefix"><tt>XmlDomGetAttrPrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrLocal"><tt>XmlDomGetAttrLocal</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrNameLen">XmlDomGetAttrNameLen</a></h2>

<table summary="Function 'XmlDomGetAttrNameLen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrNameLen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's name as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrNameLen(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrNameLen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  attribute node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of name [<i>in characters</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> name of attribute [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the fully-qualified name of an attribute (in the data
        encoding) as a length-encoded string, for example ("bar", 3) or
        ("foo:bar", 7).<p>
        A NULL-terminated version is available as XmlDomGetAttrName which
        returns the attribute name as NULL-terminated string.  If the backing
        store is known to be XMLType, then the attribute's data will be stored
        internally as length-encoded.  Using the length-based Get functions
        will avoid having to copy and NULL-terminate the data.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrName"><tt>XmlDomGetAttrName</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrURI"><tt>XmlDomGetAttrURI</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrPrefix"><tt>XmlDomGetAttrPrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrLocal"><tt>XmlDomGetAttrLocal</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrNode">XmlDomGetAttrNode</a></h2>

<table summary="Function 'XmlDomGetAttrNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.getAttributeNode()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get attribute by name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlattrnode*&nbsp;XmlDomGetAttrNode(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlattrnode *)</b></tt> attribute with the specified name [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an element's attribute specified by name.  If the node is
        not an element or the named attribute does not exist, returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrNodeNS"><tt>XmlDomGetAttrNodeNS</tt></a>, <a href="Package-DOM.html#XmlDomGetAttr"><tt>XmlDomGetAttr</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrNodeNS">XmlDomGetAttrNodeNS</a></h2>

<table summary="Function 'XmlDomGetAttrNodeNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrNodeNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.getAttributeNodeNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get attribute by name (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlattrnode*&nbsp;XmlDomGetAttrNodeNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrNodeNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's local name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlattrnode *)</b></tt> attribute node with the given URI/local name [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an element's attribute specified by URI and localname.  If
        the node is not an element or the named attribute does not exist,
        returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrNode"><tt>XmlDomGetAttrNode</tt></a>, <a href="Package-DOM.html#XmlDomGetAttr"><tt>XmlDomGetAttr</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrPrefix">XmlDomGetAttrPrefix</a></h2>

<table summary="Function 'XmlDomGetAttrPrefix' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrPrefix</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Node.prefix</tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns an attribute's namespace prefix</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrPrefix(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrPrefix' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> attribute's namespace prefix [<i>data encoding</i>] or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an attribute's namespace prefix (in the data encoding).  If
        the attribute's name is not fully qualified (has no prefix), NULL
        is returned.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;foo&nbsp;xmlns:pfx="example_namespace"&nbsp;pfx:bar="bar_value"/&gt;<br>
XmlDomGetAttrPrefix(attr&nbsp;pfx:bar)&nbsp;--&gt;&nbsp;"pfx\0"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrName"><tt>XmlDomGetAttrName</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrURI"><tt>XmlDomGetAttrURI</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrLocal"><tt>XmlDomGetAttrLocal</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrSpecified">XmlDomGetAttrSpecified</a></h2>

<table summary="Function 'XmlDomGetAttrSpecified' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrSpecified</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Attr.specified</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return flag saying whether an attribute was explicitly created</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlDomGetAttrSpecified(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrSpecified' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> attribute's "specified" flag</tr>
<tr><th scope=row><i>Description</i>
<td>        Return the 'specified' flag for an attribute.  If the attribute was
        explicitly given a value in the original document, this is TRUE;
        otherwise, it is FALSE.  If the node is not an attribute, returns
        FALSE.  If the user sets an attribute's value through DOM, its
        specified flag will be TRUE.  To return an attribute to its default
        value (if it has one), the attribute should be deleted-- it will
        then be re-created automatically with the default value (and specified
        will be FALSE).<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrURI">XmlDomGetAttrURI</a></h2>

<table summary="Function 'XmlDomGetAttrURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Node.namespaceURI</tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns an attribute's namespace URI as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrURI(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> attribute's namespace URI [<i>data encoding</i>] or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an attribute's namespace URI (in the data encoding).  If
        the attribute's name is not qualified (does not contain a namespace
        prefix), it will have the default namespace in effect when the node
        was created (which may be NULL).<p>
        A length-encoded version is available as XmlDomGetAttrURILen which
        returns the URI as a pointer and length, for use if the 
        data is known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;foo&nbsp;xmlns:pfx="example_namespace"&nbsp;pfx:bar="bar_value"/&gt;<br>
XmlDomGetAttrURI(attr&nbsp;pfx:bar)&nbsp;--&gt;&nbsp;"example_namespace\0"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrURILen"><tt>XmlDomGetAttrURILen</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrPrefix"><tt>XmlDomGetAttrPrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrLocal"><tt>XmlDomGetAttrLocal</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrURILen">XmlDomGetAttrURILen</a></h2>

<table summary="Function 'XmlDomGetAttrURILen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrURILen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns an attribute's namespace URI as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrURILen(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrURILen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  attribute node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of URI [<i>in characters</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> attribute's namespace URI [<i>data encoding</i>] or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an attribute's namespace URI (in the data encoding) as
        length-encoded string.  If the attribute's name is not qualified
        (does not contain a namespace prefix), it will have the default
        namespace in effect when the node was created (which may be NULL).<p>
        A NULL-terminated version is available as XmlDomGetAttrURI which
        returns the URI as NULL-terminated string.  If the backing
        store is known to be XMLType, then the attribute's data will be stored
        internally as length-encoded.  Using the length-based Get functions
        will avoid having to copy and NULL-terminate the data.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;foo&nbsp;xmlns:pfx="example_namespace"&nbsp;pfx:bar="bar_value"/&gt;<br>
XmlDomGetAttrURILen(attr&nbsp;pfx:bar)&nbsp;--&gt;&nbsp;("example_namespace",&nbsp;17)</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrURI"><tt>XmlDomGetAttrURI</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrPrefix"><tt>XmlDomGetAttrPrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetAttrLocal"><tt>XmlDomGetAttrLocal</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrValue">XmlDomGetAttrValue</a></h2>

<table summary="Function 'XmlDomGetAttrValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Attr.value</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's value as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrValue(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrValue' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> attribute's value</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the "value" (character data) of an attribute (in the data
        encoding) as NULL-terminated string.  Character and general entities
        will have been replaced.<p>
        A length-encoded version is available as XmlDomGetAttrValueLen which
        returns the attribute value as a pointer and length, for use if the 
        data is known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrValueLen"><tt>XmlDomGetAttrValueLen</tt></a>, <a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrValueLen">XmlDomGetAttrValueLen</a></h2>

<table summary="Function 'XmlDomGetAttrValueLen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrValueLen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's value as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetAttrValueLen(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrValueLen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  attribute node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of attr's value [<i>in characters</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> attribute's value</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the "value" (character data) of an attribute (in the data
        encoding) as length-encoded string.  Character and general entities
        will have been replaced.<p>
        A NULL-terminated version is available as XmlDomGetAttrValue which
        returns the attribute value as NULL-terminated string.  If the backing
        store is known to be XMLType, then the attribute's data will be stored
        internally as length-encoded.  Using the length-based Get functions
        will avoid having to copy and NULL-terminate the data.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrValue"><tt>XmlDomGetAttrValue</tt></a>, <a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetAttrs">XmlDomGetAttrs</a></h2>

<table summary="Function 'XmlDomGetAttrs' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetAttrs</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.attributes</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attributes of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnamedmap*&nbsp;XmlDomGetAttrs(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetAttrs' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML element node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnamedmap *)</b></tt> NamedNodeMap of node's attributes</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a NamedNodeMap of attributes of an element node, or NULL
        if it has no attributes.  For other node types, NULL is returned.
        Note that if an element once had attributes, but they have all been
        removed, an empty list will be returned.  So, presense of the list
        does not mean the element has attributes.  You must check the size
        of the list with XmlDomNumAttrs or use XmlDomHasChildNodes first.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomNumAttrs"><tt>XmlDomNumAttrs</tt></a>, <a href="Package-DOM.html#XmlDomHasChildNodes"><tt>XmlDomHasChildNodes</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetBaseURI">XmlDomGetBaseURI</a></h2>

<table summary="Function 'XmlDomGetBaseURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetBaseURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 3: Node.baseURI</tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns the base URI for a document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext&nbsp;*XmlDomGetBaseURI(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetBaseURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> document's base URI [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the base URI for a document.  Usually only documents that
        were loaded from a URI will automatically have a base URI; documents
        loaded from other sources (stdin, buffer, etc) will not naturally
        have a base URI, but a base URI may have been set for them using
        XmlDomSetBaseURI, for the purposes of resolving relative URIs in
        inclusion.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetBaseURI"><tt>XmlDomSetBaseURI</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetCharData">XmlDomGetCharData</a></h2>

<table summary="Function 'XmlDomGetCharData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetCharData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: CharacterData.data</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return data for node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetCharData(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetCharData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> CharacterData node [<i>text, comment, or CDATA</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> character data of node [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the data for a CharacterData node (type text, comment or
        CDATA) in the data encoding.  For other node types, or if there
        is no data, returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetCharData"><tt>XmlDomSetCharData</tt></a>, <a href="Package-DOM.html#XmlDomCreateText"><tt>XmlDomCreateText</tt></a>, <a href="Package-DOM.html#XmlDomCreateComment"><tt>XmlDomCreateComment</tt></a>, <a href="Package-DOM.html#XmlDomCreateCDATA"><tt>XmlDomCreateCDATA</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetCharDataLength">XmlDomGetCharDataLength</a></h2>

<table summary="Function 'XmlDomGetCharDataLength' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetCharDataLength</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: CharacterData.length</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return length of data for node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlDomGetCharDataLength(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*cdata)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetCharDataLength' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> CharacterData node [<i>text, comment, or CDATA</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> length in characters (not bytes!) of node's data</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the length of the data for a CharacterData node (type text,
        comment or CDATA) in characters (not bytes!).  For other node types,
        returns 0.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetChildNodes">XmlDomGetChildNodes</a></h2>

<table summary="Function 'XmlDomGetChildNodes' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetChildNodes</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.getChildNodes()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return children of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodelist*&nbsp;XmlDomGetChildNodes(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetChildNodes' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodelist *)</b></tt> live NodeList containing all children of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of the node's children, or NULL if it has no
        children.  Only Element, Document, DTD, and DocumentFragment
        nodes may have children; all other types will return NULL.<p>
        Note that an empty list may be returned if the node once had
        children, but all have been removed!  That is, the list may
        exist but have no members.  So, presense of the list alone does
        not mean the node has children.  You must check the size of the
        list with XmlDomNumChildNodes or use XmlDomHasChildNodes first.<p>
        The xmlnodelist structure is opaque and can only be manipulated
        with functions in the NodeList interface.<p>
        The returned list is live; all changes in the original node are
        reflected immediately.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetChildrenByTag">XmlDomGetChildrenByTag</a></h2>

<table summary="Function 'XmlDomGetChildrenByTag' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetChildrenByTag</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get children of element with given tag name [non-namespace-aware]</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodelist*&nbsp;XmlDomGetChildrenByTag(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetChildrenByTag' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> tag name to match [<i>data encoding; {"*"} for any</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodelist *)</b></tt> node list of matching children</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of children of an element with the given tag name,
        in the order in which they would be encountered in a preorder
        traversal of the tree. The tag name should be in the data encoding.
        The special name <tt>"*"</tt> matches all tag names; a NULL name matches
        nothing.  Note that tag names are CASE SENSITIVE.  This function
        is not namespace aware; the full tag names are compared.  If two
        prefixes which map to the same URI are compared, the comparison
        will fail.  See XmlDomGetChildrenByTagNS for the namespace-aware
        version.  The returned list can be freed with XmlDomFreeNodeList.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetChildrenByTagNS"><tt>XmlDomGetChildrenByTagNS</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetChildrenByTagNS">XmlDomGetChildrenByTagNS</a></h2>

<table summary="Function 'XmlDomGetChildrenByTagNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetChildrenByTagNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get children of element with tag name [namespace-aware version]</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodelist*&nbsp;XmlDomGetChildrenByTagNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetChildrenByTagNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> namespace URI to match [<i>data encoding; {"*"} for</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> local name to match [<i>data encoding; {"*"} for any</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodelist *)</b></tt> node list of matching children</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of children of an element with the given URI and
        local name, in the order in which they would be encountered in a
        preorder traversal of the tree.  The URI and local name should be
        in the data encoding.  The special name <tt>"*"</tt> matches all URIs or
        tag names; a NULL name matches nothing.  Note that names are
        CASE SENSITIVE.  See XmlDomGetChildrenByTag for the non-namespace
        version.  The returned list can be freed with XmlDomFreeNodeList.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetChildrenByTag"><tt>XmlDomGetChildrenByTag</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDTD">XmlDomGetDTD</a></h2>

<table summary="Function 'XmlDomGetDTD' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDTD</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.doctype</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD (Document Type) for document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmldtdnode*&nbsp;XmlDomGetDTD(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDTD' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmldtdnode *)</b></tt> DTD node for document [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the DTD node associated with current document; if there
        is no DTD, returns NULL.  The DTD cannot be edited, but its
        children may be retrieved with XmlDomGetChildNodes as for other
        node types.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetDTD"><tt>XmlDomSetDTD</tt></a>, <a href="Package-XML.html#XmlCreateDTD"><tt>XmlCreateDTD</tt></a>, <a href="Package-XML.html#XmlCreateDocument"><tt>XmlCreateDocument</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDName"><tt>XmlDomGetDTDName</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDEntities"><tt>XmlDomGetDTDEntities</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDNotations"><tt>XmlDomGetDTDNotations</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDTDEntities">XmlDomGetDTDEntities</a></h2>

<table summary="Function 'XmlDomGetDTDEntities' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDTDEntities</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentType">DocumentType</a>; DOM 2: DocumentType.entities</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entities of DTD</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnamedmap*&nbsp;XmlDomGetDTDEntities(xmlctx&nbsp;*xctx,&nbsp;xmldtdnode&nbsp;*dtd)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDTDEntities' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>dtd</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> DTD node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnamedmap *)</b></tt> named node map containing entities declared in DTD</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a named node map of general entities defined by the DTD.
        If the node is not a DTD, or has no general entities, returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDTD"><tt>XmlDomGetDTD</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDName"><tt>XmlDomGetDTDName</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDNotations"><tt>XmlDomGetDTDNotations</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDSysID"><tt>XmlDomGetDTDSysID</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDInternalSubset"><tt>XmlDomGetDTDInternalSubset</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDTDInternalSubset">XmlDomGetDTDInternalSubset</a></h2>

<table summary="Function 'XmlDomGetDTDInternalSubset' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDTDInternalSubset</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentType">DocumentType</a>; DOM 2: DocumentType.internalSubset</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's internal subset</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetDTDInternalSubset(xmlctx&nbsp;*xctx,&nbsp;xmldtdnode&nbsp;*dtd,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDTDInternalSubset' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>dtd</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> DTD node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name of Element [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> content model subtree</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the content model for an element.  If there is no DTD,
        returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDTD"><tt>XmlDomGetDTD</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDName"><tt>XmlDomGetDTDName</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDEntities"><tt>XmlDomGetDTDEntities</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDNotations"><tt>XmlDomGetDTDNotations</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDPubID"><tt>XmlDomGetDTDPubID</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDTDName">XmlDomGetDTDName</a></h2>

<table summary="Function 'XmlDomGetDTDName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDTDName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentType">DocumentType</a>; DOM 2: DocumentType.name</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get name of DTD</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetDTDName(xmlctx&nbsp;*xctx,&nbsp;xmldtdnode&nbsp;*dtd)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDTDName' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>dtd</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> DTD node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> name of DTD</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a DTD's name (specified immediately after the <tt>DOCTYPE</tt>
        keyword), or NULL if the node is not type DTD.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDTD"><tt>XmlDomGetDTD</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDEntities"><tt>XmlDomGetDTDEntities</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDNotations"><tt>XmlDomGetDTDNotations</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDSysID"><tt>XmlDomGetDTDSysID</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDInternalSubset"><tt>XmlDomGetDTDInternalSubset</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDTDNotations">XmlDomGetDTDNotations</a></h2>

<table summary="Function 'XmlDomGetDTDNotations' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDTDNotations</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentType">DocumentType</a>; DOM 2: DocumentType.notations</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get notations of DTD</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnamedmap*&nbsp;XmlDomGetDTDNotations(xmlctx&nbsp;*xctx,&nbsp;xmldtdnode&nbsp;*dtd)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDTDNotations' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>dtd</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> DTD node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnamedmap *)</b></tt> named node map containing notations declared in DTD</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns named node map of notations declared by the DTD.  If the
        node is not a DTD or has no notations, returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDTD"><tt>XmlDomGetDTD</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDName"><tt>XmlDomGetDTDName</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDEntities"><tt>XmlDomGetDTDEntities</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDSysID"><tt>XmlDomGetDTDSysID</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDInternalSubset"><tt>XmlDomGetDTDInternalSubset</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDTDPubID">XmlDomGetDTDPubID</a></h2>

<table summary="Function 'XmlDomGetDTDPubID' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDTDPubID</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentType">DocumentType</a>; DOM 2: DocumentType.publicID</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's public ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetDTDPubID(xmlctx&nbsp;*xctx,&nbsp;xmldtdnode&nbsp;*dtd)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDTDPubID' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>dtd</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> DTD node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> DTD's public identifier [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a DTD's public identifier.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDTD"><tt>XmlDomGetDTD</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDName"><tt>XmlDomGetDTDName</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDEntities"><tt>XmlDomGetDTDEntities</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDSysID"><tt>XmlDomGetDTDSysID</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDInternalSubset"><tt>XmlDomGetDTDInternalSubset</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDTDSysID">XmlDomGetDTDSysID</a></h2>

<table summary="Function 'XmlDomGetDTDSysID' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDTDSysID</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentType">DocumentType</a>; DOM 2: DocumentType.systemID</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's system ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetDTDSysID(xmlctx&nbsp;*xctx,&nbsp;xmldtdnode&nbsp;*dtd)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDTDSysID' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>dtd</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> DTD node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> DTD's system identifier [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a DTD's system identifier.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDTD"><tt>XmlDomGetDTD</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDName"><tt>XmlDomGetDTDName</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDEntities"><tt>XmlDomGetDTDEntities</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDPubID"><tt>XmlDomGetDTDPubID</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDInternalSubset"><tt>XmlDomGetDTDInternalSubset</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDecl">XmlDomGetDecl</a></h2>

<table summary="Function 'XmlDomGetDecl' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDecl</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns a document's XMLDecl information</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomGetDecl(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;**ver,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;**enc,&nbsp;sb4&nbsp;*std)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDecl' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>ver</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> XML version</td></tr>
<tr><td scope=row><tt>enc</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> encoding specification</td></tr>
<tr><td scope=row><tt>std</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> standalone specification</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> XML error code, perhaps version/encoding/standalone set</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the information from a document's XMLDecl.  If there is
        no XMLDecl, returns XMLERR_NO_DECL.  Returned are the XML version#
        ("1.0" or "2.0"), the specified encoding, and the standalone value.
        If encoding is not specified, NULL will be set.  The standalone flag
        is three-state: <tt>&lt; 0 if standalone was not specified, 0 if it was
        specified and FALSE, &gt;</tt> 0 if it was specified and TRUE.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetDefaultNS">XmlDomGetDefaultNS</a></h2>

<table summary="Function 'XmlDomGetDefaultNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDefaultNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get default namespace for node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetDefaultNS(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDefaultNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element/attribute DOM node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> default namespace for node [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Gets the default namespace for a node.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetDocElem">XmlDomGetDocElem</a></h2>

<table summary="Function 'XmlDomGetDocElem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDocElem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.documentElement</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get top-level element for document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlelemnode*&nbsp;XmlDomGetDocElem(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDocElem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlelemnode *)</b></tt> root element [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the root element (node) of the DOM tree, or NULL if there
        is none.  Each document has only one uppermost Element node, called
        the root element.  It is created after a document is parsed
        successfully, or manually by XmlDomCreateElem then XmlDomAppendChild,
        etc.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCreateElem"><tt>XmlDomCreateElem</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDocElemByID">XmlDomGetDocElemByID</a></h2>

<table summary="Function 'XmlDomGetDocElemByID' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDocElemByID</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.getElementById()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get document element given ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlelemnode*&nbsp;XmlDomGetDocElemByID(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*id)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDocElemByID' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>id</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element's unique ID [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlelemnode *)</b></tt> matching element.</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the element node which has the given ID.  If no such ID is
        defined, returns NULL.  Note that attributes named "ID" are not
        automatically of type ID; ID attributes (which can have any name)
        must be declared as type ID in the DTD.<p>
        The given ID should be in the data encoding or it might not match.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDocElemsByTag"><tt>XmlDomGetDocElemsByTag</tt></a>, <a href="Package-DOM.html#XmlDomGetDocElemsByTagNS"><tt>XmlDomGetDocElemsByTagNS</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDocElemsByTag">XmlDomGetDocElemsByTag</a></h2>

<table summary="Function 'XmlDomGetDocElemsByTag' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDocElemsByTag</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.getElementsByTagName()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Obtain doc elements</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodelist*&nbsp;XmlDomGetDocElemsByTag(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDocElemsByTag' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> tagname to match [<i>data encoding; "*" for all</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodelist *)</b></tt> new NodeList containing all matched Elements.</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of all elements in the document tree rooted at the
        root node with a given tag name, in document order (i.e. the order
        in which they would be encountered in a preorder traversal of the
        tree).  If root is NULL, the entire document is searched.<p>
        The special name "*" matches all tag names; a NULL name matches
        nothing.  Note that tag names are CASE SENSITIVE, and should be in
        the data encoding or a mismatch might occur.<p>
        This function is not namespace aware; the full tag names are compared.
        If two QNames with two different prefixes both of which map to the
        same URI are compared, the comparison will fail.  See
        XmlDomGetElemsByTagNS for the namespace-aware version.<p>
        The list should be freed with XmlDomFreeNodeList when it is no
        longer needed.<p>
        The list is NOT live, it is a snapshot.  That is, if a new node
        which matched the tag name were added to the DOM after the list
        was returned, the list would not automatically be updated to
        include the node.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDocElemByID"><tt>XmlDomGetDocElemByID</tt></a>, <a href="Package-DOM.html#XmlDomGetDocElemsByTagNS"><tt>XmlDomGetDocElemsByTagNS</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetDocElemsByTagNS">XmlDomGetDocElemsByTagNS</a></h2>

<table summary="Function 'XmlDomGetDocElemsByTagNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetDocElemsByTagNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.getElementsByTagNameNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Obtain doc elements (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodelist*&nbsp;XmlDomGetDocElemsByTagNS(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetDocElemsByTagNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> namespace URI to match [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> local name to match [<i>data encoding; "*" for all</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodelist *)</b></tt> new NodeList containing all matched Elements.</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of all elements (in the document tree rooted at the
        given node) with a given namespace URI and local name, in the order
        in which they would be encountered in a preorder traversal of the
        tree.  If root is NULL, the entire document is searched.<p>
        The URI and local name should be in the data encoding.  The special
        local name "*" matches all local names; a NULL local name matches
        nothing.  Namespace URIs must always match, however, no wildcard is
        allowed.  Note that comparisons are CASE SENSITIVE.  See
        XmlDomGetDocElemsByTag for the non-namespace aware version.<p>
        The list should be freed with XmlDomFreeNodeList when it is no
        longer needed.<p>
        The list is NOT live, it is a snapshot.  That is, if a new node
        which matched the tag name were added to the DOM after the list
        was returned, the list would not automatically be updated to
        include the node.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDocElemByID"><tt>XmlDomGetDocElemByID</tt></a>, <a href="Package-DOM.html#XmlDomGetDocElemsByTag"><tt>XmlDomGetDocElemsByTag</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetElemsByTag">XmlDomGetElemsByTag</a></h2>

<table summary="Function 'XmlDomGetElemsByTag' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetElemsByTag</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.getElementsByTagName()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get elements with given tag name [non-namespace-aware version]</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodelist*&nbsp;XmlDomGetElemsByTag(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetElemsByTag' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> tag name to match [<i>data encoding; {"*"} for any tag</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodelist *)</b></tt> node list of matching elements</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of all elements (in the document tree rooted at the
        root node) with a given tag name, in the order in which they would
        be encountered in a preorder traversal of the tree.  If root is NULL,
        the entire document is searched.  The tag name should be in the data
        encoding.  The special name <tt>"*"</tt> matches all tag names; a NULL name
        matches nothing.  Note that tag names are CASE SENSITIVE.  This
        function is not namespace aware; the full tag names are compared.
        If two prefixes which map to the same URI are compared, the
        comparison will fail.  See XmlDomGetElemsByTagNS for the
        namespace-aware version.  The returned list can be freed with
        XmlDomFreeNodeList.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetElemsByTagNS"><tt>XmlDomGetElemsByTagNS</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetElemsByTagNS">XmlDomGetElemsByTagNS</a></h2>

<table summary="Function 'XmlDomGetElemsByTagNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetElemsByTagNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.getElementsByTagNameNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get elements with given URI and localname [namespace aware version]</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodelist*&nbsp;XmlDomGetElemsByTagNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetElemsByTagNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> namespace URI to match [<i>data encoding; {"*"} matches any</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> local name to match [<i>data encoding; {"*"} matches any</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodelist *)</b></tt> node list of matching elements</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of all elements (in the document tree rooted at the
        root node) with a given URI and localname, in the order in which they
        would be encountered in a preorder traversal of the tree.  If root is
        NULL, the entire document is searched.  The tag name should be in the
        data encoding.  The special name <tt>"*"</tt> matches all tag names; a NULL
        name matches nothing.  Note that tag names are CASE SENSITIVE.  This
        function is not namespace aware; the full tag names are compared.
        If two prefixes which map to the same URI are compared, the
        comparison will fail.  The returned list can be freed with
        XmlDomFreeNodeList.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDocElemsByTag"><tt>XmlDomGetDocElemsByTag</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetEntityNotation">XmlDomGetEntityNotation</a></h2>

<table summary="Function 'XmlDomGetEntityNotation' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetEntityNotation</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Entity">Entity</a>; DOM 2: Entity.notationName</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's notation</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetEntityNotation(xmlctx&nbsp;*xctx,&nbsp;xmlentnode&nbsp;*ent)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetEntityNotation' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>ent</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> entity node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> entity's notation [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        For unparsed entities, returns the name of its notation (in the data
        encoding).  For parsed entities and other node types, returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetEntityPubID"><tt>XmlDomGetEntityPubID</tt></a>, <a href="Package-DOM.html#XmlDomGetEntitySysID"><tt>XmlDomGetEntitySysID</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetEntityPubID">XmlDomGetEntityPubID</a></h2>

<table summary="Function 'XmlDomGetEntityPubID' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetEntityPubID</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Entity">Entity</a>; DOM 2: Entity.publicId</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's public ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetEntityPubID(xmlctx&nbsp;*xctx,&nbsp;xmlentnode&nbsp;*ent)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetEntityPubID' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>ent</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> entity node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> entity's public identifier [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an entity's public identifier (in the data encoding).  If
        the node is not an entity, or has no defined public ID, returns NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetEntitySysID"><tt>XmlDomGetEntitySysID</tt></a>, <a href="Package-DOM.html#XmlDomGetEntityNotation"><tt>XmlDomGetEntityNotation</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetEntitySysID">XmlDomGetEntitySysID</a></h2>

<table summary="Function 'XmlDomGetEntitySysID' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetEntitySysID</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Entity">Entity</a>; DOM 2: Entity.systemId</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's system ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetEntitySysID(xmlctx&nbsp;*xctx,&nbsp;xmlentnode&nbsp;*ent)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetEntitySysID' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>ent</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> entity node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> entity's system identifier [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an entity's system identifier (in the data encoding).  If
        the node is not an entity, or has no defined system ID, returns
        NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetEntityPubID"><tt>XmlDomGetEntityPubID</tt></a>, <a href="Package-DOM.html#XmlDomGetEntityNotation"><tt>XmlDomGetEntityNotation</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetEntityType">XmlDomGetEntityType</a></h2>

<table summary="Function 'XmlDomGetEntityType' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetEntityType</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Entity">Entity</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's type</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlDomGetEntityType(xmlctx&nbsp;*xctx,&nbsp;xmlentnode&nbsp;*ent)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetEntityType' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>ent</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> entity node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE for general entity, FALSE for parameter entity</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a boolean for an entity describing whether it is general
        (TRUE) or parameter (FALSE).<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetEntityPubID"><tt>XmlDomGetEntityPubID</tt></a>, <a href="Package-DOM.html#XmlDomGetEntitySysID"><tt>XmlDomGetEntitySysID</tt></a>, <a href="Package-DOM.html#XmlDomGetEntityNotation"><tt>XmlDomGetEntityNotation</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetFirstChild">XmlDomGetFirstChild</a></h2>

<table summary="Function 'XmlDomGetFirstChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetFirstChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.getFirstChild()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns first child of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetFirstChild(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetFirstChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> first child of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the first child of a node, or NULL if the node has no
        children.  Only Element, Document, DTD, and DocumentFragment
        nodes may have children; all other types will return NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetLastChild"><tt>XmlDomGetLastChild</tt></a>, <a href="Package-DOM.html#XmlDomHasChildNodes"><tt>XmlDomHasChildNodes</tt></a>, <a href="Package-DOM.html#XmlDomGetChildNodes"><tt>XmlDomGetChildNodes</tt></a>, <a href="Package-DOM.html#XmlDomNumChildNodes"><tt>XmlDomNumChildNodes</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetFirstPfnsPair">XmlDomGetFirstPfnsPair</a></h2>

<table summary="Function 'XmlDomGetFirstPfnsPair' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetFirstPfnsPair</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get first prefix namespace pair</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlpfnspair*&nbsp;XmlDomGetFirstPfnsPair(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;**prefix,&nbsp;oratext&nbsp;**uri)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetFirstPfnsPair' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  Node whose prefix/URI pairs are to be iterated</td></tr>
<tr><td scope=row><tt>prefix</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> prefix of first mapping [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> URI of first mapping [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlpfnspair *)</b></tt> iterating object or NULL of no prefixes</tr>
<tr><th scope=row><i>Description</i>
<td>        This function is to allow implementations an opportunity to
        speedup the iteration of all available prefix-Uri bindings
        available on a given node.  It returns a state structure and
        the prefix and URI of the first prefix-URI mapping.  The
        state structure should be passed to XmlDomGetNextPfnsPair to
        fetch the remaining pairs.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetLastChild">XmlDomGetLastChild</a></h2>

<table summary="Function 'XmlDomGetLastChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetLastChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.getLastChild()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns last child of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetLastChild(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetLastChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> last child of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the last child of a node, or NULL if the node has no
        children.  Only Element, Document, DTD, and DocumentFragment
        nodes may have children; all other types will return NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetFirstChild"><tt>XmlDomGetFirstChild</tt></a>, <a href="Package-DOM.html#XmlDomHasChildNodes"><tt>XmlDomHasChildNodes</tt></a>, <a href="Package-DOM.html#XmlDomGetChildNodes"><tt>XmlDomGetChildNodes</tt></a>, <a href="Package-DOM.html#XmlDomNumChildNodes"><tt>XmlDomNumChildNodes</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetLastError">XmlDomGetLastError</a></h2>

<table summary="Function 'XmlDomGetLastError' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetLastError</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return last error code for document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomGetLastError(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetLastError' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, 0 if no error</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the error code of the last error which occured in
        the given document.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetNamedItem">XmlDomGetNamedItem</a></h2>

<table summary="Function 'XmlDomGetNamedItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNamedItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a>; DOM 2: NamedNodeMap.getNamedItem()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return named node from list</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetNamedItem(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNamedItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name of node to retrieve [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> Node with the specified name [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Retrieves an item from a NamedNodeMap, specified by name (which
        should be in the data encoding).  This is a non-namespace-aware
        function; it just matches (case sensitively) on the whole QName.
        Note this function differs from the DOM spec in that the index
        of the matching item is also returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNamedItemNS"><tt>XmlDomGetNamedItemNS</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapItem"><tt>XmlDomGetNodeMapItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapLength"><tt>XmlDomGetNodeMapLength</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNamedItemNS">XmlDomGetNamedItemNS</a></h2>

<table summary="Function 'XmlDomGetNamedItemNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNamedItemNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return named node from list (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetNamedItemNS(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNamedItemNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> namespace URI of node to retrieve [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> local name of node to retrieve [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node with given local name and namespace URI [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Retrieves an item from a NamedNodeMap, specified by URI and
        localname (which should be in the data encoding).  Note this
        function differs from the DOM spec in that the index of the
        matching item is also returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNamedItem"><tt>XmlDomGetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapItem"><tt>XmlDomGetNodeMapItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapLength"><tt>XmlDomGetNodeMapLength</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNextPfnsPair">XmlDomGetNextPfnsPair</a></h2>

<table summary="Function 'XmlDomGetNextPfnsPair' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNextPfnsPair</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get subsequent prefix namespace pair</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlpfnspair*&nbsp;XmlDomGetNextPfnsPair(xmlctx&nbsp;*xctx,&nbsp;xmlpfnspair&nbsp;*pfns,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;**prefix,&nbsp;oratext&nbsp;**uri)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNextPfnsPair' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>pfns</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  iterator object returned by XmlDomGetFirstPfnsPair</td></tr>
<tr><td scope=row><tt>prefix</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> prefix of next mapping [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> URI of next mapping [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlpfnspair *)</b></tt> iterating object, NULL when no more pairs</tr>
<tr><th scope=row><i>Description</i>
<td>        This function is to allow implementations an opportunity to
        speedup the iteration of all available prefix-URI bindings
        available on a given node.  Given an iterator structure from
        XmlDomGetFirstPfnsPair, returns the next prefix-URI mapping;
        repeat calls to XmlDomGetNextPfnsPair until NULL is returned.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetNextSibling">XmlDomGetNextSibling</a></h2>

<table summary="Function 'XmlDomGetNextSibling' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNextSibling</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.nextSibling</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return next sibling of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetNextSibling(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNextSibling' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node immediately following node at same level</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the node following a node at the same level in the DOM tree.
        That is, for each child of a parent node, the next sibling of that
        child is the child which comes after it.  If a node is the last child
        of its parent, or has no parent, NULL is returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetPrevSibling"><tt>XmlDomGetPrevSibling</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeListItem">XmlDomGetNodeListItem</a></h2>

<table summary="Function 'XmlDomGetNodeListItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeListItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeList">NodeList</a>; DOM 2: NodeList.item()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return nth node in list</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetNodeListItem(xmlctx&nbsp;*xctx,&nbsp;xmlnodelist&nbsp;*list,&nbsp;ub4&nbsp;index)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeListItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>list</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node list</td></tr>
<tr><td scope=row><tt>index</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> index into list</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node at the nth position in node list [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Return nth node in a node list.  The first item is index 0.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeListLength"><tt>XmlDomGetNodeListLength</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeListLength">XmlDomGetNodeListLength</a></h2>

<table summary="Function 'XmlDomGetNodeListLength' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeListLength</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeList">NodeList</a>; DOM 2: NodeList.length</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return length of node list</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlDomGetNodeListLength(xmlctx&nbsp;*xctx,&nbsp;xmlnodelist&nbsp;*list)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeListLength' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>list</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node list</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> number of nodes in node list</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the number of nodes in a node list (i.e. its length).
        Note that nodes are referred to by index, so the range of
        valid indexes is 0 through length-1.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeListItem"><tt>XmlDomGetNodeListItem</tt></a>, <a href="Package-DOM.html#XmlDomFreeNodeList"><tt>XmlDomFreeNodeList</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeLocal">XmlDomGetNodeLocal</a></h2>

<table summary="Function 'XmlDomGetNodeLocal' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeLocal</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.localName</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get local part of node's qualified name as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeLocal(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeLocal' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> local name of node [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the namespace local name for a node as a NULL-terminated
        string.  If the node's name is not fully qualified (has no prefix),
        then the local name is the same as the name.<p>
        A length-encoded version is available as XmlDomGetNodeLocalLen which
        returns the local name as a pointer and length, for use if the data is
        known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;pfx:foo&nbsp;xmlns:pfx="example_namespace"/&gt;<br>
XmlDomGetNodeLocal(element&nbsp;pfx:foo)&nbsp;--&gt;&nbsp;"foo\0"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeLocalLen"><tt>XmlDomGetNodeLocalLen</tt></a>, <a href="Package-DOM.html#XmlDomGetNodePrefix"><tt>XmlDomGetNodePrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeURI"><tt>XmlDomGetNodeURI</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeLocalLen">XmlDomGetNodeLocalLen</a></h2>

<table summary="Function 'XmlDomGetNodeLocalLen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeLocalLen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get local part of node's qualified name as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeLocalLen(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeLocalLen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of local name [<i>in characters</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> local name of node [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the namespace local name for a node as a length-encoded
        string.  If the node's name is not fully qualified (has no prefix),
        then the local name is the same as the name.<p>
        A NULL-terminated version is available as XmlDomGetNodeLocal which
        returns the local name as NULL-terminated string.  If the backing
        store is known to be XMLType, then the node's data will be stored
        internally as length-encoded.  Using the length-based Get functions
        will avoid having to copy and NULL-terminate the data.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;pfx:foo&nbsp;xmlns:pfx="example_namespace"/&gt;<br>
XmlDomGetNodeLocalLen(element&nbsp;pfx:foo)&nbsp;--&gt;&nbsp;("foo",&nbsp;3)</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeLocal"><tt>XmlDomGetNodeLocal</tt></a>, <a href="Package-DOM.html#XmlDomGetNodePrefix"><tt>XmlDomGetNodePrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeURILen"><tt>XmlDomGetNodeURILen</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeMapItem">XmlDomGetNodeMapItem</a></h2>

<table summary="Function 'XmlDomGetNodeMapItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeMapItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a>; DOM 2: NamedNodeMap.item()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return nth node in list</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetNodeMapItem(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map,&nbsp;ub4&nbsp;index)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeMapItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
<tr><td scope=row><tt>index</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> index into this map, starts from 0</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node at the nth position in the map (or NULL)</tr>
<tr><th scope=row><i>Description</i>
<td>        Retrieves an item from a NamedNodeMap, specified by name (which
        should be in the data encoding).  This is a non-namespace-aware
        function; it just matches (case sensitively) on the whole QName.
        Note this function differs from the DOM spec in that the index
        of the matching item is also returned.  Named "item" in W3C spec.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNamedItem"><tt>XmlDomGetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomSetNamedItem"><tt>XmlDomSetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomRemoveNamedItem"><tt>XmlDomRemoveNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapLength"><tt>XmlDomGetNodeMapLength</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeMapLength">XmlDomGetNodeMapLength</a></h2>

<table summary="Function 'XmlDomGetNodeMapLength' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeMapLength</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a>; DOM 2: NamedNodeMap.length</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return length of named node map</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlDomGetNodeMapLength(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeMapLength' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> number of nodes in NamedNodeMap</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the number of nodes in a NamedNodeMap (the length).
        Note that nodes are referred to by index, and the range of
        valid indexes is 0 through length-1.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeMapItem"><tt>XmlDomGetNodeMapItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItem"><tt>XmlDomGetNamedItem</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeName">XmlDomGetNodeName</a></h2>

<table summary="Function 'XmlDomGetNodeName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.getNodeName()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node's name as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeName(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeName' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> name of node [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the (fully-qualified) name of a node (in the data encoding)
        as a NULL-terminated string, for example "bar\0" or "foo:bar\0".<p>
        Note that some node types have fixed names: "#text", "#cdata-section",
        "#comment", "#document", "#document-fragment".<p>
        A node's name cannot be changed once it is created, so there is
        no matching SetNodeName function.<p>
        A length-based version is available as XmlDomGetNodeNameLen which
        returns the node name as a pointer and length, for use if the data
        is known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeNameLen"><tt>XmlDomGetNodeNameLen</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeNameLen">XmlDomGetNodeNameLen</a></h2>

<table summary="Function 'XmlDomGetNodeNameLen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeNameLen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node's name as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeNameLen(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeNameLen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of name [<i>in characters</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> name of node, with length of name set in 'len'</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the (fully-qualified) name of a node (in the data encoding)
        as a length-encoded string, for example <tt>"bar", 3</tt> or <tt>"foo:bar", 7</tt>.<p>
        Note that some node types have fixed names: "#text", "#cdata-section",
        "#comment", "#document", "#document-fragment".<p>
        A node's name cannot be changed once it is created, so there is
        no matching SetNodeName function.<p>
        A NULL-terminated version is available as XmlDomGetNodeName which
        returns the node name as NULL-terminated string.  If the backing
        store is known to be XMLType, then the node's name will be stored
        internally as length-encoded.  Using the length-encoded Get
        functions will avoid having to copy and NULL-terminate the name.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeName"><tt>XmlDomGetNodeName</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodePrefix">XmlDomGetNodePrefix</a></h2>

<table summary="Function 'XmlDomGetNodePrefix' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodePrefix</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.prefix</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return namespace prefix of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodePrefix(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodePrefix' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> namespace prefix of node [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the namespace prefix for a node (as a NULL-terminated
        string).  If the node's name is not fully qualified (has no
        prefix), NULL is returned.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;pfx:foo&nbsp;xmlns:pfx="example_namespace"/&gt;<br>
XmlDomGetNodePrefix(element&nbsp;pfx:foo)&nbsp;--&gt;&nbsp;"pfx"</tt></tr>

</table>

<h2 align=center><a name="XmlDomGetNodeType">XmlDomGetNodeType</a></h2>

<table summary="Function 'XmlDomGetNodeType' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeType</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.getNodeType()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node's numeric type code</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnodetype&nbsp;XmlDomGetNodeType(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeType' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnodetype)</b></tt> numeric type-code of the node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the type code of a node.  The type names and numeric values
        match the DOM specification:<p>
        ELEMENT_NODE=1, ATTRIBUTE_NODE=2, TEXT_NODE=3, CDATA_SECTION_NODE=4,
        ENTITY_REFERENCE_NODE=5, ENTITY_NODE=6, PROCESSING_INSTRUCTION_NODE=7,
        COMMENT_NODE=8, DOCUMENT_NODE=9, DOCUMENT_TYPE_NODE=10,
        DOCUMENT_FRAGMENT_NODE=11, NOTATION_NODE=12<p>
        Additional Oracle extension node types are as follows:<p>
        ELEMENT_DECL_NODE, ATTR_DECL_NODE, CP_ELEMENT_NODE, CP_CHOICE_NODE,
        CP_SEQUENCE_NODE, CP_PCDATA_NODE, CP_STAR_NODE, CP_PLUS_NODE,
        CP_OPT_NODE<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetNodeURI">XmlDomGetNodeURI</a></h2>

<table summary="Function 'XmlDomGetNodeURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.namespaceURI</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return namespace URI of node as a NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeURI(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> namespace URI of node [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the namespace URI for a node (in the data encoding) as a
        NULL-terminated string.  If the node's name is not qualified (does
        not contain a namespace prefix), it will have the default namespace
        in effect when the node was created (which may be NULL).<p>
        A length-encoded version is available as XmlDomGetNodeURILen which
        returns the URI as a pointer and length, for use if the data is
        known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;pfx:foo&nbsp;xmlns:pfx="example_namespace"/&gt;<br>
XmlDomGetNodeURI(element&nbsp;pfx:foo)&nbsp;--&gt;&nbsp;"example_namespace\0"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeURILen"><tt>XmlDomGetNodeURILen</tt></a>, <a href="Package-DOM.html#XmlDomGetNodePrefix"><tt>XmlDomGetNodePrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeLocal"><tt>XmlDomGetNodeLocal</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeURILen">XmlDomGetNodeURILen</a></h2>

<table summary="Function 'XmlDomGetNodeURILen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeURILen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return namespace URI of node as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeURILen(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeURILen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of URI [<i>in characters</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> namespace URI of node [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the namespace URI for a node (in the data encoding) as
        length-encoded string.  If the node's name is not qualified (does
        not contain a namespace prefix), it will have the default namespace
        in effect when the node was created (which may be NULL).<p>
        A NULL-terminated version is available as XmlDomGetNodeURI which
        returns the URI value as NULL-terminated string.  If the backing
        store is known to be XMLType, then the node's data will be stored
        internally as length-encoded.  Using the length-based Get functions
        will avoid having to copy and NULL-terminate the data.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;pfx:foo&nbsp;xmlns:pfx="example_namespace"/&gt;<br>
XmlDomGetNodeURILen(element&nbsp;pfx:foo)&nbsp;--&gt;&nbsp;("example_namespace",&nbsp;17)</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeURI"><tt>XmlDomGetNodeURI</tt></a>, <a href="Package-DOM.html#XmlDomGetNodePrefix"><tt>XmlDomGetNodePrefix</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeLocal"><tt>XmlDomGetNodeLocal</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeValue">XmlDomGetNodeValue</a></h2>

<table summary="Function 'XmlDomGetNodeValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.getNodeValue()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node's value as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeValue(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeValue' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> value of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the "value" (associated character data) for a node as a
        NULL-terminated string.  Character and general entities will have
        been replaced.  Only Attr, CDATA, Comment, PI and Text nodes have
        values, all other node types have NULL value.<p>
        A length-encoded version is available as XmlDomGetNodeValueLen which
        returns the node value as a pointer and length, for use if the data
        is known to use XMLType backing store.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>"&lt;foo&gt;data&lt;/foo&gt;"<br>
XmlDomGetNodeValue(node&nbsp;foo)&nbsp;--&gt;&nbsp;NULL<br>
XmlDomGetNodeValue(foo's&nbsp;first&nbsp;child,&nbsp;a&nbsp;TEXT&nbsp;node)&nbsp;--&gt;&nbsp;"data\0"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetNodeValue"><tt>XmlDomSetNodeValue</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeValueLen"><tt>XmlDomGetNodeValueLen</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNodeValueLen">XmlDomGetNodeValueLen</a></h2>

<table summary="Function 'XmlDomGetNodeValueLen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNodeValueLen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node value as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNodeValueLen(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*buf,&nbsp;ub4&nbsp;buflen,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;*len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNodeValueLen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML node</td></tr>
<tr><td scope=row><tt>buf</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  input buffer length [<i>optional</i>]</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> length of value [<i>in bytes</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> value of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the "value" (associated character data) for a node as a
        length-encoded string.  Character and general entities will have
        been replaced.  Only Attr, CDATA, Comment, PI and Text nodes have
        values, all other node types have NULL value.<p>
        A NULL-terminated version is available as XmlDomGetNodeValue which
        returns the node value as NULL-terminated string.  If the backing
        store is known to be XMLType, then the node's data will be stored
        internally as length-encoded.  Using the length-based Get functions
        will avoid having to copy and NULL-terminate the data.<p>
        If both the input buffer is non-NULL and the input buffer length is
        non-zero, then the value will be stored in the input buffer.  Else,
        the implementation will return its own buffer.<p>
        If the actual length is greater than buflen, then a truncated value
        will be copied into the buffer and len will return the actual length.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>"&lt;foo&gt;data&lt;/foo&gt;"<br>
XmlDomGetNodeValue(node&nbsp;foo)&nbsp;--&gt;&nbsp;NULL<br>
XmlDomGetNodeValue(foo's&nbsp;first&nbsp;child)&nbsp;--&gt;&nbsp;</tt><i>"data",&nbsp;4</i><tt></tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetNodeValueLen"><tt>XmlDomSetNodeValueLen</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeValue"><tt>XmlDomGetNodeValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNotationPubID">XmlDomGetNotationPubID</a></h2>

<table summary="Function 'XmlDomGetNotationPubID' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNotationPubID</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Notation">Notation</a>; DOM 2: Notation.publicId</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get notation's public ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNotationPubID(xmlctx&nbsp;*xctx,&nbsp;xmlnotenode&nbsp;*note)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNotationPubID' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>note</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> notation node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> notation's public identifier [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Return a notation's public identifier (in the data encoding).  If
        the node is not a notation, or has no defined public ID, returns
        NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNotationSysID"><tt>XmlDomGetNotationSysID</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetNotationSysID">XmlDomGetNotationSysID</a></h2>

<table summary="Function 'XmlDomGetNotationSysID' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetNotationSysID</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Notation">Notation</a>; DOM 2: Notation.systemId</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get notation's system ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetNotationSysID(xmlctx&nbsp;*xctx,&nbsp;xmlnotenode&nbsp;*note)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetNotationSysID' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>note</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> notation node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> notation's system identifier [<i>data encoding; may be NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Return a notation's system identifier (in the data encoding).  If
        the node is not a notation, or has no defined system ID, returns
        NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNotationPubID"><tt>XmlDomGetNotationPubID</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetOwnerDocument">XmlDomGetOwnerDocument</a></h2>

<table summary="Function 'XmlDomGetOwnerDocument' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetOwnerDocument</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.ownerDocument</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the owner document of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmldocnode*&nbsp;XmlDomGetOwnerDocument(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetOwnerDocument' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmldocnode *)</b></tt> document node is in</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the Document node associated with a node.  Each node may
        belong to only one document, or may not be associated with any
        document at all (e.g. immediately after XmlDomCreateElem, etc).
        The "owning" document [node] is returned, or NULL for an orphan
        node.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetOwnerElem">XmlDomGetOwnerElem</a></h2>

<table summary="Function 'XmlDomGetOwnerElem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetOwnerElem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Attr.ownerElement</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return an attribute's owning element</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlelemnode*&nbsp;XmlDomGetOwnerElem(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetOwnerElem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlelemnode *)</b></tt> attribute's element node [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the Element node associated with an attribute.  Each attr
        either belongs to an element (one and only one), or is detached
        and not yet part of the DOM tree.  In the former case, the element
        node is returned; if the attr is unassigned, NULL is returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetOwnerDocument"><tt>XmlDomGetOwnerDocument</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetPIData">XmlDomGetPIData</a></h2>

<table summary="Function 'XmlDomGetPIData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetPIData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstruction">ProcessingInstruction</a>; DOM 2: ProcessingInstruction.data</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get processing instruction's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetPIData(xmlctx&nbsp;*xctx,&nbsp;xmlpinode&nbsp;*pi)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetPIData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>pi</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> processing instruction node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> processing instruction's data [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the content (data) of a processing instruction (in the data
        encoding).  If the node is not a PI, returns NULL.  The content is
        the part from the first non-whitespace character after the target
        until the ending "?&gt;".<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;?rating&nbsp;extra&nbsp;saucy?&gt;<br>
XmlDomGetPIData&nbsp;--&gt;&nbsp;"extra&nbsp;saucy"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetPITarget"><tt>XmlDomGetPITarget</tt></a>, <a href="Package-DOM.html#XmlDomSetPIData"><tt>XmlDomSetPIData</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetPITarget">XmlDomGetPITarget</a></h2>

<table summary="Function 'XmlDomGetPITarget' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetPITarget</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstruction">ProcessingInstruction</a>; DOM 2: ProcessingInstruction.target</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get PI's target</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetPITarget(xmlctx&nbsp;*xctx,&nbsp;xmlpinode&nbsp;*pi)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetPITarget' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>pi</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> processing instruction node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> processing instruction's target [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a processing instruction's target string.  If the
        node is not a PI, returns NULL.  The target is the first token
        following the markup that begins the PI.  All PIs must have a
        target, though the data part is optional.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;?rating&nbsp;extra&nbsp;saucy?&gt;<br>
XmlDomGetPITarget&nbsp;--&gt;&nbsp;"rating"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetPIData"><tt>XmlDomGetPIData</tt></a>, <a href="Package-DOM.html#XmlDomSetPIData"><tt>XmlDomSetPIData</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetParentNode">XmlDomGetParentNode</a></h2>

<table summary="Function 'XmlDomGetParentNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetParentNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.getParentNode()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get parent node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetParentNode(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetParentNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> parent of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a node's parent node.  All nodes types except Attr, Document,
        DocumentFragment, Entity, and Notation may have a parent (these five
        exceptions always have a NULL parent).  If a node has just been
        created but not yet added to the DOM tree, or if it has been removed
        from the DOM tree, its parent is also NULL.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetPrevSibling">XmlDomGetPrevSibling</a></h2>

<table summary="Function 'XmlDomGetPrevSibling' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetPrevSibling</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.previousSibling</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return previous sibling of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomGetPrevSibling(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetPrevSibling' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node immediately preceding node at same level</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the node preceding a node at the same level in the DOM tree.
        That is, for each child of a parent node, the previous sibling of
        that child is the child which came before it.  If a node is the first
        child of its parent, or has no parent, NULL is returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNextSibling"><tt>XmlDomGetNextSibling</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetSchema">XmlDomGetSchema</a></h2>

<table summary="Function 'XmlDomGetSchema' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetSchema</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns URI of schema associated with document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetSchema(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetSchema' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> Schema URI or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns URI of schema associated with document, if there is one,
        else returns NULL.  The XmlLoadDom functions take a schema location
        hint (URI); the schema is used for efficient layout of XMLType data.
        If a schema was provided at load time, this function returns TRUE.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomIsSchemaBased"><tt>XmlDomIsSchemaBased</tt></a>, <a href="Package-XML.html#XmlLoadDom"><tt>XmlLoadDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomGetSourceEntity">XmlDomGetSourceEntity</a></h2>

<table summary="Function 'XmlDomGetSourceEntity' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetSourceEntity</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return the entity node if the input file is an external entity</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlentnode*&nbsp;XmlDomGetSourceEntity(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetSourceEntity' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlentnode *)</b></tt> entity node if the input is from an external entity</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the extern entity node whose inclusion caused the creation
        of the given node.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetSourceLine">XmlDomGetSourceLine</a></h2>

<table summary="Function 'XmlDomGetSourceLine' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetSourceLine</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: DOMLocator.getLineNumber()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return source line# of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlDomGetSourceLine(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetSourceLine' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> line number of node in original input source</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the line# in the original source where the node
        started.  The first line in every input is line #1.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetSourceLocation">XmlDomGetSourceLocation</a></h2>

<table summary="Function 'XmlDomGetSourceLocation' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetSourceLocation</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return source location (path, URI, etc) of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetSourceLocation(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetSourceLocation' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> full path of input source [<i>in compiler encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Return source location (path, URI, etc) of node.  Note this will
        be in the compiler encoding, not the data encoding!<p>
</tr>
</table>

<h2 align=center><a name="XmlDomGetTag">XmlDomGetTag</a></h2>

<table summary="Function 'XmlDomGetTag' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomGetTag</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.tagName</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return an element node's tagname</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomGetTag(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomGetTag' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> element's name [<i>data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the <tt>tagName</tt> of a node, which is the same as its name.
        DOM 1.0 says "...even though there is a generic <tt>nodeName</tt> attribute
        on the <tt>Node</tt> interface, there is still a <tt>tagName</tt> attribute on the
        <tt>Element</tt> interface; these two attributes must contain the same value,
        but the Working Group considers it worthwhile to support both, given
        the different constituencies the DOM API must satisfy."<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeName"><tt>XmlDomGetNodeName</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomHasAttr">XmlDomHasAttr</a></h2>

<table summary="Function 'XmlDomHasAttr' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomHasAttr</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.hasAttribute()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Does named attribute exist?</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlDomHasAttr(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomHasAttr' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if element has attribute with given name</tr>
<tr><th scope=row><i>Description</i>
<td>        Determines if an element has a attribute with the given name.
        Returns TRUE if so, FALSE if not.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomHasAttrNS"><tt>XmlDomHasAttrNS</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomHasAttrNS">XmlDomHasAttrNS</a></h2>

<table summary="Function 'XmlDomHasAttrNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomHasAttrNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2 Element.hasAttributeNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Does named attribute exist?  (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlDomHasAttrNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomHasAttrNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's local name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if element has attribute with given URI/localname</tr>
<tr><th scope=row><i>Description</i>
<td>        Determines if an element has an attribute with the given URI and
        localname.  Returns TRUE if so, FALSE if not.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomHasAttr"><tt>XmlDomHasAttr</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomHasAttrs">XmlDomHasAttrs</a></h2>

<table summary="Function 'XmlDomHasAttrs' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomHasAttrs</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Test if element has attributes</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlDomHasAttrs(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomHasAttrs' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML element node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if element has attributes</tr>
<tr><th scope=row><i>Description</i>
<td>        Test if an element has attributes.  Returns TRUE if any
        attributes of any sort are defined (namespace or regular).<p>
</tr>
</table>

<h2 align=center><a name="XmlDomHasChildNodes">XmlDomHasChildNodes</a></h2>

<table summary="Function 'XmlDomHasChildNodes' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomHasChildNodes</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.hasChildNodes()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Test if node has children</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlDomHasChildNodes(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomHasChildNodes' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if the node has any children</tr>
<tr><th scope=row><i>Description</i>
<td>        Test if a node has children.  Only Element, Document, DTD, and
        DocumentFragment nodes may have children.  Note that just because
        XmlDomGetChildNodes returns a list does not mean the node actually
        has children, since the list may be empty, so a non-NULL return
        from XmlDomGetChildNodes should not be used as a test.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomImportNode">XmlDomImportNode</a></h2>

<table summary="Function 'XmlDomImportNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomImportNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 2: Document.importNode()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Import a node from another DOM</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomImportNode(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlctx&nbsp;*nctx,&nbsp;xmlnode&nbsp;*node,&nbsp;boolean&nbsp;deep)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomImportNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>nctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context of imported node</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to import</td></tr>
<tr><td scope=row><tt>deep</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> recursively import subtree?</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> newly imported node (in this Document).</tr>
<tr><th scope=row><i>Description</i>
<td>        Imports a node from one Document to another.  The new node is an
        orphan and has no parent; it must be added to the DOM tree with
        XmlDomAppendChild, etc.  The original node is not modified in any
        way or removed from its document; instead, a new node is created
        with copies of all the original node's QName, prefix, namespace URI,
        and local name.<p>
        As with XmlDomCloneNode, the deep controls whether the children of
        the node are recursively imported.  If FALSE, only the node itself
        is imported, and it will have no children.  If TRUE, all descendents
        of the node will be imported as well, and an entire new subtree
        created.<p>
        Document and DocumentType nodes cannot be imported.  Imported
        attributes will have their specified flags set to TRUE.  Elements
        will have only their specified attributes imported; non-specified
        (default) attributes are omitted.  New default attributes (for the
        destination document) are then added.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomCloneNode"><tt>XmlDomCloneNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomInsertBefore">XmlDomInsertBefore</a></h2>

<table summary="Function 'XmlDomInsertBefore' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomInsertBefore</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.insertBefore()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Insert new child into node's list of children</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomInsertBefore(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*parent,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlnode&nbsp;*newChild,&nbsp;xmlnode&nbsp;*refChild)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomInsertBefore' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>parent</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> parent to receive new child</td></tr>
<tr><td scope=row><tt>newChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to insert</td></tr>
<tr><td scope=row><tt>refChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference node to insert before</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node being inserted</tr>
<tr><th scope=row><i>Description</i>
<td>        Inserts the node newChild before the existing child node refChild
        in the parent node.  If refChild is NULL, appends to parent's
        children as per XmlDomAppendChild; otherwise it must be a child of the
        given parent.  If newChild is a DocumentFragment, all of its children
        are inserted (in the same order) before refChild; the DocumentFragment
        node itself is not.  If newChild is already in the DOM tree, it is
        first removed from its current position.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomAppendChild"><tt>XmlDomAppendChild</tt></a>, <a href="Package-DOM.html#XmlDomReplaceChild"><tt>XmlDomReplaceChild</tt></a>, <a href="Package-DOM.html#XmlDomRemoveChild"><tt>XmlDomRemoveChild</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomInsertData">XmlDomInsertData</a></h2>

<table summary="Function 'XmlDomInsertData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomInsertData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: CharacterData.insertData()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Insert string into node's current data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomInsertData(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;ub4&nbsp;offset,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*arg,&nbsp;oratext&nbsp;**old)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomInsertData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  CharacterData node [<i>Text, Comment, or CDATA</i>]</td></tr>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  character offset at which to insert</td></tr>
<tr><td scope=row><tt>arg</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  data to insert [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>old</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> previous data for node [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Insert a string into a CharacterData node's data at the specified
        position.  If the node is not text, comment or CDATAS, or if
        the data to be inserted is NULL, or the offset is outside the
        original data, does nothing.  The inserted data must be in the
        data encoding.  It will not be verified, converted, or checked.
        If bad data is appended, bad things will happen-- GIGO!   The offset
        is specified as characters, not bytes.  The offset is zero-based,
        so inserting at offset zero prepends the data.<p>
        The new node data will be allocated and managed by DOM, but if the
        previous node value was allocated and managed by the user, they
        are responsible for freeing it (which is why it's returned).<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt></tt><i>Given&nbsp;a&nbsp;node&nbsp;with&nbsp;data</i><tt>&nbsp;"abcdefgh"<br>
InsertData(offset=0,&nbsp;arg="FOO")&nbsp;--&gt;&nbsp;"FOOabcdefgh"<br>
InsertData(offset=5,&nbsp;arg="*")&nbsp;--&gt;&nbsp;"abcde*fgh"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a>, <a href="Package-DOM.html#XmlDomAppendData"><tt>XmlDomAppendData</tt></a>, <a href="Package-DOM.html#XmlDomDeleteData"><tt>XmlDomDeleteData</tt></a>, <a href="Package-DOM.html#XmlDomReplaceData"><tt>XmlDomReplaceData</tt></a>, <a href="Package-DOM.html#XmlDomSplitText"><tt>XmlDomSplitText</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomIsSchemaBased">XmlDomIsSchemaBased</a></h2>

<table summary="Function 'XmlDomIsSchemaBased' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomIsSchemaBased</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Indicate whether a schema is associated with a document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlDomIsSchemaBased(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomIsSchemaBased' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if there is a schema associated with the document</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns flag saying whether there is a schema associated with this
        document.   The XmlLoadDom functions take a schema location hint
        (URI); the schema is used for efficient layout of XMLType data.
        If a schema was provided at load time, this function returns TRUE.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetSchema"><tt>XmlDomGetSchema</tt></a>, <a href="Package-XML.html#XmlLoadDom"><tt>XmlLoadDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomNormalize">XmlDomNormalize</a></h2>

<table summary="Function 'XmlDomNormalize' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomNormalize</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Element.normalize()</tr>

<tr><th scope=row><i>Purpose</i>
<td>"Normalize" a node, that is, merge adjacent text nodes</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomNormalize(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomNormalize' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        "Normalizes" the subtree rooted at an element, i.e. merges adjacent
        Text nodes children of elements.  Note that adjacent Text nodes will
        never be created during a normal parse, only after manipulation of
        the document with DOM calls.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>&lt;a&gt;"XXX"&nbsp;"YYY"&lt;b&gt;"111"&nbsp;"222"&lt;/b&gt;&lt;/a&gt;<br>
normalize(node&nbsp;a)&nbsp;--&gt;<br>
&lt;a&gt;"XXXYYY"&lt;b&gt;"111222"&lt;/b&gt;&lt;/a&gt;</tt></tr>

</table>

<h2 align=center><a name="XmlDomNumAttrs">XmlDomNumAttrs</a></h2>

<table summary="Function 'XmlDomNumAttrs' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomNumAttrs</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return number of attributes of element</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlDomNumAttrs(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomNumAttrs' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML element node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> number of attributes of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the number of attributes of an element.  Note that just
        because a list is returned by XmlDomGetAttrs does not mean
        it contains any attributes; it may be an empty list with zero
        length.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomNumChildNodes">XmlDomNumChildNodes</a></h2>

<table summary="Function 'XmlDomNumChildNodes' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomNumChildNodes</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return number of children of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlDomNumChildNodes(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomNumChildNodes' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> number of children of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the number of children of a node.  Only Element, Document,
        DTD, and DocumentFragment nodes may have children, all other types
        return 0.  Note that just because XmlDomGetChildNodes returns a list
        does not mean that it contains any children; it may be an empty list
        with zero length.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomPrefixToURI">XmlDomPrefixToURI</a></h2>

<table summary="Function 'XmlDomPrefixToURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomPrefixToURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 3: Node.lookupNamespacePrefix()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Get namespace URI for prefix</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomPrefixToURI(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*prefix)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomPrefixToURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
<tr><td scope=row><tt>prefix</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> prefix to map</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> URI for prefix [<i>data encoding; NULL if no match</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Given a namespace prefix and a node, returns the namespace URI
        mapped to that prefix.  If the given node doesn't have a matching
        prefix, its parent is tried, then its parent, and so on, all the
        way to the root node.  If the prefix is undefined, NULL is returned.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomRemoveAttr">XmlDomRemoveAttr</a></h2>

<table summary="Function 'XmlDomRemoveAttr' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomRemoveAttr</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.removeAttribute()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove attribute with specified name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomRemoveAttr(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomRemoveAttr' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Removes an attribute (specified by name).  If the removed attribute
        has a default value it is immediately re-created with that default.
        Note that the attribute is removed from the element's list of
        attributes, but the attribute node itself is not destroyed.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomRemoveAttrNS"><tt>XmlDomRemoveAttrNS</tt></a>, <a href="Package-DOM.html#XmlDomRemoveAttrNode"><tt>XmlDomRemoveAttrNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomRemoveAttrNS">XmlDomRemoveAttrNS</a></h2>

<table summary="Function 'XmlDomRemoveAttrNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomRemoveAttrNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.removeAttributeNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove attribute with specified URI and local name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomRemoveAttrNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomRemoveAttrNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's local name</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Removes an attribute (specified by URI and localname).  If the
        removed attribute has a default value it is immediately re-created
        with that default.  Note that the attribute is removed from the
        element's list of attributes, but the attribute node itself is not
        destroyed.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomRemoveAttr"><tt>XmlDomRemoveAttr</tt></a>, <a href="Package-DOM.html#XmlDomRemoveAttrNode"><tt>XmlDomRemoveAttrNode</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomRemoveAttrNode">XmlDomRemoveAttrNode</a></h2>

<table summary="Function 'XmlDomRemoveAttrNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomRemoveAttrNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.removeAttributeNode()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove attribute node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlattrnode*&nbsp;XmlDomRemoveAttrNode(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;xmlattrnode&nbsp;*oldAttr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomRemoveAttrNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>newAttr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node to add</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlattrnode *)</b></tt> replaced attribute node [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Removes an attribute from an element.  If the attribute has a
        default value, it is immediately re-created with that value
        (Specified set to FALSE).  Returns the removed attribute on
        success, else NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomRemoveAttr"><tt>XmlDomRemoveAttr</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomRemoveChild">XmlDomRemoveChild</a></h2>

<table summary="Function 'XmlDomRemoveChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomRemoveChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.removeChild()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove an existing child node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomRemoveChild(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*oldChild)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomRemoveChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>oldChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to remove</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node removed</tr>
<tr><th scope=row><i>Description</i>
<td>        Removes a node from its parent's list of children and returns it.
        The node is orphaned; its parent will be NULL after removal.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomAppendChild"><tt>XmlDomAppendChild</tt></a>, <a href="Package-DOM.html#XmlDomInsertBefore"><tt>XmlDomInsertBefore</tt></a>, <a href="Package-DOM.html#XmlDomReplaceChild"><tt>XmlDomReplaceChild</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomRemoveNamedItem">XmlDomRemoveNamedItem</a></h2>

<table summary="Function 'XmlDomRemoveNamedItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomRemoveNamedItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a>; DOM 2: NamedNodeMap.removeNamedItem()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove node from named node map</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomRemoveNamedItem(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map,&nbsp;oratext&nbsp;*name)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomRemoveNamedItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name of node to remove [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node removed from this map</tr>
<tr><th scope=row><i>Description</i>
<td>        Removes a node from a NamedNodeMap, specified by name.  This is a
        non-namespace-aware function; it just matches (case sensitively)
        on the whole QName.  If the removed node is an attribute with default
        value (not specified), it is immediately replaced.  The removed node
        is returned; if no removal took place, NULL is returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomRemoveNamedItemNS"><tt>XmlDomRemoveNamedItemNS</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItem"><tt>XmlDomGetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItemNS"><tt>XmlDomGetNamedItemNS</tt></a>, <a href="Package-DOM.html#XmlDomSetNamedItem"><tt>XmlDomSetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomSetNamedItemNS"><tt>XmlDomSetNamedItemNS</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomRemoveNamedItemNS">XmlDomRemoveNamedItemNS</a></h2>

<table summary="Function 'XmlDomRemoveNamedItemNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomRemoveNamedItemNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a>; DOM 2: NamedNodeMap.removeNamedItemNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove node from named node map (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomRemoveNamedItemNS(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*uri,&nbsp;oratext&nbsp;*local)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomRemoveNamedItemNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> namespace URI of node to remove [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>local</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> local name of node to remove [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node removed from this map</tr>
<tr><th scope=row><i>Description</i>
<td>        Removes a node from a NamedNodeMap, specified by URI and localname.
        If the removed node is an attribute with default value (not specified),
        it is immediately replaced.  The removed node is returned; if no
        removal took place, NULL is returned.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomRemoveNamedItem"><tt>XmlDomRemoveNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItem"><tt>XmlDomGetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItemNS"><tt>XmlDomGetNamedItemNS</tt></a>, <a href="Package-DOM.html#XmlDomSetNamedItem"><tt>XmlDomSetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomSetNamedItemNS"><tt>XmlDomSetNamedItemNS</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomReplaceChild">XmlDomReplaceChild</a></h2>

<table summary="Function 'XmlDomReplaceChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomReplaceChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.replaceChild()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Replace an existing child of a node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomReplaceChild(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*newChild,&nbsp;xmlnode&nbsp;*oldChild)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomReplaceChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>newChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  new node being substituted</td></tr>
<tr><td scope=row><tt>oldChild</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> old node being replaced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> node replaced</tr>
<tr><th scope=row><i>Description</i>
<td>        Replaces the child node oldChild with the new node newChild in
        oldChild's parent, and returns oldChild (which is now orphaned,
        with a NULL parent).  If newChild is a DocumentFragment, all of
        its children are inserted in place of oldChild; the DocumentFragment
        node itself is not.  If newChild is already in the DOM tree, it is
        first removed from its current position.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomAppendChild"><tt>XmlDomAppendChild</tt></a>, <a href="Package-DOM.html#XmlDomInsertBefore"><tt>XmlDomInsertBefore</tt></a>, <a href="Package-DOM.html#XmlDomRemoveChild"><tt>XmlDomRemoveChild</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomReplaceData">XmlDomReplaceData</a></h2>

<table summary="Function 'XmlDomReplaceData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomReplaceData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: CharacterData.replaceData()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Replace part of node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomReplaceData(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;ub4&nbsp;offset,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;count,&nbsp;oratext&nbsp;*arg,&nbsp;oratext&nbsp;**old)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomReplaceData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  CharacterData node [<i>text, comment, or CDATA</i>]</td></tr>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  character offset from which to start replacing</td></tr>
<tr><td scope=row><tt>count</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  number of characters to replace</td></tr>
<tr><td scope=row><tt>arg</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  replacement substring [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>out</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> previous data for node [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Replaces a range of characters in a CharacterData node's data with
        a new string.  If the node is not text, comment or CDATA, or
        if the offset is outside of the original data, or if the replacement
        string is NULL, does nothing.  If the count is zero, acts just as
        XmlDomInsertData.  The offset is zero-based, so offset zero refers
        to the start of the data.  The replacement data must be in the data
        encoding.  It will not be verified, converted, or checked.  If bad
        data is set, bad things will happen-- GIGO!   The offset and count
        are both in characters, not bytes.  If the sum of offset and count
        exceeds length, then all characters to the end of the data are
        replaced.<p>
        The new node data will be allocated and managed by DOM, but if the
        previous node value was allocated and managed by the user, they
        are responsible for freeing it (which is why it's returned).<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>Given&nbsp;a&nbsp;node&nbsp;with&nbsp;data&nbsp;"abcdefgh",<br>
XmlDomReplaceData(offset=0,&nbsp;count=1,&nbsp;arg="FOO")&nbsp;--&gt;&nbsp;"FOObcdefgh"<br>
XmlDomRreplaceData(offset=2,&nbsp;count=2,&nbsp;arg="*")&nbsp;--&gt;&nbsp;"ab*efgh"<br>
XmlDomRreplaceData(offset=5,&nbsp;count=5,&nbsp;arg="*")&nbsp;--&gt;&nbsp;"abcde*"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a>, <a href="Package-DOM.html#XmlDomAppendData"><tt>XmlDomAppendData</tt></a>, <a href="Package-DOM.html#XmlDomInsertData"><tt>XmlDomInsertData</tt></a>, <a href="Package-DOM.html#XmlDomDeleteData"><tt>XmlDomDeleteData</tt></a>, <a href="Package-DOM.html#XmlDomSplitText"><tt>XmlDomSplitText</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSaveString">XmlDomSaveString</a></h2>

<table summary="Function 'XmlDomSaveString' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSaveString</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Saves a string permanently in a document's memory pool </tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomSaveString(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*str)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSaveString' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document</td></tr>
<tr><td scope=row><tt>str</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> string to save [<i>data encoding; single- or multi-byte only</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> saved copy of string</tr>
<tr><th scope=row><i>Description</i>
<td>        Copies the given string into the document's memory pool, so that
        it persists for the life of the document.  The individual string
        WILL NOT BE FREEABLE, and the storage will be returned only when
        the entire document is freed.  Works on single-byte or multi-byte
        encodings; for Unicode strings, use XmlDomSaveString2<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSaveString2"><tt>XmlDomSaveString2</tt></a>, <a href="Package-XML.html#XmlFreeDocument"><tt>XmlFreeDocument</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSaveString2">XmlDomSaveString2</a></h2>

<table summary="Function 'XmlDomSaveString2' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSaveString2</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Saves a Unicode string permanently in a document's memory pool </tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub2*&nbsp;XmlDomSaveString2(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;ub2&nbsp;*ustr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSaveString2' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document</td></tr>
<tr><td scope=row><tt>ustr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> string to save [<i>data encoding; Unicode only</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub2 *)</b></tt> saved copy of string</tr>
<tr><th scope=row><i>Description</i>
<td>        Copies the given string into the document's memory pool, so that
        it persists for the life of the document.  The individual string
        will not be freeable, and the storage will be returned only when
        the entire document is free.  Works on Unicode strings only; for
        single-byte or multi-byte strings, use XmlDomSaveString<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSaveString"><tt>XmlDomSaveString</tt></a>, <a href="Package-XML.html#XmlFreeDocument"><tt>XmlFreeDocument</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetAttr">XmlDomSetAttr</a></h2>

<table summary="Function 'XmlDomSetAttr' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetAttr</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.setAttribute()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set new attribute for element</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomSetAttr(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*name,&nbsp;oratext&nbsp;*value)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetAttr' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's value [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a new attribute for an element with the given name and value
        (which should be in the data encoding).  If the named attribute already
        exists, its value is simply replaced.  The name and value are not
        verified, converted, or checked.  If bad data is set, bad things may
        happen-- GIGO!  The value is not parsed, so entity references will not
        be expanded.  The attribute's Specified flag will be set.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetAttrNS"><tt>XmlDomSetAttrNS</tt></a>, <a href="Package-DOM.html#XmlDomCreateAttr"><tt>XmlDomCreateAttr</tt></a>, <a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a>, <a href="Package-DOM.html#XmlDomRemoveAttr"><tt>XmlDomRemoveAttr</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetAttrNS">XmlDomSetAttrNS</a></h2>

<table summary="Function 'XmlDomSetAttrNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetAttrNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.setAttributeNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set new attribute for element (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomSetAttrNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;oratext&nbsp;*uri,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*qname,&nbsp;oratext&nbsp;*value)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetAttrNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>qname</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's qualified name [<i>data encoding</i>]</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's value [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a new attribute for an element with the given URI, localname
        and value (which should be in the data encoding).  If the named
        attribute already exists, its value is simply replaced.  The name
        and value are not verified, converted, or checked.  If bad data is
        set, bad things will happen-- GIGO!<p>
        The value is not parsed, so entity references will not be expanded.<p>
        The attribute's <tt>specified</tt> flag will be set.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetAttr"><tt>XmlDomSetAttr</tt></a>, <a href="Package-DOM.html#XmlDomCreateAttr"><tt>XmlDomCreateAttr</tt></a>, <a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a>, <a href="Package-DOM.html#XmlDomRemoveAttr"><tt>XmlDomRemoveAttr</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetAttrNode">XmlDomSetAttrNode</a></h2>

<table summary="Function 'XmlDomSetAttrNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetAttrNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.setAttributeNode()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set attribute node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlattrnode*&nbsp;XmlDomSetAttrNode(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;xmlattrnode&nbsp;*newAttr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetAttrNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>newAttr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node to add</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlattrnode *)</b></tt> replaced attribute node (or NULL)</tr>
<tr><th scope=row><i>Description</i>
<td>        Adds a new attribute to an element.  If an attribute with the given
        name already exists, it is replaced and the old attribute returned
        through <tt>oldNode</tt>.  If the attribute is new, it is added to the
        element's list and <tt>oldNode</tt> set to NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetAttrNodeNS"><tt>XmlDomSetAttrNodeNS</tt></a>, <a href="Package-DOM.html#XmlDomCreateAttr"><tt>XmlDomCreateAttr</tt></a>, <a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetAttrNodeNS">XmlDomSetAttrNodeNS</a></h2>

<table summary="Function 'XmlDomSetAttrNodeNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetAttrNodeNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Element">Element</a>; DOM 2: Element.setAttributeNodeNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set attribute node (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlattrnode*&nbsp;XmlDomSetAttrNodeNS(xmlctx&nbsp;*xctx,&nbsp;xmlelemnode&nbsp;*elem,&nbsp;xmlattrnode&nbsp;*newAttr)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetAttrNodeNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>elem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node</td></tr>
<tr><td scope=row><tt>newAttr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node to add</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlattrnode *)</b></tt> replaced attribute node [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Adds a new attribute to an element.  If an attribute with <tt>newNode</tt>'s
        URI and localname already exists, it is replaced and the old attribute
        returned through <tt>oldNode</tt>.  If the attribute is new, it is added to
        the element's list and <tt>oldNode</tt> set to NULL.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetAttrNode"><tt>XmlDomSetAttrNode</tt></a>, <a href="Package-DOM.html#XmlDomCreateAttr"><tt>XmlDomCreateAttr</tt></a>, <a href="Package-DOM.html#XmlDomSetAttrValue"><tt>XmlDomSetAttrValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetAttrValue">XmlDomSetAttrValue</a></h2>

<table summary="Function 'XmlDomSetAttrValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetAttrValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Attr">Attr</a>; DOM 2: Attr.value</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set an attribute's value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomSetAttrValue(xmlctx&nbsp;*xctx,&nbsp;xmlattrnode&nbsp;*attr,&nbsp;oratext&nbsp;*value)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetAttrValue' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>attr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new value of attribute [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the given attribute's value to data.  If the node is not an
        attribute, does nothing.  Note that the new value must be in the
        data encoding!  It is not verified, converted, or checked.  If bad
        data is set for the attribute, bad things will happen-- GIGO!  The
        attribute's specified flag will be TRUE after setting a new value.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetAttrValue"><tt>XmlDomGetAttrValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetBaseURI">XmlDomSetBaseURI</a></h2>

<table summary="Function 'XmlDomSetBaseURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetBaseURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a>; DOM 3: Document.setBaseURI()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Sets base URI for document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomSetBaseURI(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;oratext&nbsp;*uri)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetBaseURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> base URI to set [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> XML error code</tr>
<tr><th scope=row><i>Description</i>
<td>        Only documents that were loaded from a URI will automatically
        have a base URI; documents loaded from other sources (stdin,
        buffer, etc) will not naturally have a base URI, so this API
        is used to set a base URI, for the purposes of relative URI
        resolution in includes.  The base URI should be in the data
        encoding, and a copy will be made.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>A&nbsp;document&nbsp;is&nbsp;loaded&nbsp;with&nbsp;XmlLoadDomStdio&nbsp;from&nbsp;stdin;&nbsp;that<br>
document&nbsp;as&nbsp;a&nbsp;DOCTYPE&nbsp;declaration,&nbsp;which&nbsp;is&nbsp;always&nbsp;a&nbsp;URI.<br>
The&nbsp;DTD's&nbsp;URI&nbsp;is&nbsp;relative,&nbsp;i.e.&nbsp;"subdir/junk.dtd".&nbsp;&nbsp;Where<br>
is&nbsp;the&nbsp;DTD&nbsp;to&nbsp;be&nbsp;found?&nbsp;&nbsp;Its&nbsp;URI&nbsp;is&nbsp;resolved&nbsp;against&nbsp;the<br>
parent's&nbsp;URI,&nbsp;but&nbsp;the&nbsp;parent&nbsp;doesn't&nbsp;have&nbsp;a&nbsp;URI&nbsp;in&nbsp;this<br>
case,&nbsp;so&nbsp;no&nbsp;resolution&nbsp;takes&nbsp;place,&nbsp;and&nbsp;"subdir/junk.dtd"<br>
is&nbsp;tried&nbsp;directly,&nbsp;which&nbsp;may&nbsp;or&nbsp;may&nbsp;not&nbsp;work&nbsp;depending&nbsp;on<br>
the&nbsp;working&nbsp;directory.&nbsp;&nbsp;To&nbsp;make&nbsp;this&nbsp;work&nbsp;always,&nbsp;set&nbsp;the<br>
base&nbsp;URI&nbsp;of&nbsp;the&nbsp;top-level&nbsp;document&nbsp;to&nbsp;an&nbsp;absolute&nbsp;path,<br>
for&nbsp;example&nbsp;to&nbsp;"/root/dir1/dir2/topdoc.html";&nbsp;then&nbsp;the&nbsp;URI<br>
resolution&nbsp;of&nbsp;the&nbsp;included&nbsp;DTD&nbsp;would&nbsp;produce<br>
"/root/dir1/dir2/subdir/junk.dtd"&nbsp;every&nbsp;time.</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetBaseURI"><tt>XmlDomGetBaseURI</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetCharData">XmlDomSetCharData</a></h2>

<table summary="Function 'XmlDomSetCharData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetCharData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: CharacterData.data</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set data for node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomSetCharData(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*data)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetCharData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> CharacterData node [<i>text, comment, or CDATA</i>]</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new data for node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets data for a CharacterData node (type text, comment or CDATA),
        replacing the old data.  For other node types, does nothing.  The
        new data is not verified, converted, or checked-- it should be in
        the data encoding.  If bad data is set, bad things will happen-- GIGO!<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetDTD">XmlDomSetDTD</a></h2>

<table summary="Function 'XmlDomSetDTD' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetDTD</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Sets DTD (Document Type Definition) for document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomSetDTD(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;xmldtdnode&nbsp;*dtdnode)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetDTD' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>dtdnode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> Document Type to set [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, 0 on success</tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the DTD for document.  Note this call may only be used
        for a blank document, BEFORE any parsing has taken place.  A
        single DTD can be set for multiple documents, so when a document
        with a set DTD is freed, the set DTD is NOT also freed.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDTD"><tt>XmlDomGetDTD</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDName"><tt>XmlDomGetDTDName</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDEntities"><tt>XmlDomGetDTDEntities</tt></a>, <a href="Package-DOM.html#XmlDomGetDTDNotations"><tt>XmlDomGetDTDNotations</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetDefaultNS">XmlDomSetDefaultNS</a></h2>

<table summary="Function 'XmlDomSetDefaultNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetDefaultNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set default namespace for node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomSetDefaultNS(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*defns)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetDefaultNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element/attribute DOM node</td></tr>
<tr><td scope=row><tt>defns</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new default namespace for node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Set the default namespace for a node<p>
</tr>
</table>

<h2 align=center><a name="XmlDomSetDocOrder">XmlDomSetDocOrder</a></h2>

<table summary="Function 'XmlDomSetDocOrder' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetDocOrder</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set document order for all nodes</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlDomSetDocOrder(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc,&nbsp;ub4&nbsp;start_id)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetDocOrder' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
<tr><td scope=row><tt>start_id</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> starting ID#</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> highest ordinal assigned</tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the document order for each node in the current document.  Must
        be called once on the final document before XSLT processing can occur.
        Note this is called automatically by the XSLT processor, so ordinarily
        the user need not make this call.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetDocOrder"><tt>XmlDomGetDocOrder</tt></a>, <a href="Package-DOM.html#XmlDomCompareDocOrder"><tt>XmlDomCompareDocOrder</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetNamedItem">XmlDomSetNamedItem</a></h2>

<table summary="Function 'XmlDomSetNamedItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetNamedItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a>; DOM 2: NamedNodeMap.setNamedItem()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set node in named node list</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomSetNamedItem(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map,&nbsp;xmlnode&nbsp;*newNode)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetNamedItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
<tr><td scope=row><tt>newNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node to store in map</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> the replaced node (or NULL)</tr>
<tr><th scope=row><i>Description</i>
<td>        Adds a new node to a NamedNodeMap.  If a node already exists with
        the given name, replaces the old node and returns it.  If no such
        named node exists, adds the new node to the map and sets old to
        NULL.  This is a non-namespace-aware function; it just matches
        (case sensitively) on the whole QName.  Since some node types have
        fixed names (Text, Comment, etc), trying to set another of the same
        type will always cause replacement.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetNamedItemNS"><tt>XmlDomSetNamedItemNS</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItem"><tt>XmlDomGetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItemNS"><tt>XmlDomGetNamedItemNS</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapItem"><tt>XmlDomGetNodeMapItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapLength"><tt>XmlDomGetNodeMapLength</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetNamedItemNS">XmlDomSetNamedItemNS</a></h2>

<table summary="Function 'XmlDomSetNamedItemNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetNamedItemNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMap">NamedNodeMap</a>; DOM 2: NamedNodeMap.setNamedItemNS()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set node in named node list (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode*&nbsp;XmlDomSetNamedItemNS(xmlctx&nbsp;*xctx,&nbsp;xmlnamedmap&nbsp;*map,&nbsp;xmlnode&nbsp;*newNode)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetNamedItemNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>map</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NamedNodeMap</td></tr>
<tr><td scope=row><tt>newNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node to store in map</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> replaced Node [<i>or NULL</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Adds a new node to a NamedNodeMap.  If a node already exists with
        the given URI and localname, replaces the old node and returns it.
        If no such named node exists, adds the new node to the map and sets
        old to NULL.  Since some node types have fixed names (Text, Comment,
        etc), trying to set another of the same type will always cause
        replacement.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetNamedItem"><tt>XmlDomSetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItem"><tt>XmlDomGetNamedItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNamedItemNS"><tt>XmlDomGetNamedItemNS</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapItem"><tt>XmlDomGetNodeMapItem</tt></a>, <a href="Package-DOM.html#XmlDomGetNodeMapLength"><tt>XmlDomGetNodeMapLength</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetNodePrefix">XmlDomSetNodePrefix</a></h2>

<table summary="Function 'XmlDomSetNodePrefix' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetNodePrefix</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set namespace prefix of node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomSetNodePrefix(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*prefix)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetNodePrefix' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
<tr><td scope=row><tt>prefix</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new namespace prefix</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the namespace prefix of node (as NULL-terminated string).
        Does not verify the prefix is defined!  Just causes a new QName
        to be formed from the new prefix and the old local name; the new
        QName will be under DOM control and should not be managed by the
        user.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomSetNodeValue">XmlDomSetNodeValue</a></h2>

<table summary="Function 'XmlDomSetNodeValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetNodeValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a>; DOM 2: Node.setNodeValue()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Set node value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomSetNodeValue(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*value)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetNodeValue' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node's new value [<i>data encoding; user control</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, 0 on success</tr>
<tr><th scope=row><i>Description</i>
<td>        Sets a node's value (character data) as a NULL-terminated string.
        Does not allow setting the value to NULL.  Only Attr, CDATA, Comment,
        PI and Text nodes have values; trying to set the value of another
        type of node is a no-op.  The new value must be in the data encoding!
        It is not verified, converted, or checked.  If bad data is set for
        a node, bad things will happen-- GIGO!<p>
        The value is NOT copied, its pointer is just stored.  The user is
        responsible for persistence and freeing of that data.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetNodeValue"><tt>XmlDomGetNodeValue</tt></a>, <a href="Package-DOM.html#XmlDomSetNodeValueLen"><tt>XmlDomSetNodeValueLen</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetNodeValueLen">XmlDomSetNodeValueLen</a></h2>

<table summary="Function 'XmlDomSetNodeValueLen' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetNodeValueLen</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set node value as length-encoded string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomSetNodeValueLen(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;oratext&nbsp;*value,&nbsp;ub4&nbsp;len)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetNodeValueLen' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML node</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new value for node</td></tr>
<tr><td scope=row><tt>len</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> length of value [<i>in bytes</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, 0 on success</tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the "value" (associated character data) for a node as a
        length-encoded string.<p>
        A NULL-terminated version is available as XmlDomSetNodeValue which
        takes the node value as a NULL-terminated string.  If the backing
        store is known to be XMLType, then the node's data will be stored
        internally as length-encoded.  Using the length-based Set functions
        will avoid having to copy and NULL-terminate the data.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>"&lt;foo&gt;data&lt;/foo&gt;"<br>
XmlDomSetNodeValue(foo's&nbsp;text&nbsp;node,&nbsp;"z",&nbsp;1)<br>
"&lt;foo&gt;z&lt;/foo&gt;"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomSetNodeValueLen"><tt>XmlDomSetNodeValueLen</tt></a>, <a href="Package-DOM.html#XmlDomSetNodeValue"><tt>XmlDomSetNodeValue</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSetPIData">XmlDomSetPIData</a></h2>

<table summary="Function 'XmlDomSetPIData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSetPIData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstruction">ProcessingInstruction</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set processing instruction's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlDomSetPIData(xmlctx&nbsp;*xctx,&nbsp;xmlpinode&nbsp;*pi,&nbsp;oratext&nbsp;*data)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSetPIData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>pi</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> processing instruction node</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> processing instruction's new data [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Set's a Processing Instruction's (PI) data (content), which must be
        in the data encoding.  It is not permitted to set the data to NULL.
        If the node is not a PI, does nothing.  The new data is not verified,
        converted, or checked.  If bad data is set, bad things will happen--
        GIGO!<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetPITarget"><tt>XmlDomGetPITarget</tt></a>, <a href="Package-DOM.html#XmlDomGetPIData"><tt>XmlDomGetPIData</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSplitText">XmlDomSplitText</a></h2>

<table summary="Function 'XmlDomSplitText' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSplitText</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Text">Text</a>; DOM 2: Text.splitText()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Split text node into two</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmltextnode*&nbsp;XmlDomSplitText(xmlctx&nbsp;*xctx,&nbsp;xmltextnode&nbsp;*textnode,&nbsp;ub4&nbsp;offset)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSplitText' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>textnode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> text node</td></tr>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> character offset at which to split, starting from 0.</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmltextnode *)</b></tt> new text node</tr>
<tr><th scope=row><i>Description</i>
<td>        Splits a single text node into two text nodes; the original data
        is split between them.  If the given node is not type text, or the
        offset is outside of the original data, does nothing and returns
        NULL.  The offset is zero-based, and is in characters, not bytes.
        The original node is retained, its data is just truncated.  A new
        text node is created which contains the remainder of the original
        data, and is inserted as the next sibling of the original.  The
        new text node is returned.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>(Given&nbsp;a&nbsp;Text&nbsp;node&nbsp;with&nbsp;data)&nbsp;"abcdefgh",<br>
XmlDomSplitText(1)&nbsp;--&gt;&nbsp;Text("a"),&nbsp;Text("bcdefgh")<br>
XmlDomSplitText(5)&nbsp;--&gt;&nbsp;Text("abcde"),&nbsp;Text("fgh")</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomGetCharData"><tt>XmlDomGetCharData</tt></a>, <a href="Package-DOM.html#XmlDomAppendData"><tt>XmlDomAppendData</tt></a>, <a href="Package-DOM.html#XmlDomInsertData"><tt>XmlDomInsertData</tt></a>, <a href="Package-DOM.html#XmlDomDeleteData"><tt>XmlDomDeleteData</tt></a>, <a href="Package-DOM.html#XmlDomReplaceData"><tt>XmlDomReplaceData</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSubstringData">XmlDomSubstringData</a></h2>

<table summary="Function 'XmlDomSubstringData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSubstringData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterData">CharacterData</a>; DOM 2: CharacterData.substringData()</tr>

<tr><th scope=row><i>Purpose</i>
<td>Return substring of node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext*&nbsp;XmlDomSubstringData(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node,&nbsp;ub4&nbsp;offset,&nbsp;ub4&nbsp;count)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSubstringData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> CharacterData node [<i>text, comment, or CDATA</i>]</td></tr>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> start offset of substring to extract</td></tr>
<tr><td scope=row><tt>count</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> number of characters to extract</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> specified substring.</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a range of character data from a CharacterData node (type
        text, comment or CDATA).  For other node types, or if count is zero,
        returns NULL.  Since the data is in the data encoding, offset and
        count are in characters, not bytes.  The beginning of the string is
        offset 0.  If the sum of offset and count exceeds the length, then
        all characters to the end of the data are returned.<p>
        The substring is permanently allocated in the node's document's
        memory pool.  To free the substring, use XmlDomFreeString.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>Given&nbsp;a&nbsp;node&nbsp;with&nbsp;data&nbsp;"abcdefgh",<br>
XmlDomSubstringData(offset=0,&nbsp;length=1)&nbsp;--&gt;&nbsp;"a"<br>
XmlDomSubstringData(offset=5,&nbsp;length=5)&nbsp;--&gt;&nbsp;"fgh"</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-DOM.html#XmlDomAppendData"><tt>XmlDomAppendData</tt></a>, <a href="Package-DOM.html#XmlDomInsertData"><tt>XmlDomInsertData</tt></a>, <a href="Package-DOM.html#XmlDomDeleteData"><tt>XmlDomDeleteData</tt></a>, <a href="Package-DOM.html#XmlDomReplaceData"><tt>XmlDomReplaceData</tt></a>, <a href="Package-DOM.html#XmlDomSplitText"><tt>XmlDomSplitText</tt></a>, <a href="Package-DOM.html#XmlDomFreeString"><tt>XmlDomFreeString</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlDomSync">XmlDomSync</a></h2>

<table summary="Function 'XmlDomSync' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomSync</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Document">Document</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Synchronizes the persistent version of a document with its DOM.</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomSync(xmlctx&nbsp;*xctx,&nbsp;xmldocnode&nbsp;*doc)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomSync' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML document [<i>node</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, 0 on success</tr>
<tr><th scope=row><i>Description</i>
<td>        Causes a modified DOM to be written back out to its original
        source, synchronizing the persistent store and in-memory versions.<p>
</tr>
</table>

<h2 align=center><a name="XmlDomValidate">XmlDomValidate</a></h2>

<table summary="Function 'XmlDomValidate' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlDomValidate</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Node">Node</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Validate a node against current DTD</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlDomValidate(xmlctx&nbsp;*xctx,&nbsp;xmlnode&nbsp;*node)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlDomValidate' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>node</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to validate</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code, XMLERR_OK [<i>0</i>] means node is valid</tr>
<tr><th scope=row><i>Description</i>
<td>        Given a root node, validates it against the current DTD.<p>
</tr>
</table>
</body>
</html>
