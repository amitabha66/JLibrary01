<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- WARNING!  THIS IS A GENERATED FILE!!  DO NOT EDIT!!! -->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>XSLTVM APIs</title>
</head>
<body bgcolor=white>
<a name="_top_"></a>
<center><table width="90%"><tr><td align=left>
<b>Packages: <a href="packages.html">All</a></b>
 | <b><a href="Package-Callback.html">Callback</a></b>
 | <b><a href="Package-DOM.html">DOM</a></b>
 | <b><a href="Package-Range.html">Range</a></b>
 | <b><a href="Package-SAX.html">SAX</a></b>
 | <b><a href="Package-Schema.html">Schema</a></b>
 | <b><a href="Package-Traversal.html">Traversal</a></b>
 | <b><a href="Package-XML.html">XML</a></b>
 | <b><a href="Package-XPath.html">XPath</a></b>
 | <b><a href="Package-XPointer.html">XPointer</a></b>
 | <b><a href="Package-XSLT.html">XSLT</a></b>
 | <b><a href="Package-XSLTVM.html">XSLTVM</a></b>
</td><td align=right><b><a href="Functions.html">Functions</a></b>
 | <b><a href="Datatypes.html">Datatypes</a></b></td></tr></table>
</center><hr noshade size=1>
<center><h1>Package XSLTVM</h1></center>

   XSLTVM Package implements the XSL Transformation (XSLT) language as  
   specified in W3C Recommendation 16 November 1999.  XSLT Virtual Machine is
   the software implementation of a "CPU" designed to run compiled XSLT code. 
   A concept of virtual machine assumes a compiler compiling XSLT stylesheets
   to a sequence of byte codes or machine instructions for the "XSLT CPU". 
   The byte-code program is a platform-independent sequence of 2-byte units.
   It can be stored, cashed and run on different XSLTVM.  The XSLTVM uses 
   the bytecode programs to transform instance XML documents.  This approach
   clearly separates compile(design)-time from run-time computations and 
   specifies a uniform way of exchanging data between instructions. 
     
   A typical scenario of using the package APIs has the following steps:<p>       (1) Create/Use an XML meta context object.
       xctx = XmlCreate(&err,...);<p>       (2) Create/Use an XSLT Compiler object.
       comp = XmlXvmCreateComp(xctx);<p>       (3) Compile an XSLT stylesheets and store/cash the result bytecode.
       code = XmlXvmCompileFile(comp, xslFile, baseuri, flags, &err);<p>       (4) Create/Use an XSLTVM object. The explicit stack size seting are
           needed when XSLTVM terminates with "... Stack Overflow" message
           or when smaller memory footprints are required (see XmlXvmCreate).
       vm = XmlXvmCreate(xctx, "StringStack", 32, "NodeStack", 24, NULL);<p>       (5) Set a stylesheet bytecode to the XSLTVM object.
       len = XmlXvmGetBytecodeLength(code, &err);
       err = XmlXvmSetBytecodeBuffer(vm, code, len);<p>       (6) Transform an instance XML document.
       err = XmlXvmTransformFile(vm, xmlFile, baseuri);<p>       (7) Clean.
        XmlXvmDestroy(vm);
        XmlXvmDestroyComp(comp);
        XmlDestroy(xctx);<p>
<ul>
    <li><a href="#functions"><b>Function Index</b></a>
    <li><a href="#XSLTC">Interface <b>XSLTC</b></a>
    <li><a href="#XSLTVM">Interface <b>XSLTVM</b></a>
</ul>

<hr noshade size=1><center><h2><a name="functions">Function Index</a></h2></center>
<center><table summary="Package 'XSLTVM' function index" cellspacing=0 cellpadding=0>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Interface<th scope=col>Description</tr>
  <tr>
    <td width=200><a href="#XMLXVM_DEBUG_F"><b>XMLXVM_DEBUG_F</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>XML XSLT VM debug function</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmCompileBuffer"><b>XmlXvmCompileBuffer</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Compile an XSLT stylesheet from buffer into bytecode</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmCompileDom"><b>XmlXvmCompileDom</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Compile an XSLT stylesheet from DOM into bytecode</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmCompileFile"><b>XmlXvmCompileFile</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Compile XSLT stylesheet from file into bytecode</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmCompileURI"><b>XmlXvmCompileURI</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Compile XSLT stylesheet from URI into bytecode</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmCompileXPath"><b>XmlXvmCompileXPath</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Compiles an XPath expression</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmCreate"><b>XmlXvmCreate</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Create an XSLT virtual machine</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmCreateComp"><b>XmlXvmCreateComp</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Create an XSLT compiler</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmDestroy"><b>XmlXvmDestroy</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Destroys an XSLT virtual machine</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmDestroyComp"><b>XmlXvmDestroyComp</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Destroys an XSLT compiler object</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmEvaluateXPath"><b>XmlXvmEvaluateXPath</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Evaluate already-compiled XPath expression</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetBytecodeLength"><b>XmlXvmGetBytecodeLength</b></a></td>

    <td><a href="#XSLTC"><b>XSLTC</b></a></td>
    <td>Returns the bytecode length</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetObjectBoolean"><b>XmlXvmGetObjectBoolean</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Get boolean value of XPath object</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetObjectNSetNode"><b>XmlXvmGetObjectNSetNode</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Get node from nodeset-type XPath object</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetObjectNSetNum"><b>XmlXvmGetObjectNSetNum</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Get number of of nodes in nodeset-type XPath object</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetObjectNumber"><b>XmlXvmGetObjectNumber</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Get number from XPath object</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetObjectString"><b>XmlXvmGetObjectString</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Get string from XPath object</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetObjectType"><b>XmlXvmGetObjectType</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Get XPath object type</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmGetOutputDom"><b>XmlXvmGetOutputDom</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Returns the output DOM</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmResetParams"><b>XmlXvmResetParams</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Resets the stylesheet top-level text params.</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetBaseURI"><b>XmlXvmSetBaseURI</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Sets the base URI for the XSLTVM</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetBytecodeBuffer"><b>XmlXvmSetBytecodeBuffer</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Set the compiled byte-code</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetBytecodeFile"><b>XmlXvmSetBytecodeFile</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Set the compiled bytecode from file</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetBytecodeURI"><b>XmlXvmSetBytecodeURI</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Set the compiled byte-code</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetDebugFunc"><b>XmlXvmSetDebugFunc</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Set a callback function for debuging</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetOutputDom"><b>XmlXvmSetOutputDom</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Sets the XSLTVM to output document node.</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetOutputEncoding"><b>XmlXvmSetOutputEncoding</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Sets the encoding for the XSLTVM output</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetOutputSax"><b>XmlXvmSetOutputSax</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Set XSLTVM to output SAX</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetOutputStream"><b>XmlXvmSetOutputStream</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Set the XSLTVM output to a user-defined stream</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmSetTextParam"><b>XmlXvmSetTextParam</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Set the stylesheet top-level text param.</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmTransformBuffer"><b>XmlXvmTransformBuffer</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Run compiled XSLT stylesheet on XML document in memory</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmTransformDom"><b>XmlXvmTransformDom</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Run compiled XSLT stylesheet on XML document as DOM</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmTransformFile"><b>XmlXvmTransformFile</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Run compiled XSLT stylesheet on XML document in file</td>
  </tr>
  <tr>
    <td width=200><a href="#XmlXvmTransformURI"><b>XmlXvmTransformURI</b></a></td>

    <td><a href="#XSLTVM"><b>XSLTVM</b></a></td>
    <td>Run compiled XSLT stylesheet on XML document from URI</td>
  </tr>
</table></center>

<br><hr noshade size=1><center><h2><a name="XSLTC">Interface XSLTC</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'XSLTC' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XmlXvmCompileBuffer"><b>XmlXvmCompileBuffer</b></a></td>
	       <td>Compile an XSLT stylesheet from buffer into bytecode</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmCompileDom"><b>XmlXvmCompileDom</b></a></td>
	       <td>Compile an XSLT stylesheet from DOM into bytecode</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmCompileFile"><b>XmlXvmCompileFile</b></a></td>
	       <td>Compile XSLT stylesheet from file into bytecode</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmCompileURI"><b>XmlXvmCompileURI</b></a></td>
	       <td>Compile XSLT stylesheet from URI into bytecode</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmCompileXPath"><b>XmlXvmCompileXPath</b></a></td>
	       <td>Compiles an XPath expression</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmCreateComp"><b>XmlXvmCreateComp</b></a></td>
	       <td>Create an XSLT compiler</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmDestroyComp"><b>XmlXvmDestroyComp</b></a></td>
	       <td>Destroys an XSLT compiler object</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetBytecodeLength"><b>XmlXvmGetBytecodeLength</b></a></td>
	       <td>Returns the bytecode length</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="XSLTVM">Interface XSLTVM</a></h2></center>
	   <center><h3>Function Index</h3>
<table summary="Interface 'XSLTVM' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#XMLXVM_DEBUG_F"><b>XMLXVM_DEBUG_F</b></a></td>
	       <td>XML XSLT VM debug function</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmCreate"><b>XmlXvmCreate</b></a></td>
	       <td>Create an XSLT virtual machine</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmDestroy"><b>XmlXvmDestroy</b></a></td>
	       <td>Destroys an XSLT virtual machine</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmEvaluateXPath"><b>XmlXvmEvaluateXPath</b></a></td>
	       <td>Evaluate already-compiled XPath expression</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetObjectBoolean"><b>XmlXvmGetObjectBoolean</b></a></td>
	       <td>Get boolean value of XPath object</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetObjectNSetNode"><b>XmlXvmGetObjectNSetNode</b></a></td>
	       <td>Get node from nodeset-type XPath object</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetObjectNSetNum"><b>XmlXvmGetObjectNSetNum</b></a></td>
	       <td>Get number of of nodes in nodeset-type XPath object</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetObjectNumber"><b>XmlXvmGetObjectNumber</b></a></td>
	       <td>Get number from XPath object</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetObjectString"><b>XmlXvmGetObjectString</b></a></td>
	       <td>Get string from XPath object</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetObjectType"><b>XmlXvmGetObjectType</b></a></td>
	       <td>Get XPath object type</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmGetOutputDom"><b>XmlXvmGetOutputDom</b></a></td>
	       <td>Returns the output DOM</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmResetParams"><b>XmlXvmResetParams</b></a></td>
	       <td>Resets the stylesheet top-level text params.</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetBaseURI"><b>XmlXvmSetBaseURI</b></a></td>
	       <td>Sets the base URI for the XSLTVM</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetBytecodeBuffer"><b>XmlXvmSetBytecodeBuffer</b></a></td>
	       <td>Set the compiled byte-code</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetBytecodeFile"><b>XmlXvmSetBytecodeFile</b></a></td>
	       <td>Set the compiled bytecode from file</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetBytecodeURI"><b>XmlXvmSetBytecodeURI</b></a></td>
	       <td>Set the compiled byte-code</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetDebugFunc"><b>XmlXvmSetDebugFunc</b></a></td>
	       <td>Set a callback function for debuging</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetOutputDom"><b>XmlXvmSetOutputDom</b></a></td>
	       <td>Sets the XSLTVM to output document node.</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetOutputEncoding"><b>XmlXvmSetOutputEncoding</b></a></td>
	       <td>Sets the encoding for the XSLTVM output</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetOutputSax"><b>XmlXvmSetOutputSax</b></a></td>
	       <td>Set XSLTVM to output SAX</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetOutputStream"><b>XmlXvmSetOutputStream</b></a></td>
	       <td>Set the XSLTVM output to a user-defined stream</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmSetTextParam"><b>XmlXvmSetTextParam</b></a></td>
	       <td>Set the stylesheet top-level text param.</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmTransformBuffer"><b>XmlXvmTransformBuffer</b></a></td>
	       <td>Run compiled XSLT stylesheet on XML document in memory</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmTransformDom"><b>XmlXvmTransformDom</b></a></td>
	       <td>Run compiled XSLT stylesheet on XML document as DOM</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmTransformFile"><b>XmlXvmTransformFile</b></a></td>
	       <td>Run compiled XSLT stylesheet on XML document in file</td>
	       </tr>
	       <tr>
	       <td><a href="#XmlXvmTransformURI"><b>XmlXvmTransformURI</b></a></td>
	       <td>Run compiled XSLT stylesheet on XML document from URI</td>
	       </tr>
	   </table></center>
<hr noshade size=1>

<h2 align=center><a name="XMLXVM_DEBUG_F">XMLXVM_DEBUG_F</a></h2>

<table summary="Function 'XMLXVM_DEBUG_F' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XMLXVM_DEBUG_F</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>XML XSLT VM debug function</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>#define&nbsp;XMLXVM_DEBUG_F(func,&nbsp;line,&nbsp;file,&nbsp;obj,&nbsp;n)&nbsp;\<br>void&nbsp;func(ub2&nbsp;line,&nbsp;oratext&nbsp;*file,&nbsp;xvmobj&nbsp;*obj,&nbsp;ub4&nbsp;n)</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XMLXVM_DEBUG_F' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>line</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> source stylesheet line#</td></tr>
<tr><td scope=row><tt>file</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> stylesheet filename</td></tr>
<tr><td scope=row><tt>obj</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> current VM object</td></tr>
<tr><td scope=row><tt>n</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> index of current node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Debug callback function for XSLT VM<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmSetDebugFunc"><tt>XmlXvmSetDebugFunc</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmCompileBuffer">XmlXvmCompileBuffer</a></h2>

<table summary="Function 'XmlXvmCompileBuffer' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmCompileBuffer</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Compile an XSLT stylesheet from buffer into bytecode</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub2&nbsp;*XmlXvmCompileBuffer(xmlxvmcomp&nbsp;*comp,&nbsp;oratext&nbsp;*buffer,&nbsp;ub4&nbsp;length,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*baseURI,&nbsp;xmlxvmflag&nbsp;flags,&nbsp;xmlerr&nbsp;*error);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmCompileBuffer' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>comp</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  compiler object</td></tr>
<tr><td scope=row><tt>buffer</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  pointer to buffer containing stylesheet document</td></tr>
<tr><td scope=row><tt>length</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  the length of the stylesheet document in bytes</td></tr>
<tr><td scope=row><tt>baseuri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  base URI of the document</td></tr>
<tr><td scope=row><tt>flags</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  flags for the current compilation</td></tr>
<tr><td scope=row><tt>error</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> returned error code</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub2 *)</b></tt> bytecode or NULL on error</tr>
<tr><th scope=row><i>Description</i>
<td>        Compile an XSLT stylesheet from buffer into bytecode<p>
        Compiler flags could be one or more of the following:<p>
            XMLXVM_DEBUG      - forces compiler to include debug
                                information into the bytecode<p>
            XMLXVM_STRIPSPACE - same as <tt>&lt;xsl:strip-space elements="*"/&gt;</tt>.<p>
        The generated bytecode resides in a compiler buffer which is freed 
        when next stylesheet is compiled or when compiler object is deleted. 
        Hence, if the bytecode is to be reused it should be copied into 
        another location. <p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmCompileFile"><tt>XmlXvmCompileFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileURI"><tt>XmlXvmCompileURI</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileDom"><tt>XmlXvmCompileDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmCompileDom">XmlXvmCompileDom</a></h2>

<table summary="Function 'XmlXvmCompileDom' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmCompileDom</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Compile an XSLT stylesheet from DOM into bytecode</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub2&nbsp;*XmlXvmCompileDom(xmlxvmcomp&nbsp;*comp,&nbsp;xmldocnode&nbsp;*root,&nbsp;xmlxvmflag&nbsp;flags,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlerr&nbsp;*error);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmCompileDom' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>comp</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  compiler object</td></tr>
<tr><td scope=row><tt>root</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  root element of the stylesheet DOM</td></tr>
<tr><td scope=row><tt>flags</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  flags for the current compilation</td></tr>
<tr><td scope=row><tt>error</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> returned error code</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub2 *)</b></tt> bytecode or NULL on error</tr>
<tr><th scope=row><i>Description</i>
<td>        Compile an XSLT stylesheet from DOM into bytecode <p>
        Compiler flags could be one or more of the following:<p>
            XMLXVM_DEBUG      - forces compiler to include debug
                                information into the bytecode<p>
            XMLXVM_STRIPSPACE - same as <tt>&lt;xsl:strip-space elements="*"/&gt;</tt>.<p>
        The generated bytecode resides in a compiler buffer which is freed 
        when next stylesheet is compiled or when compiler object is deleted. 
        Hence, if the bytecode is to be reused it should be copied into 
        another location. <p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>comp&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmCreateComp(xctx);<br>
code&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmCompileDom(comp,&nbsp;root,&nbsp;XMLXVM_DEBUG,&nbsp;&err);</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmCompileFile"><tt>XmlXvmCompileFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileBuffer"><tt>XmlXvmCompileBuffer</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileURI"><tt>XmlXvmCompileURI</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmCompileFile">XmlXvmCompileFile</a></h2>

<table summary="Function 'XmlXvmCompileFile' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmCompileFile</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Compile XSLT stylesheet from file into bytecode</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub2&nbsp;*XmlXvmCompileFile(xmlxvmcomp&nbsp;*comp,&nbsp;oratext&nbsp;*path,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;*baseURI,&nbsp;xmlxvmflag&nbsp;flags,&nbsp;xmlerr&nbsp;*error);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmCompileFile' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>comp</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  compiler object</td></tr>
<tr><td scope=row><tt>path</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  path of XSL stylesheet file</td></tr>
<tr><td scope=row><tt>baseuri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  base URI of the document</td></tr>
<tr><td scope=row><tt>flags</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  flags for the current compilation</td></tr>
<tr><td scope=row><tt>error</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> returned error code</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub2 *)</b></tt> bytecode or NULL on error</tr>
<tr><th scope=row><i>Description</i>
<td>        Compile XSLT stylesheet from file into bytecode.<p>
        Compiler flags could be one or more of the following:<p>
            XMLXVM_DEBUG      - forces compiler to include debug
                                information into the bytecode<p>
            XMLXVM_STRIPSPACE - same as <tt>&lt;xsl:strip-space elements="*"/&gt;</tt>.<p>
        The generated bytecode resides in a compiler buffer which is freed 
        when next stylesheet is compiled or when compiler object is deleted. 
        Hence, if the bytecode is to be reused it should be copied into 
        another location. <p>

</tr>
<tr><th scope=row><i>Example</i>
<td><tt>comp&nbsp;=&nbsp;XmlXvmCreateComp(xctx);<br>
code&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile1,&nbsp;baseuri,&nbsp;0,&nbsp;&err);<br>
...&nbsp;&nbsp;(copy&nbsp;the&nbsp;code)<br>
code&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile2,&nbsp;baseuri,&nbsp;0,&nbsp;&err);<br>
...&nbsp;&nbsp;(copy&nbsp;the&nbsp;code)</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmCompileURI"><tt>XmlXvmCompileURI</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileBuffer"><tt>XmlXvmCompileBuffer</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileDom"><tt>XmlXvmCompileDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmCompileURI">XmlXvmCompileURI</a></h2>

<table summary="Function 'XmlXvmCompileURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmCompileURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Compile XSLT stylesheet from URI into bytecode</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub2&nbsp;*XmlXvmCompileURI(xmlxvmcomp&nbsp;*comp,&nbsp;oratext&nbsp;*uri,&nbsp;xmlxvmflag&nbsp;flags,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlerr&nbsp;*error);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmCompileURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>comp</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  compiler object</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  URI of the file contining the XSL stylesheet</td></tr>
<tr><td scope=row><tt>flags</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  flags for the current compilation</td></tr>
<tr><td scope=row><tt>error</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> returned error code</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub2 *)</b></tt> bytecode or NULL on error</tr>
<tr><th scope=row><i>Description</i>
<td>        Compile XSLT stylesheet from URI into bytecode<p>
        Compiler flags could be one or more of the following:<p>
            XMLXVM_DEBUG      - forces compiler to include debug
                                information into the bytecode<p>
            XMLXVM_STRIPSPACE - same as <tt>&lt;xsl:strip-space elements="*"/&gt;</tt>.<p>
        The generated bytecode resides in a compiler buffer which is freed 
        when next stylesheet is compiled or when compiler object is deleted. 
        Hence, if the bytecode is to be reused it should be copied into 
        another location. <p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>comp&nbsp;=&nbsp;XmlXvmCreateComp(xctx);<br>
code&nbsp;=&nbsp;XmlXvmCompileURI(comp,&nbsp;xslFile1,&nbsp;uri,&nbsp;XMLXVM_DEBUG,&nbsp;&err);<br>
...&nbsp;&nbsp;(copy&nbsp;the&nbsp;code)<br>
code&nbsp;=&nbsp;XmlXvmCompileURI(comp,&nbsp;xslFile2,&nbsp;uri,&nbsp;XMLXVM_STRIPSPACE,&nbsp;&err);<br>
...&nbsp;&nbsp;(copy&nbsp;the&nbsp;code)</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmCompileFile"><tt>XmlXvmCompileFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileBuffer"><tt>XmlXvmCompileBuffer</tt></a>, <a href="Package-XSLTVM.html#XmlXvmCompileDom"><tt>XmlXvmCompileDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmCompileXPath">XmlXvmCompileXPath</a></h2>

<table summary="Function 'XmlXvmCompileXPath' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmCompileXPath</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Compiles an XPath expression</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub2&nbsp;*XmlXvmCompileXPath(xmlxvmcomp&nbsp;*comp,&nbsp;oratext&nbsp;*xpath,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext&nbsp;**pfxmap,&nbsp;xmlerr&nbsp;*error);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmCompileXPath' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>comp</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  Compiler object</td></tr>
<tr><td scope=row><tt>xpath</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  XPath expression</td></tr>
<tr><td scope=row><tt>pfxmap</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  array of prefix-URI mappings</td></tr>
<tr><td scope=row><tt>error</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> returned error code</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub2 *)</b></tt> XPath expression bytecode or NULL on error</tr>
<tr><th scope=row><i>Description</i>
<td>        Compiles an XPath expression.  The optional pfxmap is used
        to map namespace prefixes to URIs in the XPath expression.
        It is an array of prefix, URI values, endinging in NULL,
        for example:<p>
        oratext *my_pfx_map[] = <tt>
            "pfx1", "/this/that/pfx1/uri",
            "pfx2", "/this/that/another/pfx2/uri",
            NULL
        </tt>;<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>comp&nbsp;=&nbsp;XmlXvmCreateComp(xctx);<br>
code&nbsp;=&nbsp;XmlXvmCompileXPath(comp,&nbsp;"pfx1:doc/employee[4]",<br>
				&nbsp;&nbsp;my_pfx_map,&nbsp;&err);</tt></tr>

</table>

<h2 align=center><a name="XmlXvmCreate">XmlXvmCreate</a></h2>

<table summary="Function 'XmlXvmCreate' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmCreate</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an XSLT virtual machine</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlxvm&nbsp;*XmlXvmCreate(xmlctx&nbsp;*xctx,&nbsp;...);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmCreate' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
<tr><td scope=row><tt>...</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> list of zero or more properties to be set, NULL-terminated</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlxvm *)</b></tt> XSLT virtual machine object, or NULL on error</tr>
<tr><th scope=row><i>Description</i>
<td>        Create an XSLT virtual machine.
        Zero or more of the following XSLTVM properties could be set by
        using this API:<p>
            "VMStack", size,     - sets the size[Kbyte] of the main VM stack.
                                   Default size is 4K.<p>
            "NodeStack", size,   - sets the size[Kbyte] of the node-stack
                                   Default size is 16K.<p>
            "StringStack", size  - sets the size[Kbyte] of the string-stack
                                   Default size is 64K.<p>
        If the stack size is not specified the default size is used.  The
        explicit stack size seting is needed when XSLTVM terminates with
        "Stack Overflow" message or when smaller memory footprints are
        required.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>vm&nbsp;=&nbsp;XmlXvmCreate(xctx);<br>
XmlXvmDestroy(vm);<br>
...<br>
vm&nbsp;=&nbsp;XmlXvmCreate(xctx,&nbsp;"VMStack",&nbsp;10,&nbsp;"NodeStack",&nbsp;24,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"StringStack",&nbsp;24,&nbsp;NULL);</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmDestroy"><tt>XmlXvmDestroy</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmCreateComp">XmlXvmCreateComp</a></h2>

<table summary="Function 'XmlXvmCreateComp' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmCreateComp</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an XSLT compiler</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlxvmcomp&nbsp;*XmlXvmCreateComp(xmlctx&nbsp;*xctx);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmCreateComp' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XML context</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlxvmcomp *)</b></tt> XSLT compiler object, or NULL on error</tr>
<tr><th scope=row><i>Description</i>
<td>        Create an XSLT compiler object. The XSLT compiler is used to compile
        XSLT stylesheets into bytecode.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>comp&nbsp;=&nbsp;XmlXvmCreateComp(xctx);<br>
code&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile1,&nbsp;baseuri,&nbsp;0,&nbsp;&err);<br>
code&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile2,&nbsp;baseuri,&nbsp;0,&nbsp;&err);<br>
...<br>
--&nbsp;the&nbsp;following&nbsp;is&nbsp;an&nbsp;example&nbsp;of&nbsp;bytecode&nbsp;instructions&nbsp;sequence:<br>
...<br>
14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;xsl:apply-templates&nbsp;select="@*&nbsp;|&nbsp;node()"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;PUSHCUR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;ATTRIBUTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;PUSHCUR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;CHILD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;47&nbsp;&nbsp;&nbsp;&nbsp;UNION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;PUSHCTX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[loop][context]<br>
&nbsp;&nbsp;&nbsp;&nbsp;49&nbsp;&nbsp;&nbsp;&nbsp;FOREACH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code:&nbsp;@-8&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;PUSHCUR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;52&nbsp;&nbsp;&nbsp;&nbsp;MATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;54&nbsp;&nbsp;&nbsp;&nbsp;CALLTEMPLATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;55&nbsp;&nbsp;&nbsp;&nbsp;BRA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code:&nbsp;@6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;57&nbsp;&nbsp;&nbsp;&nbsp;TESTCURNDTYPE&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;59&nbsp;&nbsp;&nbsp;&nbsp;BNO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;code:&nbsp;@-3&nbsp;&nbsp;&nbsp;<br>
...</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmDestroyComp"><tt>XmlXvmDestroyComp</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmDestroy">XmlXvmDestroy</a></h2>

<table summary="Function 'XmlXvmDestroy' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmDestroy</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Destroys an XSLT virtual machine</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlXvmDestroy(xmlxvm&nbsp;*vm);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmDestroy' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>comp</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XSLT virtual machine object</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Destroys an XSLT virtual machine<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmCreate"><tt>XmlXvmCreate</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmDestroyComp">XmlXvmDestroyComp</a></h2>

<table summary="Function 'XmlXvmDestroyComp' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmDestroyComp</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Destroys an XSLT compiler object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlXvmDestroyComp(xmlxvmcomp&nbsp;*comp);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmDestroyComp' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>comp</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XSLT compiler object</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Destroys an XSLT compiler object<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmCreateComp"><tt>XmlXvmCreateComp</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmEvaluateXPath">XmlXvmEvaluateXPath</a></h2>

<table summary="Function 'XmlXvmEvaluateXPath' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmEvaluateXPath</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Evaluate already-compiled XPath expression</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xvmobj&nbsp;*XmlXvmEvaluateXPath(xmlxvm&nbsp;*vm,&nbsp;ub2&nbsp;*bytecode,&nbsp;ub4&nbsp;ctxpos,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;ctxsize,&nbsp;xmlnode&nbsp;*ctxnode);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmEvaluateXPath' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XSLTVM object</td></tr>
<tr><td scope=row><tt>bytecode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XPath expression bytecode</td></tr>
<tr><td scope=row><tt>ctxpos</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> current context position</td></tr>
<tr><td scope=row><tt>ctxsize</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> current context size</td></tr>
<tr><td scope=row><tt>ctxnode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> current context node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xvmobj *)</b></tt> XPath object</tr>
<tr><th scope=row><i>Description</i>
<td>        Evaluate already-compiled XPath expression<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>code&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmCompileXPath(comp,&nbsp;xpath,&nbsp;NULL,&nbsp;&err);<br>
obj&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmEvaluateXPath(vm,&nbsp;code,&nbsp;1,&nbsp;1,&nbsp;node);<br>
switch&nbsp;(XmlXvmGetObjectType(obj))<br>
...</tt></tr>

</table>

<h2 align=center><a name="XmlXvmGetBytecodeLength">XmlXvmGetBytecodeLength</a></h2>

<table summary="Function 'XmlXvmGetBytecodeLength' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetBytecodeLength</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTC">XSLTC</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns the bytecode length</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlXvmGetBytecodeLength(ub2&nbsp;*bytecode,&nbsp;xmlerr&nbsp;*error);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetBytecodeLength' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>bytecode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  bytecode buffer</td></tr>
<tr><td scope=row><tt>error</tt></td>
<td>&nbsp;<b>(OUT)</b>&nbsp;</td>
<td> returned error code</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> The bytecode length in bytes.</tr>
<tr><th scope=row><i>Description</i>
<td>        The bytecode length is needed when the bytecode is to be copied 
        or when it is set into XSLTVM.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>len&nbsp;=&nbsp;XmlXvmGetBytecodeLength(code,&nbsp;&err);<br>
err&nbsp;=&nbsp;XmlXvmSetBytecodeBuffer&nbsp;(vm,&nbsp;code,&nbsp;len);</tt></tr>

</table>

<h2 align=center><a name="XmlXvmGetObjectBoolean">XmlXvmGetObjectBoolean</a></h2>

<table summary="Function 'XmlXvmGetObjectBoolean' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetObjectBoolean</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get boolean value of XPath object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>boolean&nbsp;XmlXvmGetObjectBoolean(xvmobj&nbsp;*obj);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetObjectBoolean' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xobj</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XPath object.</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> value of an XPath object</tr>
<tr><th scope=row><i>Description</i>
<td>        Get boolean value of XPath object<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>obj&nbsp;=&nbsp;XmlXvmEvaluateXPath(vm,&nbsp;code,&nbsp;1,&nbsp;1,&nbsp;node);<br>
switch&nbsp;(XmlXvmGetObjectType(obj))&nbsp;<br>
</tt><i><br>
	&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_BOOL:<br>
		bool&nbsp;=&nbsp;XmlXvmGetObjectBoolean(obj);<br>
		...<br>
</i><tt></tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmGetObjectType"><tt>XmlXvmGetObjectType</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNum"><tt>XmlXvmGetObjectNSetNum</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNode"><tt>XmlXvmGetObjectNSetNode</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNumber"><tt>XmlXvmGetObjectNumber</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectBoolean"><tt>XmlXvmGetObjectBoolean</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmGetObjectNSetNode">XmlXvmGetObjectNSetNode</a></h2>

<table summary="Function 'XmlXvmGetObjectNSetNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetObjectNSetNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node from nodeset-type XPath object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlnode&nbsp;*XmlXvmGetObjectNSetNode(xvmobj&nbsp;*obj,&nbsp;ub4&nbsp;i);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetObjectNSetNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xobj</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XPath object</td></tr>
<tr><td scope=row><tt>i</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node index in nodeset</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode *)</b></tt> The object type or values.</tr>
<tr><th scope=row><i>Description</i>
<td>        Get node from nodeset-type XPath object<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>obj&nbsp;=&nbsp;XmlXvmEvaluateXPath(vm,&nbsp;code,&nbsp;1,&nbsp;1,&nbsp;node);<br>
switch&nbsp;(XmlXvmGetObjectType(obj))&nbsp;</tt><i><br>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_NDSET:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objnum&nbsp;=&nbsp;XmlXvmGetObjectNSetNum(obj);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;objnum;&nbsp;i++)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;XmlXvmGetObjectNSetNode(obj,&nbsp;i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
</i><tt></tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmGetObjectType"><tt>XmlXvmGetObjectType</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNum"><tt>XmlXvmGetObjectNSetNum</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectString"><tt>XmlXvmGetObjectString</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNumber"><tt>XmlXvmGetObjectNumber</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectBoolean"><tt>XmlXvmGetObjectBoolean</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmGetObjectNSetNum">XmlXvmGetObjectNSetNum</a></h2>

<table summary="Function 'XmlXvmGetObjectNSetNum' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetObjectNSetNum</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get number of of nodes in nodeset-type XPath object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>ub4&nbsp;XmlXvmGetObjectNSetNum(xvmobj&nbsp;*obj);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetObjectNSetNum' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xobj</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XPath object (nodeset)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> number of nodes in nodeset</tr>
<tr><th scope=row><i>Description</i>
<td>        Get number of of nodes in nodeset-type XPath object<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>obj&nbsp;=&nbsp;XmlXvmEvaluateXPath(vm,&nbsp;code,&nbsp;1,&nbsp;1,&nbsp;node);<br>
switch&nbsp;(XmlXvmGetObjectType(obj))&nbsp;</tt><i><br>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_NDSET:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objnum&nbsp;=&nbsp;XmlXvmGetObjectNSetNum(obj);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;objnum;&nbsp;i++)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;=&nbsp;XmlXvmGetObjectNSetNode(obj,&nbsp;i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
</i><tt></tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmGetObjectType"><tt>XmlXvmGetObjectType</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNode"><tt>XmlXvmGetObjectNSetNode</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectString"><tt>XmlXvmGetObjectString</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNumber"><tt>XmlXvmGetObjectNumber</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectBoolean"><tt>XmlXvmGetObjectBoolean</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmGetObjectNumber">XmlXvmGetObjectNumber</a></h2>

<table summary="Function 'XmlXvmGetObjectNumber' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetObjectNumber</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get number from XPath object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>double&nbsp;XmlXvmGetObjectNumber(xvmobj&nbsp;*obj);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetObjectNumber' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xobj</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XPath object.</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(double)</b></tt> number</tr>
<tr><th scope=row><i>Description</i>
<td>        Get number from XPath object<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>obj&nbsp;=&nbsp;XmlXvmEvaluateXPath(vm,&nbsp;code,&nbsp;1,&nbsp;1,&nbsp;node);<br>
switch&nbsp;(XmlXvmGetObjectType(obj))&nbsp;<br>
</tt><i><br>
	&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_NUM:<br>
		num&nbsp;=&nbsp;XmlXvmGetObjectNumber(obj);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
</i><tt></tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmGetObjectType"><tt>XmlXvmGetObjectType</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNum"><tt>XmlXvmGetObjectNSetNum</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNode"><tt>XmlXvmGetObjectNSetNode</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectString"><tt>XmlXvmGetObjectString</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectBoolean"><tt>XmlXvmGetObjectBoolean</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmGetObjectString">XmlXvmGetObjectString</a></h2>

<table summary="Function 'XmlXvmGetObjectString' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetObjectString</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get string from XPath object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>oratext&nbsp;*XmlXvmGetObjectString(xvmobj&nbsp;*obj);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetObjectString' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xobj</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XPath object.</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> string</tr>
<tr><th scope=row><i>Description</i>
<td>        Get string from XPath object<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>obj&nbsp;=&nbsp;XmlXvmEvaluateXPath(vm,&nbsp;code,&nbsp;1,&nbsp;1,&nbsp;node);<br>
switch&nbsp;(XmlXvmGetObjectType(obj))&nbsp;<br>
</tt><i><br>
	&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_STR:<br>
		str&nbsp;=&nbsp;XmlXvmGetObjectString(obj);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
</i><tt></tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmGetObjectType"><tt>XmlXvmGetObjectType</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNum"><tt>XmlXvmGetObjectNSetNum</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNode"><tt>XmlXvmGetObjectNSetNode</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNumber"><tt>XmlXvmGetObjectNumber</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectBoolean"><tt>XmlXvmGetObjectBoolean</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmGetObjectType">XmlXvmGetObjectType</a></h2>

<table summary="Function 'XmlXvmGetObjectType' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetObjectType</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get XPath object type</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlxvmobjtype&nbsp;XmlXvmGetObjectType(xvmobj&nbsp;*obj);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetObjectType' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>xobj</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XPath object</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlxvmobjtype)</b></tt> type-code for object</tr>
<tr><th scope=row><i>Description</i>
<td>        Get XPath object type<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>switch&nbsp;(XmlXvmGetObjectType(obj))&nbsp;</tt><i><br>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_NDSET:&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_BOOL:&nbsp;...&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_NUM:&nbsp;...&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_FRAG:&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XMLXVM_TYPE_STR:&nbsp;...<br>
</i><tt></tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNum"><tt>XmlXvmGetObjectNSetNum</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNSetNode"><tt>XmlXvmGetObjectNSetNode</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectString"><tt>XmlXvmGetObjectString</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectNumber"><tt>XmlXvmGetObjectNumber</tt></a>, <a href="Package-XSLTVM.html#XmlXvmGetObjectBoolean"><tt>XmlXvmGetObjectBoolean</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmGetOutputDom">XmlXvmGetOutputDom</a></h2>

<table summary="Function 'XmlXvmGetOutputDom' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmGetOutputDom</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Returns the output DOM</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlfragnode&nbsp;*XmlXvmGetOutputDom(xmlxvm&nbsp;*vm);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmGetOutputDom' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlfragnode *)</b></tt> output DOM, or NULL in a case of SAX or Stream output.</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the root node of the result DOM tree (if any).
        XmlXvmSetOutputDom() has to be used before transformation to set 
        the VM to output a DOM tree (the default VM output is a stream). <p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>doc&nbsp;&nbsp;=&nbsp;XmlCreateDocument(xctx,&nbsp;&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;&err);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmSetOutputDom(vm,&nbsp;doc);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmTransformFile(vm,&nbsp;...);&nbsp;<br>
root&nbsp;=&nbsp;XmlXvmGetOutputDom(vm);</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmSetOutputDom"><tt>XmlXvmSetOutputDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmResetParams">XmlXvmResetParams</a></h2>

<table summary="Function 'XmlXvmResetParams' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmResetParams</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Resets the stylesheet top-level text params.</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>void&nbsp;XmlXvmResetParams(xmlxvm&nbsp;*vm);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmResetParams' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        No returns.</tr>
<tr><th scope=row><i>Description</i>
<td>        Resets the stylesheet top-level param with their default values.<p>
</tr>
</table>

<h2 align=center><a name="XmlXvmSetBaseURI">XmlXvmSetBaseURI</a></h2>

<table summary="Function 'XmlXvmSetBaseURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetBaseURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Sets the base URI for the XSLTVM</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetBaseURI(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*baseuri);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetBaseURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>baseuri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM baseuri for reading and writing documents</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code.</tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the base URI for the XSLTVM. The baseuri is used by VM to 
        the compose the path XML documents to be loaded for transformation
        using document() or XmlXvmTransformFile().<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>err&nbsp;&nbsp;=&nbsp;XmlXvmSetBaseURI(vm,&nbsp;"/doc/myxmlfiles/");<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmTransformFile(vm,&nbsp;"xmlfile1",&nbsp;NULL);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmTransformFile(vm,&nbsp;"xmlfile2",&nbsp;NULL);<br>
...</tt></tr>

</table>

<h2 align=center><a name="XmlXvmSetBytecodeBuffer">XmlXvmSetBytecodeBuffer</a></h2>

<table summary="Function 'XmlXvmSetBytecodeBuffer' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetBytecodeBuffer</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set the compiled byte-code</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetBytecodeBuffer(xmlxvm&nbsp;*vm,&nbsp;ub2&nbsp;*buffer,&nbsp;size_t&nbsp;buflen);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetBytecodeBuffer' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XSLT VM context</td></tr>
<tr><td scope=row><tt>buffer</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> user's buffer</td></tr>
<tr><td scope=row><tt>buflen</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> size of buffer in bytes</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, XMLERR_OK [<i>0</i>] on success</tr>
<tr><th scope=row><i>Description</i>
<td>       Set the compiled bytecode from buffer. Any previously set bytecode 
       is replaced. An XML transformation can't be performed if the stylesheet 
       bytecode is not set. The VM doesn't copy the bytecode into internal 
       buffer, hence the it shouldn't be freed before VM finishes using it. <p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>code&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile,&nbsp;baseuri,&nbsp;flags,&nbsp;&err);<br>
len&nbsp;=&nbsp;XmlXvmGetBytecodeLength(code,&nbsp;&err);<br>
err&nbsp;=&nbsp;XmlXvmSetBytecodeBuffer(vm,&nbsp;code,&nbsp;len);</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmSetBytecodeFile"><tt>XmlXvmSetBytecodeFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmSetBytecodeURI"><tt>XmlXvmSetBytecodeURI</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmSetBytecodeFile">XmlXvmSetBytecodeFile</a></h2>

<table summary="Function 'XmlXvmSetBytecodeFile' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetBytecodeFile</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set the compiled bytecode from file</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetBytecodeFile(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*path);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetBytecodeFile' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XSLT VM context</td></tr>
<tr><td scope=row><tt>path</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> path of bytecode file</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, XMLERR_OK [<i>0</i>] on success</tr>
<tr><th scope=row><i>Description</i>
<td>       Set the compiled bytecode from file. Any previously set bytecode 
       is replaced. An XML transformation can't be performed if the stylesheet 
       bytecode is not set.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>err&nbsp;=&nbsp;XmlXvmSetBytecodeFile(vm,&nbsp;codefile);<br>
err&nbsp;=&nbsp;XmlXvmTransformFile&nbsp;(vm,&nbsp;xmlFile,&nbsp;baseuri);</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmSetBytecodeURI"><tt>XmlXvmSetBytecodeURI</tt></a>, <a href="Package-XSLTVM.html#XmlXvmSetBytecodeBuffer"><tt>XmlXvmSetBytecodeBuffer</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmSetBytecodeURI">XmlXvmSetBytecodeURI</a></h2>

<table summary="Function 'XmlXvmSetBytecodeURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetBytecodeURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set the compiled byte-code</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetBytecodeURI(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*uri);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetBytecodeURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XSLT VM context</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> URI</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, XMLERR_OK [<i>0</i>] on success</tr>
<tr><th scope=row><i>Description</i>
<td>       Set the compiled bytecode from URI. Any previously set bytecode 
       is replaced. An XML transformation can't be performed if the stylesheet 
       bytecode is not set.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmSetBytecodeFile"><tt>XmlXvmSetBytecodeFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmSetBytecodeBuffer"><tt>XmlXvmSetBytecodeBuffer</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmSetDebugFunc">XmlXvmSetDebugFunc</a></h2>

<table summary="Function 'XmlXvmSetDebugFunc' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetDebugFunc</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set a callback function for debuging</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>#define&nbsp;XMLXVM_DEBUG_FUNC(func)&nbsp;\<br>void&nbsp;func&nbsp;(ub2&nbsp;line,&nbsp;oratext&nbsp;*filename,&nbsp;xvmobj&nbsp;*obj,&nbsp;ub4&nbsp;n)<br>xmlerr&nbsp;XmlXvmSetDebugFunc(xmlxvm&nbsp;*vm,&nbsp;XMLXVM_DEBUG_FUNC(debugcallback));</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetDebugFunc' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> XSLT VM context</td></tr>
<tr><td scope=row><tt>func</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> the callback function</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> numeric error code, XMLERR_OK [<i>0</i>] on success</tr>
<tr><th scope=row><i>Description</i>
<td>       The user callback function is invoked by VM every time the execution
       reaches a new line in the XSLT stylesheet. The VM passes to the user 
       the stylesheet file name, the line number, the current context nodes-set
       and the current node index in the node-set. 
       IMPORTANT - the stylesheet has to be compiled with flag XMLXVM_DEBUG.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>XMLXVM_DEBUG_F(MyCallbackFunction,&nbsp;line,&nbsp;file,&nbsp;obj,&nbsp;n);<br>
...<br>
code&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile,&nbsp;NULL,&nbsp;XMLXVM_DEBUG,&nbsp;&err);<br>
...<br>
vm&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmCreate(xctx,&nbsp;NULL);<br>
len&nbsp;&nbsp;=&nbsp;XmlXvmGetBytecodeLength(code,&nbsp;&err);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmSetBytecodeBuffer(vm,&nbsp;code,&nbsp;len);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmSetDebugFunc(vm,&nbsp;MyCallbackFunction);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmTransformFile(vm,&nbsp;xmlFile,&nbsp;baseuri);</tt></tr>

</table>

<h2 align=center><a name="XmlXvmSetOutputDom">XmlXvmSetOutputDom</a></h2>

<table summary="Function 'XmlXvmSetOutputDom' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetOutputDom</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Sets the XSLTVM to output document node.</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetOutputDom(xmlxvm&nbsp;*vm,&nbsp;xmldocnode&nbsp;*doc);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetOutputDom' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> empty document</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code</tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the XSLTVM to output DOM. If (xmldocnode == NULL) then the 
        result DOM tree belongs to the VM object and is deleted when 
        a new transformation is performed or when the VM object is deleted.
        If the result DOM tree is to be used for longer period of time then
        an xmldocnode has to be created and set to the VM object.         <p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>doc&nbsp;&nbsp;=&nbsp;XmlCreateDocument(xctx,&nbsp;&nbsp;NULL,&nbsp;NULL,&nbsp;NULL,&nbsp;&err);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmSetOutputDom(vm,&nbsp;doc);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmTransformFile(vm,&nbsp;...);&nbsp;<br>
root&nbsp;=&nbsp;XmlXvmGetOutputDom(vm);</tt></tr>

</table>

<h2 align=center><a name="XmlXvmSetOutputEncoding">XmlXvmSetOutputEncoding</a></h2>

<table summary="Function 'XmlXvmSetOutputEncoding' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetOutputEncoding</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Sets the encoding for the XSLTVM output</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetOutputEncoding(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*encoding);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetOutputEncoding' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>encoding</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> output encoding</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code.</tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the encoding for the XSLTVM stream output. If the input (data) 
        encoding is different from the one set by this APIs then encoding
        conversion is performed. This APIs overrides the encoding set in the
        XSLT stylesheet (if any).<p>
</tr>
</table>

<h2 align=center><a name="XmlXvmSetOutputSax">XmlXvmSetOutputSax</a></h2>

<table summary="Function 'XmlXvmSetOutputSax' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetOutputSax</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set XSLTVM to output SAX</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetOutputSax(xmlxvm&nbsp;*vm,&nbsp;xmlsaxcb&nbsp;*saxcb,&nbsp;void&nbsp;*saxctx);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetOutputSax' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>saxcb</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> SAX callback object</td></tr>
<tr><td scope=row><tt>saxctx</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> SAX context</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code</tr>
<tr><th scope=row><i>Description</i>
<td>        Set XSLTVM to output SAX. If the SAX callback interface object is
        provided the VM outputs the result document in a form of SAX events
        using the user specified callback functions. <p>
</tr>
</table>

<h2 align=center><a name="XmlXvmSetOutputStream">XmlXvmSetOutputStream</a></h2>

<table summary="Function 'XmlXvmSetOutputStream' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetOutputStream</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set the XSLTVM output to a user-defined stream</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetOutputStream(xmlxvm&nbsp;*vm,&nbsp;xmlostream&nbsp;*ostream);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetOutputStream' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>ostream</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> stream object</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code.</tr>
<tr><th scope=row><i>Description</i>
<td>        Set the XSLTVM output to a user-defined stream. The default XSLTVM
        output is a stream. This APIs overrides the default stream with 
        user spesified APIs for writing. <p>
</tr>
</table>

<h2 align=center><a name="XmlXvmSetTextParam">XmlXvmSetTextParam</a></h2>

<table summary="Function 'XmlXvmSetTextParam' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmSetTextParam</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set the stylesheet top-level text param.</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmSetTextParam(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*name,&nbsp;oratext&nbsp;*value);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmSetTextParam' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name of top-level param</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> value of top-level param</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code, XMLERR_SUCC [<i>0</i>] on success.</tr>
<tr><th scope=row><i>Description</i>
<td>        Set the stylesheet top-level text param. The param value set in the
        XSLT stylesheet is overritten. Since the top-level param are reset
        with stylesheed values after each transformation this APIs has to be 
        called again.<p>
</tr>
</table>

<h2 align=center><a name="XmlXvmTransformBuffer">XmlXvmTransformBuffer</a></h2>

<table summary="Function 'XmlXvmTransformBuffer' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmTransformBuffer</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Run compiled XSLT stylesheet on XML document in memory</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmTransformBuffer(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ub4&nbsp;length,&nbsp;oratext&nbsp;*baseURI);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmTransformBuffer' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>buffer</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> NULL-terminated buffer containing the XML document</td></tr>
<tr><td scope=row><tt>length</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> the length of the XML document</td></tr>
<tr><td scope=row><tt>baseURI(IN)</tt></td>
<td>&nbsp;<b>(base)</b>&nbsp;</td>
<td> base URI of the XML document</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code.</tr>
<tr><th scope=row><i>Description</i>
<td>        Run compiled XSLT stylesheet on XML document in memory.  The
        compiled XSLT stylesheet (bytecode) should be set using
        XmlXvmSetBytecode...() prior to this call.  xsl:output is supported 
        only if the output is a stream instead of DOM or SAX.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmTransformFile"><tt>XmlXvmTransformFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformURI"><tt>XmlXvmTransformURI</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformDom"><tt>XmlXvmTransformDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmTransformDom">XmlXvmTransformDom</a></h2>

<table summary="Function 'XmlXvmTransformDom' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmTransformDom</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Run compiled XSLT stylesheet on XML document as DOM</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmTransformDom(xmlxvm&nbsp;*vm,&nbsp;xmldocnode&nbsp;*root);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmTransformDom' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>root</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> root element of the XML document's DOM</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code.</tr>
<tr><th scope=row><i>Description</i>
<td>        Run compiled XSLT stylesheet on XML document as DOM.  The compiled
        XSLT stylesheet (bytecode) should be set using XmlXvmSetBytecode...()
        prior to this call.  xsl:output is supported only if the output is
        a stream instead of DOM or SAX.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>code&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile,&nbsp;baseuri,&nbsp;0,&nbsp;&err);<br>
vm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmCreate(xctx,&nbsp;NULL);<br>
len&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmGetBytecodeLength(code,&nbsp;&err);<br>
err&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmSetBytecodeBuffer&nbsp;(vm,&nbsp;code,&nbsp;len);&nbsp;<br>
domdoc&nbsp;=&nbsp;XmlLoadDom(xctx,&nbsp;&err,&nbsp;"uri",&nbsp;xmlFile,&nbsp;NULL);<br>
err&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmTransformDom(vm,&nbsp;domdoc);<br>
err&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmTransformDom&nbsp;(vm,&nbsp;domdoc);</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmTransformFile"><tt>XmlXvmTransformFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformURI"><tt>XmlXvmTransformURI</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformBuffer"><tt>XmlXvmTransformBuffer</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmTransformFile">XmlXvmTransformFile</a></h2>

<table summary="Function 'XmlXvmTransformFile' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmTransformFile</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Run compiled XSLT stylesheet on XML document in file</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmTransformFile(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*path,&nbsp;oratext&nbsp;*baseURI);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmTransformFile' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>path</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> path of XML document to transform</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code</tr>
<tr><th scope=row><i>Description</i>
<td>        Run compiled XSLT stylesheet on XML document in file.  The compiled
        XSLT stylesheet (bytecode) should be set using XmlXvmSetBytecode ...()
        prior to this call.  xsl:output is supported only if the output is
        a stream instead of DOM or SAX.<p>
</tr>
<tr><th scope=row><i>Example</i>
<td><tt>code&nbsp;=&nbsp;XmlXvmCompileFile(comp,&nbsp;xslFile,&nbsp;baseuri,&nbsp;0,&nbsp;&err);<br>
...<br>
vm&nbsp;&nbsp;&nbsp;=&nbsp;XmlXvmCreate(xctx,&nbsp;NULL);<br>
len&nbsp;&nbsp;=&nbsp;XmlXvmGetBytecodeLength(code,&nbsp;&err);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmSetBytecodeBuffer(vm,&nbsp;code,&nbsp;len);<br>
err&nbsp;&nbsp;=&nbsp;XmlXvmTransformFile(vm,&nbsp;xmlFile[i],&nbsp;baseuri);</tt></tr>

<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmTransformURI"><tt>XmlXvmTransformURI</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformBuffer"><tt>XmlXvmTransformBuffer</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformDom"><tt>XmlXvmTransformDom</tt></a></td></tr>
</table>

<h2 align=center><a name="XmlXvmTransformURI">XmlXvmTransformURI</a></h2>

<table summary="Function 'XmlXvmTransformURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>XmlXvmTransformURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#XSLTVM">XSLTVM</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Run compiled XSLT stylesheet on XML document from URI</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>xmlerr&nbsp;XmlXvmTransformURI(xmlxvm&nbsp;*vm,&nbsp;oratext&nbsp;*uri);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'XmlXvmTransformURI' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>vm</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> VM object</td></tr>
<tr><td scope=row><tt>uri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> URI of XML document to transform</td></tr>
<tr><td scope=row><tt>baseuri</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> base URI of XML document</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlerr)</b></tt> error code.</tr>
<tr><th scope=row><i>Description</i>
<td>        Run compiled XSLT stylesheet on XML document from URI.  The compiled
        XSLT stylesheet (bytecode) should be set using XmlXvmSetBytecode ...() 
        prior to this call.  xsl:output is supported only if the output is
        a stream instead of DOM or SAX.<p>
</tr>
<tr><th scope=row><i>See Also</i><td>
<a href="Package-XSLTVM.html#XmlXvmTransformFile"><tt>XmlXvmTransformFile</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformBuffer"><tt>XmlXvmTransformBuffer</tt></a>, <a href="Package-XSLTVM.html#XmlXvmTransformDom"><tt>XmlXvmTransformDom</tt></a></td></tr>
</table>
</body>
</html>
