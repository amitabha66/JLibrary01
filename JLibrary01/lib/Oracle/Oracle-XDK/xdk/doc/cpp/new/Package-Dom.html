<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- WARNING!  THIS IS A GENERATED FILE!!  DO NOT EDIT!!! -->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Dom APIs</title>
</head>
<body bgcolor=white>
<a name="_top_"></a>
<center><table width="90%"><tr><td align=left>
<b>Packages: <a href="packages.html">All</a></b>
 | <b><a href="Package-Ctx.html">Ctx</a></b>
 | <b><a href="Package-Dom.html">Dom</a></b>
 | <b><a href="Package-IO.html">IO</a></b>
 | <b><a href="Package-OracleXml.html">OracleXml</a></b>
 | <b><a href="Package-Parser.html">Parser</a></b>
 | <b><a href="Package-Tools.html">Tools</a></b>
 | <b><a href="Package-XPath.html">XPath</a></b>
 | <b><a href="Package-XPointer.html">XPointer</a></b>
 | <b><a href="Package-Xsl.html">Xsl</a></b>
</td><td align=right><b><a href="Functions.html">Functions</a></b>
 | <b><a href="Datatypes.html">Datatypes</a></b></td></tr></table>
</center><hr noshade size=1>
<center><h1>Package Dom</h1></center>

    DOM interfaces are represented as generic references to different
    implementations of the DOM spec. They are parameterized by Node
    that supports various specializatins and instantiations. Of them,
    the most important is xmlnode that corresponds to the current C
    implementation<p>    These generic references do not have a NULL like value. Any
    implementation should never create a reference with no state
    (like NULL). If there is need to signal that something has
    no state, an exception should be thrown.<p>    Many methods might throw the SYNTAX_ERR exception, if the DOM
    tree is incorrectly formed, or UNDEFINED_ERR, in the case
    of wrong parameters or unexpected NULL pointers .  If these are
    the only errors that a particular method might throw, it is not
    reflected in the method signature.<p>    Actual DOM trees do NOT dependent on the context (TCtx). However,
    manipulations on DOM trees in the current, xmlctx based implementation
    require access to the current context (TCtx). This is accomplished by
    passing the context pointer to the constructor of DOMImplRef. In
    multithreaded environment DOMImplRef is always created in the thread
    context and, so, has the pointer to the right context.<p>    DOMImplRef providea a way to create DOM trees. DomImplRef is a
    reference to the actual DOMImplementation object that is created when
    a regular, non-copy constructor of DomImplRef is invoked. This works
    well in multithreaded environment where DOM trees need to be shared,
    and each thread has a separate TCtx associated with it. This works
    equally well in a single threaded environment.<p>    DOMString is only one of encodings supported by Oracle
    implementations. The support of other encodings is Oracle's
    extension. The oratext* data type is used for all encodings.<p>    Interfaces in this package represent DOM level 2 Core interfaces
    according to http://www.w3.org/TR/DOM-Level-2-Core/core.html<p>
<ul>
    <li><a href="#functions"><b>Member Function Index</b></a>
    <li><a href="#AttrRef">Interface <b>AttrRef</b></a> (reference to Attribute nodes)
    <li><a href="#CDATASectionRef">Interface <b>CDATASectionRef</b></a> (reference to CDATASection nodes)
    <li><a href="#CharacterDataRef">Interface <b>CharacterDataRef</b></a>
    <li><a href="#CommentRef">Interface <b>CommentRef</b></a> (reference to Comment nodes)
    <li><a href="#DOMException">Interface <b>DOMException</b></a> (Exception class for DOM operations)
    <li><a href="#DOMImplRef">Interface <b>DOMImplRef</b></a> (reference to DOMImplementation)
    <li><a href="#DOMImplementation">Interface <b>DOMImplementation</b></a> (handles DOM trees)
    <li><a href="#DocumentFragmentRef">Interface <b>DocumentFragmentRef</b></a> (reference to Fragment nodes)
    <li><a href="#DocumentRange">Interface <b>DocumentRange</b></a> (DOM 2 interface)
    <li><a href="#DocumentRef">Interface <b>DocumentRef</b></a> (reference to Document nodes)
    <li><a href="#DocumentTraversal">Interface <b>DocumentTraversal</b></a> (DOM 2 interface)
    <li><a href="#DocumentTypeRef">Interface <b>DocumentTypeRef</b></a> (reference to DTD nodes)
    <li><a href="#ElementRef">Interface <b>ElementRef</b></a> (reference to Element nodes)
    <li><a href="#EntityRef">Interface <b>EntityRef</b></a> (reference to Entity nodes)
    <li><a href="#EntityReferenceRef">Interface <b>EntityReferenceRef</b></a> (reference to EntityReference nodes)
    <li><a href="#NamedNodeMap">Interface <b>NamedNodeMap</b></a> (represents named node maps)
    <li><a href="#NamedNodeMapRef">Interface <b>NamedNodeMapRef</b></a> (reference to a node map )
    <li><a href="#NodeFilter">Interface <b>NodeFilter</b></a> (DOM 2 Node Filter)
    <li><a href="#NodeIterator">Interface <b>NodeIterator</b></a> (DOM 2 Node Iterator)
    <li><a href="#NodeList">Interface <b>NodeList</b></a> (represents node lists)
    <li><a href="#NodeListRef">Interface <b>NodeListRef</b></a> (reference to a node list)
    <li><a href="#NodeRef">Interface <b>NodeRef</b></a> (reference to generic DOM node)
    <li><a href="#NotationRef">Interface <b>NotationRef</b></a> (reference to Notation nodes)
    <li><a href="#ProcessingInstructionRef">Interface <b>ProcessingInstructionRef</b></a> (reference to PI nodes)
    <li><a href="#Range">Interface <b>Range</b></a> (DOM 2 Range)
    <li><a href="#RangeException">Interface <b>RangeException</b></a> (Exceptions for DOM 2 Range operations)
    <li><a href="#TextRef">Interface <b>TextRef</b></a> (reference to Text nodes)
    <li><a href="#TreeWalker">Interface <b>TreeWalker</b></a> (DOM 2 Tree Walker)
</ul>

<hr noshade size=1><center><h2><a name="functions">Member Function Index</a></h2></center>
<center><table summary="Package 'Dom' function index" cellspacing=0 cellpadding=0>
<tr bgcolor="#9090F0"><th scope=col>Interface<th scope=col>Function<th scope=col>Description</tr>
  <tr>
    <td><tt><a href="#AttrRef">AttrRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::AttrRef::AttrRef">AttrRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#AttrRef">AttrRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::AttrRef::AttrRef_1">AttrRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#AttrRef">AttrRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::AttrRef::getName">getName</a></b>&nbsp;</tt></td>

    <td>Return attribute's name</td>
  </tr>
  <tr>
    <td><tt><a href="#AttrRef">AttrRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::AttrRef::getOwnerElement">getOwnerElement</a></b>&nbsp;</tt></td>

    <td>Return attribute's owning element</td>
  </tr>
  <tr>
    <td><tt><a href="#AttrRef">AttrRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::AttrRef::getSpecified">getSpecified</a></b>&nbsp;</tt></td>

    <td>Return boolean indicating if an attribute was explicitly created</td>
  </tr>
  <tr>
    <td><tt><a href="#AttrRef">AttrRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::AttrRef::getValue">getValue</a></b>&nbsp;</tt></td>

    <td>Return attribute's value</td>
  </tr>
  <tr>
    <td><tt><a href="#AttrRef">AttrRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::AttrRef::setValue">setValue</a></b>&nbsp;</tt></td>

    <td>Set attribute's value</td>
  </tr>
  <tr>
    <td><tt><a href="#CDATASectionRef">CDATASectionRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CDATASectionRef::CDATASectionRef">CDATASectionRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#CDATASectionRef">CDATASectionRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CDATASectionRef::CDATASectionRef_1">CDATASectionRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::appendData">appendData</a></b>&nbsp;</tt></td>

    <td>Append data to end of node's current data</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::deleteData">deleteData</a></b>&nbsp;</tt></td>

    <td>Remove part of node's data</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::freeString">freeString</a></b>&nbsp;</tt></td>

    <td>Deallocate the string allocated by substringData()</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::getData">getData</a></b>&nbsp;</tt></td>

    <td>Return node's data</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::getLength">getLength</a></b>&nbsp;</tt></td>

    <td>Return length of node's data</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::insertData">insertData</a></b>&nbsp;</tt></td>

    <td>Insert string into node's current data</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::replaceData">replaceData</a></b>&nbsp;</tt></td>

    <td>Replace part of node's data</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::setData">setData</a></b>&nbsp;</tt></td>

    <td>Set node's data</td>
  </tr>
  <tr>
    <td><tt><a href="#CharacterDataRef">CharacterDataRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CharacterDataRef::substringData">substringData</a></b>&nbsp;</tt></td>

    <td>Get substring of node's data</td>
  </tr>
  <tr>
    <td><tt><a href="#CommentRef">CommentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CommentRef::CommentRef">CommentRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#CommentRef">CommentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::CommentRef::CommentRef_1">CommentRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMException">DOMException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMException::getCode">getCode</a></b>&nbsp;</tt></td>

    <td>Get Oracle XML error code embedded in the exception </td>
  </tr>
  <tr>
    <td><tt><a href="#DOMException">DOMException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMException::getDOMCode">getDOMCode</a></b>&nbsp;</tt></td>

    <td>Get DOM exception code embedded in the exception </td>
  </tr>
  <tr>
    <td><tt><a href="#DOMException">DOMException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMException::getMesLang">getMesLang</a></b>&nbsp;</tt></td>

    <td>Get current language (encoding) of error messages</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMException">DOMException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMException::getMessage">getMessage</a></b>&nbsp;</tt></td>

    <td>Get Oracle XML error message</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::DOMImplRef">DOMImplRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::DOMImplRef_1">DOMImplRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::DOMImplRef_2">DOMImplRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::createDocument">createDocument</a></b>&nbsp;</tt></td>

    <td>Create document reference</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::createDocumentType">createDocumentType</a></b>&nbsp;</tt></td>

    <td>Create DTD reference</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::getImplementation">getImplementation</a></b>&nbsp;</tt></td>

    <td>Get DOMImplementation object associated with the document</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::getNoMod">getNoMod</a></b>&nbsp;</tt></td>

    <td>Get the 'no modification allowed' flag value</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::hasFeature">hasFeature</a></b>&nbsp;</tt></td>

    <td>Determine if DOM feature is implemented</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::setContext">setContext</a></b>&nbsp;</tt></td>

    <td>Set another context to a node</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplRef">DOMImplRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplRef::~DOMImplRef">~DOMImplRef</a></b>&nbsp;</tt></td>

    <td>Public default destructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplementation">DOMImplementation</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplementation::DOMImplementation">DOMImplementation</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplementation">DOMImplementation</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplementation::getNoMod">getNoMod</a></b>&nbsp;</tt></td>

    <td>Get the 'no modification allowed' flag value</td>
  </tr>
  <tr>
    <td><tt><a href="#DOMImplementation">DOMImplementation</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DOMImplementation::~DOMImplementation">~DOMImplementation</a></b>&nbsp;</tt></td>

    <td>Public default destructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentFragmentRef">DocumentFragmentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentFragmentRef::DocumentFragmentRef">DocumentFragmentRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentFragmentRef">DocumentFragmentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentFragmentRef::DocumentFragmentRef_1">DocumentFragmentRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRange">DocumentRange</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRange::DocumentRange">DocumentRange</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRange">DocumentRange</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRange::createRange">createRange</a></b>&nbsp;</tt></td>

    <td>Create new range object</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRange">DocumentRange</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRange::destroyRange">destroyRange</a></b>&nbsp;</tt></td>

    <td>Destroy range object</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRange">DocumentRange</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRange::~DocumentRange">~DocumentRange</a></b>&nbsp;</tt></td>

    <td>Default destructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::DocumentRef">DocumentRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::DocumentRef_1">DocumentRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createAttribute">createAttribute</a></b>&nbsp;</tt></td>

    <td>Create an attribute node</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createAttributeNS">createAttributeNS</a></b>&nbsp;</tt></td>

    <td>Create an attribute node with namespace information</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createCDATASection">createCDATASection</a></b>&nbsp;</tt></td>

    <td>Create a CDATA node</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createComment">createComment</a></b>&nbsp;</tt></td>

    <td>Create a comment node</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createDocumentFragment">createDocumentFragment</a></b>&nbsp;</tt></td>

    <td>Create a document fragment</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createElement">createElement</a></b>&nbsp;</tt></td>

    <td>Create an element node</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createElementNS">createElementNS</a></b>&nbsp;</tt></td>

    <td>Create an element node with namespace information</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createEntityReference">createEntityReference</a></b>&nbsp;</tt></td>

    <td>Create an entity reference node</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createProcessingInstruction">createProcessingInstruction</a></b>&nbsp;</tt></td>

    <td>Create a processing instruction node</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::createTextNode">createTextNode</a></b>&nbsp;</tt></td>

    <td>Create a text node</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::getDoctype">getDoctype</a></b>&nbsp;</tt></td>

    <td>Get DTD (Document Type) associated with the document</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::getDocumentElement">getDocumentElement</a></b>&nbsp;</tt></td>

    <td>Get top-level element of this document</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::getElementById">getElementById</a></b>&nbsp;</tt></td>

    <td>Get an element given its ID</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::getElementsByTagName">getElementsByTagName</a></b>&nbsp;</tt></td>

    <td>Get elements in the document by tag name</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::getElementsByTagNameNS">getElementsByTagNameNS</a></b>&nbsp;</tt></td>

    <td>Get elements in the document by tag name (namespace aware version)</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::getImplementation">getImplementation</a></b>&nbsp;</tt></td>

    <td>Get DOMImplementation object associated with the document</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentRef">DocumentRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentRef::importNode">importNode</a></b>&nbsp;</tt></td>

    <td>Import a node from another DOM</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTraversal">DocumentTraversal</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTraversal::DocumentTraversal">DocumentTraversal</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTraversal">DocumentTraversal</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTraversal::createNodeIterator">createNodeIterator</a></b>&nbsp;</tt></td>

    <td>Create new iterator object</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTraversal">DocumentTraversal</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTraversal::createTreeWalker">createTreeWalker</a></b>&nbsp;</tt></td>

    <td>Create new tree walker object</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTraversal">DocumentTraversal</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTraversal::destroyNodeIterator">destroyNodeIterator</a></b>&nbsp;</tt></td>

    <td>Destroy node iterator object</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTraversal">DocumentTraversal</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTraversal::destroyTreeWalker">destroyTreeWalker</a></b>&nbsp;</tt></td>

    <td>Destroy tree walker object</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTraversal">DocumentTraversal</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTraversal::~DocumentTraversal">~DocumentTraversal</a></b>&nbsp;</tt></td>

    <td>Default destructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::DocumentTypeRef">DocumentTypeRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::DocumentTypeRef_1">DocumentTypeRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::getEntities">getEntities</a></b>&nbsp;</tt></td>

    <td>Get DTD's entities</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::getInternalSubset">getInternalSubset</a></b>&nbsp;</tt></td>

    <td>Get DTD's internal subset</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::getName">getName</a></b>&nbsp;</tt></td>

    <td>Get name of DTD</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::getNotations">getNotations</a></b>&nbsp;</tt></td>

    <td>Get DTD's notations</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::getPublicId">getPublicId</a></b>&nbsp;</tt></td>

    <td>Get DTD's public ID</td>
  </tr>
  <tr>
    <td><tt><a href="#DocumentTypeRef">DocumentTypeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::DocumentTypeRef::getSystemId">getSystemId</a></b>&nbsp;</tt></td>

    <td>Get DTD's system ID</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::ElementRef">ElementRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::ElementRef_1">ElementRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::getAttribute">getAttribute</a></b>&nbsp;</tt></td>

    <td>Get attribute's value given its name</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::getAttributeNS">getAttributeNS</a></b>&nbsp;</tt></td>

    <td>Get attribute's value given its URI and localname</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::getAttributeNode">getAttributeNode</a></b>&nbsp;</tt></td>

    <td>Get the attribute node given its name</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::getElementsByTagName">getElementsByTagName</a></b>&nbsp;</tt></td>

    <td>Get elements with given tag name</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::getTagName">getTagName</a></b>&nbsp;</tt></td>

    <td>Get element's tag name</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::hasAttribute">hasAttribute</a></b>&nbsp;</tt></td>

    <td>Check if named attribute exist</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::hasAttributeNS">hasAttributeNS</a></b>&nbsp;</tt></td>

    <td>Check if named attribute exist (namespace aware version)</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::removeAttribute">removeAttribute</a></b>&nbsp;</tt></td>

    <td>Remove attribute with specified name</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::removeAttributeNS">removeAttributeNS</a></b>&nbsp;</tt></td>

    <td>Remove attribute with specified URI and local name</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::removeAttributeNode">removeAttributeNode</a></b>&nbsp;</tt></td>

    <td>Remove attribute node</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::setAttribute">setAttribute</a></b>&nbsp;</tt></td>

    <td>Set new attribute for this element and /or new value</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::setAttributeNS">setAttributeNS</a></b>&nbsp;</tt></td>

    <td>Set new attribute for the element and /or new value</td>
  </tr>
  <tr>
    <td><tt><a href="#ElementRef">ElementRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ElementRef::setAttributeNode">setAttributeNode</a></b>&nbsp;</tt></td>

    <td>Set attribute node</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityRef">EntityRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityRef::EntityRef">EntityRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityRef">EntityRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityRef::EntityRef_1">EntityRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityRef">EntityRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityRef::getNotationName">getNotationName</a></b>&nbsp;</tt></td>

    <td>Get entity's notation</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityRef">EntityRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityRef::getPublicId">getPublicId</a></b>&nbsp;</tt></td>

    <td>Get entity's public ID</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityRef">EntityRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityRef::getSystemId">getSystemId</a></b>&nbsp;</tt></td>

    <td>Get entity's system ID</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityRef">EntityRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityRef::getType">getType</a></b>&nbsp;</tt></td>

    <td>Get entity's type</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityReferenceRef">EntityReferenceRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityReferenceRef::EntityReferenceRef">EntityReferenceRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#EntityReferenceRef">EntityReferenceRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::EntityReferenceRef::EntityReferenceRef_1">EntityReferenceRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::NamedNodeMapRef">NamedNodeMapRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::NamedNodeMapRef_1">NamedNodeMapRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::getLength">getLength</a></b>&nbsp;</tt></td>

    <td>Get map's length</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::getNamedItem">getNamedItem</a></b>&nbsp;</tt></td>

    <td>Get item given its name</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::getNamedItemNS">getNamedItemNS</a></b>&nbsp;</tt></td>

    <td>Get item given its namespace URI and local name</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::item">item</a></b>&nbsp;</tt></td>

    <td>Get item given its index</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::removeNamedItem">removeNamedItem</a></b>&nbsp;</tt></td>

    <td>Remove an item given its name</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::removeNamedItemNS">removeNamedItemNS</a></b>&nbsp;</tt></td>

    <td>Remove the item from the map</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::setNamedItem">setNamedItem</a></b>&nbsp;</tt></td>

    <td>Add new item to the map</td>
  </tr>
  <tr>
    <td><tt><a href="#NamedNodeMapRef">NamedNodeMapRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NamedNodeMapRef::setNamedItemNS">setNamedItemNS</a></b>&nbsp;</tt></td>

    <td>Set named item to the map</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeFilter">NodeFilter</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeFilter::acceptNode">acceptNode</a></b>&nbsp;</tt></td>

    <td>Execute it for a given node and use its return value</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeIterator">NodeIterator</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeIterator::adjustCtx">adjustCtx</a></b>&nbsp;</tt></td>

    <td>Attach this iterator to the another context</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeIterator">NodeIterator</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeIterator::detach">detach</a></b>&nbsp;</tt></td>

    <td>invalidate the iterator</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeIterator">NodeIterator</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeIterator::nextNode">nextNode</a></b>&nbsp;</tt></td>

    <td>Go to the next node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeIterator">NodeIterator</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeIterator::previousNode">previousNode</a></b>&nbsp;</tt></td>

    <td>Go to the previous node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeListRef">NodeListRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeListRef::NodeListRef">NodeListRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeListRef">NodeListRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeListRef::NodeListRef_1">NodeListRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeListRef">NodeListRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeListRef::getLength">getLength</a></b>&nbsp;</tt></td>

    <td>Get list's length</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeListRef">NodeListRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeListRef::item">item</a></b>&nbsp;</tt></td>

    <td>Get item given its index</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::NodeRef">NodeRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::NodeRef_1">NodeRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::appendChild">appendChild</a></b>&nbsp;</tt></td>

    <td>Append new child to node's list of children</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::cloneNode">cloneNode</a></b>&nbsp;</tt></td>

    <td>Clone this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getAttributes">getAttributes</a></b>&nbsp;</tt></td>

    <td>Get attributes of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getChildNodes">getChildNodes</a></b>&nbsp;</tt></td>

    <td>Get children of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getFirstChild">getFirstChild</a></b>&nbsp;</tt></td>

    <td>Get the first child node of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getLastChild">getLastChild</a></b>&nbsp;</tt></td>

    <td>Get the last child node of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getLocalName">getLocalName</a></b>&nbsp;</tt></td>

    <td>Get local name of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getNamespaceURI">getNamespaceURI</a></b>&nbsp;</tt></td>

    <td>Get namespace URI of this node as a NULL-terminated string</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getNextSibling">getNextSibling</a></b>&nbsp;</tt></td>

    <td>Get the next sibling node of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getNoMod">getNoMod</a></b>&nbsp;</tt></td>

    <td>Tests if no modifications are allowed for this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getNodeName">getNodeName</a></b>&nbsp;</tt></td>

    <td>Get node's name as NULL-terminated string</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getNodeType">getNodeType</a></b>&nbsp;</tt></td>

    <td>get DOMNodeType of the node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getNodeValue">getNodeValue</a></b>&nbsp;</tt></td>

    <td>Get node's value as NULL-terminated string</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getOwnerDocument">getOwnerDocument</a></b>&nbsp;</tt></td>

    <td>Get the owner document of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getParentNode">getParentNode</a></b>&nbsp;</tt></td>

    <td>Get parent node of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getPrefix">getPrefix</a></b>&nbsp;</tt></td>

    <td>Get namespace prefix of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::getPreviousSibling">getPreviousSibling</a></b>&nbsp;</tt></td>

    <td>Get the previous sibling node of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::hasAttributes">hasAttributes</a></b>&nbsp;</tt></td>

    <td>Tests if this node has attributes</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::hasChildNodes">hasChildNodes</a></b>&nbsp;</tt></td>

    <td>Test if this node has children</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::insertBefore">insertBefore</a></b>&nbsp;</tt></td>

    <td>Insert new child into node's list of children</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::isSupported">isSupported</a></b>&nbsp;</tt></td>

    <td>Tests if specified feature is supported by the implementation</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::markToDelete">markToDelete</a></b>&nbsp;</tt></td>

    <td>Sets the mark to delete the referenced node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::normalize">normalize</a></b>&nbsp;</tt></td>

    <td>Merge adjacent text nodes</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::removeChild">removeChild</a></b>&nbsp;</tt></td>

    <td>Remove an existing child node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::replaceChild">replaceChild</a></b>&nbsp;</tt></td>

    <td>Replace an existing child of a node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::resetNode">resetNode</a></b>&nbsp;</tt></td>

    <td>Reset NodeRef to reference another node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::setNodeValue">setNodeValue</a></b>&nbsp;</tt></td>

    <td>Set node's value as NULL-terminated string</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::setPrefix">setPrefix</a></b>&nbsp;</tt></td>

    <td>Set namespace prefix of this node</td>
  </tr>
  <tr>
    <td><tt><a href="#NodeRef">NodeRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NodeRef::~NodeRef">~NodeRef</a></b>&nbsp;</tt></td>

    <td>Public default destructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NotationRef">NotationRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NotationRef::NotationRef">NotationRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NotationRef">NotationRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NotationRef::NotationRef_1">NotationRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#NotationRef">NotationRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NotationRef::getPublicId">getPublicId</a></b>&nbsp;</tt></td>

    <td>Get publicId</td>
  </tr>
  <tr>
    <td><tt><a href="#NotationRef">NotationRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::NotationRef::getSystemId">getSystemId</a></b>&nbsp;</tt></td>

    <td>Get systemId</td>
  </tr>
  <tr>
    <td><tt><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ProcessingInstructionRef::ProcessingInstructionRef">ProcessingInstructionRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ProcessingInstructionRef::ProcessingInstructionRef_1">ProcessingInstructionRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ProcessingInstructionRef::getData">getData</a></b>&nbsp;</tt></td>

    <td>Get processing instruction's data</td>
  </tr>
  <tr>
    <td><tt><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ProcessingInstructionRef::getTarget">getTarget</a></b>&nbsp;</tt></td>

    <td>Get processing instruction's target</td>
  </tr>
  <tr>
    <td><tt><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::ProcessingInstructionRef::setData">setData</a></b>&nbsp;</tt></td>

    <td>Set processing instruction's data</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::CompareBoundaryPoints">CompareBoundaryPoints</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::cloneContent">cloneContent</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::cloneRange">cloneRange</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::deleteContents">deleteContents</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::detach">detach</a></b>&nbsp;</tt></td>

    <td>invalidate the range</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::extractContent">extractContent</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::getCollapsed">getCollapsed</a></b>&nbsp;</tt></td>

    <td>Check if the range is collapsed</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::getCommonAncestorContainer">getCommonAncestorContainer</a></b>&nbsp;</tt></td>

    <td>Get the deepest common ancestor node</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::getEndContainer">getEndContainer</a></b>&nbsp;</tt></td>

    <td>Get end container node</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::getEndOffset">getEndOffset</a></b>&nbsp;</tt></td>

    <td>Get offset of the end point</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::getStartContainer">getStartContainer</a></b>&nbsp;</tt></td>

    <td>Get start container node</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::getStartOffset">getStartOffset</a></b>&nbsp;</tt></td>

    <td>Get offset of the start point</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::insertNode">insertNode</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::select">select</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::selectNode">selectNode</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::setEnd">setEnd</a></b>&nbsp;</tt></td>

    <td>Set end point</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::setEndAfter">setEndAfter</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::setEndBefore">setEndBefore</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::setStart">setStart</a></b>&nbsp;</tt></td>

    <td>Set start point</td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::setStartAfter">setStartAfter</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::setStartBefore">setStartBefore</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::surroundContent">surroundContent</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#Range">Range</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::Range::toString">toString</a></b>&nbsp;</tt></td>

    <td></td>
  </tr>
  <tr>
    <td><tt><a href="#RangeException">RangeException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::RangeException::getCode">getCode</a></b>&nbsp;</tt></td>

    <td>Get Oracle XML error code embedded in the exception </td>
  </tr>
  <tr>
    <td><tt><a href="#RangeException">RangeException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::RangeException::getMesLang">getMesLang</a></b>&nbsp;</tt></td>

    <td>Get current language (encoding) of error messages</td>
  </tr>
  <tr>
    <td><tt><a href="#RangeException">RangeException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::RangeException::getMessage">getMessage</a></b>&nbsp;</tt></td>

    <td>Get Oracle XML error message</td>
  </tr>
  <tr>
    <td><tt><a href="#RangeException">RangeException</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::RangeException::getRangeCode">getRangeCode</a></b>&nbsp;</tt></td>

    <td>Get Range exception code embedded in the exception </td>
  </tr>
  <tr>
    <td><tt><a href="#TextRef">TextRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TextRef::TextRef">TextRef</a></b>&nbsp;</tt></td>

    <td>Constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#TextRef">TextRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TextRef::TextRef_1">TextRef</a></b>&nbsp;</tt></td>

    <td>Copy constructor</td>
  </tr>
  <tr>
    <td><tt><a href="#TextRef">TextRef</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TextRef::splitText">splitText</a></b>&nbsp;</tt></td>

    <td>Split text node into two</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::adjustCtx">adjustCtx</a></b>&nbsp;</tt></td>

    <td>Attach this tree walker to the another context</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::firstChild">firstChild</a></b>&nbsp;</tt></td>

    <td>Get the first child of the current node</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::lastChild">lastChild</a></b>&nbsp;</tt></td>

    <td>Get the last child of the current node</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::nextNode">nextNode</a></b>&nbsp;</tt></td>

    <td>Get the next node</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::nextSibling">nextSibling</a></b>&nbsp;</tt></td>

    <td>Get the next sibling node</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::parentNode">parentNode</a></b>&nbsp;</tt></td>

    <td>Get the parent of the current node</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::previousNode">previousNode</a></b>&nbsp;</tt></td>

    <td>Get the previous node</td>
  </tr>
  <tr>
    <td><tt><a href="#TreeWalker">TreeWalker</a>&nbsp;</tt></td>
    <td><tt><b><a href="#Dom::TreeWalker::previousSibling">previousSibling</a></b>&nbsp;</tt></td>

    <td>Get the previous sibling node</td>
  </tr>
</table></center>

<br><hr noshade size=1><center><h2><a name="AttrRef">Interface AttrRef</a> (reference to Attribute nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'AttrRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::AttrRef::AttrRef"><b>AttrRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::AttrRef::AttrRef_1"><b>AttrRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::AttrRef::getName"><b>getName</b></a></td>
	       <td>Return attribute's name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::AttrRef::getOwnerElement"><b>getOwnerElement</b></a></td>
	       <td>Return attribute's owning element</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::AttrRef::getSpecified"><b>getSpecified</b></a></td>
	       <td>Return boolean indicating if an attribute was explicitly created</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::AttrRef::getValue"><b>getValue</b></a></td>
	       <td>Return attribute's value</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::AttrRef::setValue"><b>setValue</b></a></td>
	       <td>Set attribute's value</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="CDATASectionRef">Interface CDATASectionRef</a> (reference to CDATASection nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'CDATASectionRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::CDATASectionRef::CDATASectionRef"><b>CDATASectionRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CDATASectionRef::CDATASectionRef_1"><b>CDATASectionRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="CharacterDataRef">Interface CharacterDataRef</a></h2></center>
<p>
    This interface does not have a corresponding node kind. It just
    introduces some common functionality for Text, Comment, and PI
    nodes.
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'CharacterDataRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::appendData"><b>appendData</b></a></td>
	       <td>Append data to end of node's current data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::deleteData"><b>deleteData</b></a></td>
	       <td>Remove part of node's data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::freeString"><b>freeString</b></a></td>
	       <td>Deallocate the string allocated by substringData()</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::getData"><b>getData</b></a></td>
	       <td>Return node's data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::getLength"><b>getLength</b></a></td>
	       <td>Return length of node's data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::insertData"><b>insertData</b></a></td>
	       <td>Insert string into node's current data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::replaceData"><b>replaceData</b></a></td>
	       <td>Replace part of node's data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::setData"><b>setData</b></a></td>
	       <td>Set node's data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CharacterDataRef::substringData"><b>substringData</b></a></td>
	       <td>Get substring of node's data</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="CommentRef">Interface CommentRef</a> (reference to Comment nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'CommentRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::CommentRef::CommentRef"><b>CommentRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::CommentRef::CommentRef_1"><b>CommentRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DOMException">Interface DOMException</a> (Exception class for DOM operations)</h2></center>
<p>
    DOM operations raise exceptions only when an operation is impossible
    to perform for DOM logic related reasons. Implementations might
    need to handle a wider range of error conditions. In these cases
    inherited XMLException functionality can be used.<p><p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DOMException' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DOMException::getCode"><b>getCode</b></a></td>
	       <td>Get Oracle XML error code embedded in the exception </td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMException::getDOMCode"><b>getDOMCode</b></a></td>
	       <td>Get DOM exception code embedded in the exception </td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMException::getMesLang"><b>getMesLang</b></a></td>
	       <td>Get current language (encoding) of error messages</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMException::getMessage"><b>getMessage</b></a></td>
	       <td>Get Oracle XML error message</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DOMImplRef">Interface DOMImplRef</a> (reference to DOMImplementation)</h2></center>
<p>
    DOMImplRef is explicitly bound to a particular context. It
    provides access to all standard DOMImplementation functionality
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DOMImplRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::DOMImplRef"><b>DOMImplRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::DOMImplRef_1"><b>DOMImplRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::DOMImplRef_2"><b>DOMImplRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::createDocument"><b>createDocument</b></a></td>
	       <td>Create document reference</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::createDocumentType"><b>createDocumentType</b></a></td>
	       <td>Create DTD reference</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::getImplementation"><b>getImplementation</b></a></td>
	       <td>Get DOMImplementation object associated with the document</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::getNoMod"><b>getNoMod</b></a></td>
	       <td>Get the 'no modification allowed' flag value</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::hasFeature"><b>hasFeature</b></a></td>
	       <td>Determine if DOM feature is implemented</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::setContext"><b>setContext</b></a></td>
	       <td>Set another context to a node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplRef::~DOMImplRef"><b>~DOMImplRef</b></a></td>
	       <td>Public default destructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DOMImplementation">Interface DOMImplementation</a> (handles DOM trees)</h2></center>
<p>
    DOMImplementation - is fundamental for manipulating DOM trees.
    Every DOM tree is attached to a particular DOM implementation object.
    Several DOM trees can be attached to the same DOM implementation
    object. Each DOM tree can be deleted and deallocated by deleting
    the document object. All DOM trees attached to a particular DOM
    implementation object are deleted when this object is deleted.
    DOMImplementation object is visible to the user directly. The
    user explicitly creates and deletes DOMIMplementation objects.
    However, the functionality of DOMImplementation is available
    through DOMImplRef objects only.<p><p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DOMImplementation' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DOMImplementation::DOMImplementation"><b>DOMImplementation</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplementation::getNoMod"><b>getNoMod</b></a></td>
	       <td>Get the 'no modification allowed' flag value</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DOMImplementation::~DOMImplementation"><b>~DOMImplementation</b></a></td>
	       <td>Public default destructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DocumentFragmentRef">Interface DocumentFragmentRef</a> (reference to Fragment nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DocumentFragmentRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DocumentFragmentRef::DocumentFragmentRef"><b>DocumentFragmentRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentFragmentRef::DocumentFragmentRef_1"><b>DocumentFragmentRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DocumentRange">Interface DocumentRange</a> (DOM 2 interface)</h2></center>
<p>
    This is an interface to the factory producing Range objects. It
    keeps track of all objects that it created and destructs them when
    itself is destructed.
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DocumentRange' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DocumentRange::DocumentRange"><b>DocumentRange</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRange::createRange"><b>createRange</b></a></td>
	       <td>Create new range object</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRange::destroyRange"><b>destroyRange</b></a></td>
	       <td>Destroy range object</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRange::~DocumentRange"><b>~DocumentRange</b></a></td>
	       <td>Default destructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DocumentRef">Interface DocumentRef</a> (reference to Document nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DocumentRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::DocumentRef"><b>DocumentRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::DocumentRef_1"><b>DocumentRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createAttribute"><b>createAttribute</b></a></td>
	       <td>Create an attribute node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createAttributeNS"><b>createAttributeNS</b></a></td>
	       <td>Create an attribute node with namespace information</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createCDATASection"><b>createCDATASection</b></a></td>
	       <td>Create a CDATA node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createComment"><b>createComment</b></a></td>
	       <td>Create a comment node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createDocumentFragment"><b>createDocumentFragment</b></a></td>
	       <td>Create a document fragment</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createElement"><b>createElement</b></a></td>
	       <td>Create an element node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createElementNS"><b>createElementNS</b></a></td>
	       <td>Create an element node with namespace information</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createEntityReference"><b>createEntityReference</b></a></td>
	       <td>Create an entity reference node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createProcessingInstruction"><b>createProcessingInstruction</b></a></td>
	       <td>Create a processing instruction node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::createTextNode"><b>createTextNode</b></a></td>
	       <td>Create a text node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::getDoctype"><b>getDoctype</b></a></td>
	       <td>Get DTD (Document Type) associated with the document</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::getDocumentElement"><b>getDocumentElement</b></a></td>
	       <td>Get top-level element of this document</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::getElementById"><b>getElementById</b></a></td>
	       <td>Get an element given its ID</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::getElementsByTagName"><b>getElementsByTagName</b></a></td>
	       <td>Get elements in the document by tag name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::getElementsByTagNameNS"><b>getElementsByTagNameNS</b></a></td>
	       <td>Get elements in the document by tag name (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::getImplementation"><b>getImplementation</b></a></td>
	       <td>Get DOMImplementation object associated with the document</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentRef::importNode"><b>importNode</b></a></td>
	       <td>Import a node from another DOM</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DocumentTraversal">Interface DocumentTraversal</a> (DOM 2 interface)</h2></center>
<p>
    This is an interface to the factory producing NodeIterator
    and TreeWalker objects. It keeps track of all objects that
    it created and destructs them when itself is destructed.
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DocumentTraversal' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DocumentTraversal::DocumentTraversal"><b>DocumentTraversal</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTraversal::createNodeIterator"><b>createNodeIterator</b></a></td>
	       <td>Create new iterator object</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTraversal::createTreeWalker"><b>createTreeWalker</b></a></td>
	       <td>Create new tree walker object</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTraversal::destroyNodeIterator"><b>destroyNodeIterator</b></a></td>
	       <td>Destroy node iterator object</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTraversal::destroyTreeWalker"><b>destroyTreeWalker</b></a></td>
	       <td>Destroy tree walker object</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTraversal::~DocumentTraversal"><b>~DocumentTraversal</b></a></td>
	       <td>Default destructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="DocumentTypeRef">Interface DocumentTypeRef</a> (reference to DTD nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'DocumentTypeRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::DocumentTypeRef"><b>DocumentTypeRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::DocumentTypeRef_1"><b>DocumentTypeRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::getEntities"><b>getEntities</b></a></td>
	       <td>Get DTD's entities</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::getInternalSubset"><b>getInternalSubset</b></a></td>
	       <td>Get DTD's internal subset</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::getName"><b>getName</b></a></td>
	       <td>Get name of DTD</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::getNotations"><b>getNotations</b></a></td>
	       <td>Get DTD's notations</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::getPublicId"><b>getPublicId</b></a></td>
	       <td>Get DTD's public ID</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::DocumentTypeRef::getSystemId"><b>getSystemId</b></a></td>
	       <td>Get DTD's system ID</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="ElementRef">Interface ElementRef</a> (reference to Element nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'ElementRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::ElementRef"><b>ElementRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::ElementRef_1"><b>ElementRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::getAttribute"><b>getAttribute</b></a></td>
	       <td>Get attribute's value given its name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::getAttributeNS"><b>getAttributeNS</b></a></td>
	       <td>Get attribute's value given its URI and localname</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::getAttributeNode"><b>getAttributeNode</b></a></td>
	       <td>Get the attribute node given its name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::getElementsByTagName"><b>getElementsByTagName</b></a></td>
	       <td>Get elements with given tag name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::getTagName"><b>getTagName</b></a></td>
	       <td>Get element's tag name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::hasAttribute"><b>hasAttribute</b></a></td>
	       <td>Check if named attribute exist</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::hasAttributeNS"><b>hasAttributeNS</b></a></td>
	       <td>Check if named attribute exist (namespace aware version)</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::removeAttribute"><b>removeAttribute</b></a></td>
	       <td>Remove attribute with specified name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::removeAttributeNS"><b>removeAttributeNS</b></a></td>
	       <td>Remove attribute with specified URI and local name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::removeAttributeNode"><b>removeAttributeNode</b></a></td>
	       <td>Remove attribute node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::setAttribute"><b>setAttribute</b></a></td>
	       <td>Set new attribute for this element and /or new value</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::setAttributeNS"><b>setAttributeNS</b></a></td>
	       <td>Set new attribute for the element and /or new value</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ElementRef::setAttributeNode"><b>setAttributeNode</b></a></td>
	       <td>Set attribute node</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="EntityRef">Interface EntityRef</a> (reference to Entity nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'EntityRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::EntityRef::EntityRef"><b>EntityRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::EntityRef::EntityRef_1"><b>EntityRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::EntityRef::getNotationName"><b>getNotationName</b></a></td>
	       <td>Get entity's notation</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::EntityRef::getPublicId"><b>getPublicId</b></a></td>
	       <td>Get entity's public ID</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::EntityRef::getSystemId"><b>getSystemId</b></a></td>
	       <td>Get entity's system ID</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::EntityRef::getType"><b>getType</b></a></td>
	       <td>Get entity's type</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="EntityReferenceRef">Interface EntityReferenceRef</a> (reference to EntityReference nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'EntityReferenceRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::EntityReferenceRef::EntityReferenceRef"><b>EntityReferenceRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::EntityReferenceRef::EntityReferenceRef_1"><b>EntityReferenceRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NamedNodeMap">Interface NamedNodeMap</a> (represents named node maps)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NamedNodeMap' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NamedNodeMapRef">Interface NamedNodeMapRef</a> (reference to a node map )</h2></center>
<p>
    The node map referenced can be marked for deletion by the
    implementation and, then, is deleted when the destructor
    of this class is called
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NamedNodeMapRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::NamedNodeMapRef"><b>NamedNodeMapRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::NamedNodeMapRef_1"><b>NamedNodeMapRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::getLength"><b>getLength</b></a></td>
	       <td>Get map's length</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::getNamedItem"><b>getNamedItem</b></a></td>
	       <td>Get item given its name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::getNamedItemNS"><b>getNamedItemNS</b></a></td>
	       <td>Get item given its namespace URI and local name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::item"><b>item</b></a></td>
	       <td>Get item given its index</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::removeNamedItem"><b>removeNamedItem</b></a></td>
	       <td>Remove an item given its name</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::removeNamedItemNS"><b>removeNamedItemNS</b></a></td>
	       <td>Remove the item from the map</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::setNamedItem"><b>setNamedItem</b></a></td>
	       <td>Add new item to the map</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NamedNodeMapRef::setNamedItemNS"><b>setNamedItemNS</b></a></td>
	       <td>Set named item to the map</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NodeFilter">Interface NodeFilter</a> (DOM 2 Node Filter)</h2></center>
<p>
    NodeFilter implementations are provided by users.<p><p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NodeFilter' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::NodeFilter::acceptNode"><b>acceptNode</b></a></td>
	       <td>Execute it for a given node and use its return value</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NodeIterator">Interface NodeIterator</a> (DOM 2 Node Iterator)</h2></center>
<p>
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NodeIterator' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::NodeIterator::adjustCtx"><b>adjustCtx</b></a></td>
	       <td>Attach this iterator to the another context</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeIterator::detach"><b>detach</b></a></td>
	       <td>invalidate the iterator</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeIterator::nextNode"><b>nextNode</b></a></td>
	       <td>Go to the next node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeIterator::previousNode"><b>previousNode</b></a></td>
	       <td>Go to the previous node</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NodeList">Interface NodeList</a> (represents node lists)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NodeList' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NodeListRef">Interface NodeListRef</a> (reference to a node list)</h2></center>
<p>
    The node list referenced can be marked for deletion by the
    implementation and, then, is deleted when the destructor of this 
    class is called
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NodeListRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::NodeListRef::NodeListRef"><b>NodeListRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeListRef::NodeListRef_1"><b>NodeListRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeListRef::getLength"><b>getLength</b></a></td>
	       <td>Get list's length</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeListRef::item"><b>item</b></a></td>
	       <td>Get item given its index</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NodeRef">Interface NodeRef</a> (reference to generic DOM node)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NodeRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::NodeRef"><b>NodeRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::NodeRef_1"><b>NodeRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::appendChild"><b>appendChild</b></a></td>
	       <td>Append new child to node's list of children</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::cloneNode"><b>cloneNode</b></a></td>
	       <td>Clone this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getAttributes"><b>getAttributes</b></a></td>
	       <td>Get attributes of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getChildNodes"><b>getChildNodes</b></a></td>
	       <td>Get children of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getFirstChild"><b>getFirstChild</b></a></td>
	       <td>Get the first child node of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getLastChild"><b>getLastChild</b></a></td>
	       <td>Get the last child node of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getLocalName"><b>getLocalName</b></a></td>
	       <td>Get local name of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getNamespaceURI"><b>getNamespaceURI</b></a></td>
	       <td>Get namespace URI of this node as a NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getNextSibling"><b>getNextSibling</b></a></td>
	       <td>Get the next sibling node of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getNoMod"><b>getNoMod</b></a></td>
	       <td>Tests if no modifications are allowed for this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getNodeName"><b>getNodeName</b></a></td>
	       <td>Get node's name as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getNodeType"><b>getNodeType</b></a></td>
	       <td>get DOMNodeType of the node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getNodeValue"><b>getNodeValue</b></a></td>
	       <td>Get node's value as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getOwnerDocument"><b>getOwnerDocument</b></a></td>
	       <td>Get the owner document of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getParentNode"><b>getParentNode</b></a></td>
	       <td>Get parent node of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getPrefix"><b>getPrefix</b></a></td>
	       <td>Get namespace prefix of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::getPreviousSibling"><b>getPreviousSibling</b></a></td>
	       <td>Get the previous sibling node of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::hasAttributes"><b>hasAttributes</b></a></td>
	       <td>Tests if this node has attributes</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::hasChildNodes"><b>hasChildNodes</b></a></td>
	       <td>Test if this node has children</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::insertBefore"><b>insertBefore</b></a></td>
	       <td>Insert new child into node's list of children</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::isSupported"><b>isSupported</b></a></td>
	       <td>Tests if specified feature is supported by the implementation</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::markToDelete"><b>markToDelete</b></a></td>
	       <td>Sets the mark to delete the referenced node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::normalize"><b>normalize</b></a></td>
	       <td>Merge adjacent text nodes</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::removeChild"><b>removeChild</b></a></td>
	       <td>Remove an existing child node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::replaceChild"><b>replaceChild</b></a></td>
	       <td>Replace an existing child of a node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::resetNode"><b>resetNode</b></a></td>
	       <td>Reset NodeRef to reference another node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::setNodeValue"><b>setNodeValue</b></a></td>
	       <td>Set node's value as NULL-terminated string</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::setPrefix"><b>setPrefix</b></a></td>
	       <td>Set namespace prefix of this node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NodeRef::~NodeRef"><b>~NodeRef</b></a></td>
	       <td>Public default destructor</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="NotationRef">Interface NotationRef</a> (reference to Notation nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'NotationRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::NotationRef::NotationRef"><b>NotationRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NotationRef::NotationRef_1"><b>NotationRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NotationRef::getPublicId"><b>getPublicId</b></a></td>
	       <td>Get publicId</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::NotationRef::getSystemId"><b>getSystemId</b></a></td>
	       <td>Get systemId</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="ProcessingInstructionRef">Interface ProcessingInstructionRef</a> (reference to PI nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'ProcessingInstructionRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::ProcessingInstructionRef::ProcessingInstructionRef"><b>ProcessingInstructionRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ProcessingInstructionRef::ProcessingInstructionRef_1"><b>ProcessingInstructionRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ProcessingInstructionRef::getData"><b>getData</b></a></td>
	       <td>Get processing instruction's data</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ProcessingInstructionRef::getTarget"><b>getTarget</b></a></td>
	       <td>Get processing instruction's target</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::ProcessingInstructionRef::setData"><b>setData</b></a></td>
	       <td>Set processing instruction's data</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="Range">Interface Range</a> (DOM 2 Range)</h2></center>
<p>
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'Range' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::Range::CompareBoundaryPoints"><b>CompareBoundaryPoints</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::cloneContent"><b>cloneContent</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::cloneRange"><b>cloneRange</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::deleteContents"><b>deleteContents</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::detach"><b>detach</b></a></td>
	       <td>invalidate the range</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::extractContent"><b>extractContent</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::getCollapsed"><b>getCollapsed</b></a></td>
	       <td>Check if the range is collapsed</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::getCommonAncestorContainer"><b>getCommonAncestorContainer</b></a></td>
	       <td>Get the deepest common ancestor node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::getEndContainer"><b>getEndContainer</b></a></td>
	       <td>Get end container node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::getEndOffset"><b>getEndOffset</b></a></td>
	       <td>Get offset of the end point</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::getStartContainer"><b>getStartContainer</b></a></td>
	       <td>Get start container node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::getStartOffset"><b>getStartOffset</b></a></td>
	       <td>Get offset of the start point</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::insertNode"><b>insertNode</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::select"><b>select</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::selectNode"><b>selectNode</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::setEnd"><b>setEnd</b></a></td>
	       <td>Set end point</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::setEndAfter"><b>setEndAfter</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::setEndBefore"><b>setEndBefore</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::setStart"><b>setStart</b></a></td>
	       <td>Set start point</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::setStartAfter"><b>setStartAfter</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::setStartBefore"><b>setStartBefore</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::surroundContent"><b>surroundContent</b></a></td>
	       <td></td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::Range::toString"><b>toString</b></a></td>
	       <td></td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="RangeException">Interface RangeException</a> (Exceptions for DOM 2 Range operations)</h2></center>
<p>
    Range operations raise exceptions only when an operation is
    impossible to perform for Range logic related reasons.
    Implementations might need to handle a wider range of error
    conditions. In these cases inherited XMLException functionality
    can be used.<p><p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'RangeException' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::RangeException::getCode"><b>getCode</b></a></td>
	       <td>Get Oracle XML error code embedded in the exception </td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::RangeException::getMesLang"><b>getMesLang</b></a></td>
	       <td>Get current language (encoding) of error messages</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::RangeException::getMessage"><b>getMessage</b></a></td>
	       <td>Get Oracle XML error message</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::RangeException::getRangeCode"><b>getRangeCode</b></a></td>
	       <td>Get Range exception code embedded in the exception </td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="TextRef">Interface TextRef</a> (reference to Text nodes)</h2></center>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'TextRef' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::TextRef::TextRef"><b>TextRef</b></a></td>
	       <td>Constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TextRef::TextRef_1"><b>TextRef</b></a></td>
	       <td>Copy constructor</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TextRef::splitText"><b>splitText</b></a></td>
	       <td>Split text node into two</td>
	       </tr>
	   </table></center>

<br><hr noshade size=1><center><h2><a name="TreeWalker">Interface TreeWalker</a> (DOM 2 Tree Walker)</h2></center>
<p>
<p>
	   <center><h3>Member Function Index</h3>
<table summary="Interface 'TreeWalker' function index" cellspacing=0 cellpadding=2>
<tr bgcolor="#9090F0"><th scope=col>Function<th scope=col>Description</tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::adjustCtx"><b>adjustCtx</b></a></td>
	       <td>Attach this tree walker to the another context</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::firstChild"><b>firstChild</b></a></td>
	       <td>Get the first child of the current node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::lastChild"><b>lastChild</b></a></td>
	       <td>Get the last child of the current node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::nextNode"><b>nextNode</b></a></td>
	       <td>Get the next node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::nextSibling"><b>nextSibling</b></a></td>
	       <td>Get the next sibling node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::parentNode"><b>parentNode</b></a></td>
	       <td>Get the parent of the current node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::previousNode"><b>previousNode</b></a></td>
	       <td>Get the previous node</td>
	       </tr>
	       <tr>
	       <td><a href="#Dom::TreeWalker::previousSibling"><b>previousSibling</b></a></td>
	       <td>Get the previous sibling node</td>
	       </tr>
	   </table></center>
<hr noshade size=1>

<h2 align=center><a name="Dom::AttrRef::AttrRef">AttrRef</a></h2>

<table summary="Function 'Dom::AttrRef::AttrRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>AttrRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#AttrRef">AttrRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;AttrRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::AttrRef::AttrRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(AttrRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given attribute node after a call to createAttribute.<p>
</tr>
</table>

<h2 align=center><a name="Dom::AttrRef::AttrRef_1">AttrRef</a></h2>

<table summary="Function 'Dom::AttrRef::AttrRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>AttrRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#AttrRef">AttrRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;AttrRef(&nbsp;const&nbsp;AttrRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::AttrRef::AttrRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(AttrRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::AttrRef::getName">getName</a></h2>

<table summary="Function 'Dom::AttrRef::getName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#AttrRef">AttrRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getName()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> name of attribute</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the fully-qualified name of an attribute (in the data
        encoding) as a NULL-terminated string.<p>
</tr>
</table>

<h2 align=center><a name="Dom::AttrRef::getOwnerElement">getOwnerElement</a></h2>

<table summary="Function 'Dom::AttrRef::getOwnerElement' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getOwnerElement</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#AttrRef">AttrRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's owning element</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getOwnerElement();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> attribute's owning element node.</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns attribute's owning element<p>
</tr>
</table>

<h2 align=center><a name="Dom::AttrRef::getSpecified">getSpecified</a></h2>

<table summary="Function 'Dom::AttrRef::getSpecified' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getSpecified</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#AttrRef">AttrRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return boolean indicating if an attribute was explicitly created</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;getSpecified()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> attribute's "specified" value</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the 'specified' value for an attribute. If the attribute
	was explicitly given a value in the original document, it is
	TRUE; otherwise, it is FALSE.  If the node is not an attribute,
	returns FALSE.  If the user sets attribute's value through DOM,
	its 'specified' value will be TRUE.<p>
</tr>
</table>

<h2 align=center><a name="Dom::AttrRef::getValue">getValue</a></h2>

<table summary="Function 'Dom::AttrRef::getValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#AttrRef">AttrRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return attribute's value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getValue()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> attribute's value</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the "value" (character data) of an attribute (in the
	data encoding) as NULL-terminated string.  Character and general
	entities will have been replaced.<p>
</tr>
</table>

<h2 align=center><a name="Dom::AttrRef::setValue">setValue</a></h2>

<table summary="Function 'Dom::AttrRef::setValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#AttrRef">AttrRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set attribute's value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setValue(&nbsp;oratext*&nbsp;data)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::AttrRef::setValue' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new value of attribute</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the given attribute's value to data. The new value must be
	in the data encoding. It is not verified, converted, or checked.
	The attribute's 'specified' flag will be TRUE after setting a new
	value.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CDATASectionRef::CDATASectionRef">CDATASectionRef</a></h2>

<table summary="Function 'Dom::CDATASectionRef::CDATASectionRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>CDATASectionRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CDATASectionRef">CDATASectionRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;CDATASectionRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CDATASectionRef::CDATASectionRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> CDATASection node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(CDATASectionRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given CDATA node after a call to createCDATASection.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CDATASectionRef::CDATASectionRef_1">CDATASectionRef</a></h2>

<table summary="Function 'Dom::CDATASectionRef::CDATASectionRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>CDATASectionRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CDATASectionRef">CDATASectionRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;CDATASectionRef(&nbsp;const&nbsp;CDATASectionRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CDATASectionRef::CDATASectionRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(CDATASectionRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::appendData">appendData</a></h2>

<table summary="Function 'Dom::CharacterDataRef::appendData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>appendData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Append data to end of node's current data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;appendData(&nbsp;oratext*&nbsp;data)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CharacterDataRef::appendData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> data to append</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Append a string to the end of a CharacterData node's data. The
	appended data should be in the data encoding.  It will not be
	verified, converted, or checked.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::deleteData">deleteData</a></h2>

<table summary="Function 'Dom::CharacterDataRef::deleteData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>deleteData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove part of node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;deleteData(&nbsp;ub4&nbsp;offset,&nbsp;ub4&nbsp;count)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CharacterDataRef::deleteData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  character offset from which to start removing</td></tr>
<tr><td scope=row><tt>count</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  number of characters to delete</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Remove a range of characters from a CharacterData node's data.
        The offset is zero-based, so offset zero refers to the start of
	the data. Both offset and count are in characters, not bytes.
	If the sum of offset and count exceeds the data length then all
	characters from offset to the end of the data are deleted.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::freeString">freeString</a></h2>

<table summary="Function 'Dom::CharacterDataRef::freeString' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>freeString</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Deallocate the string allocated by substringData()</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;freeString(&nbsp;oratext*&nbsp;str);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CharacterDataRef::freeString' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>str</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> string to free</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Deallocates the string allocated by substringData(). It is
	Oracle's extension.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::getData">getData</a></h2>

<table summary="Function 'Dom::CharacterDataRef::getData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getData()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> node's data</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the data for a CharacterData node (type text, comment or
        CDATA) in the data encoding.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::getLength">getLength</a></h2>

<table summary="Function 'Dom::CharacterDataRef::getLength' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getLength</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Return length of node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;ub4&nbsp;getLength()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> length in characters (not bytes!) of node's data</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the length of the data for a CharacterData node (type
	text, comment or CDATA) in characters (not bytes!).<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::insertData">insertData</a></h2>

<table summary="Function 'Dom::CharacterDataRef::insertData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>insertData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Insert string into node's current data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;insertData(&nbsp;ub4&nbsp;offset,&nbsp;oratext*&nbsp;data)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CharacterDataRef::insertData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  character offset at which to insert</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  data to insert</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Insert a string into a CharacterData node's data at the specified
        position. The inserted data must be in the data encoding.
	It will not be verified, converted, or checked. The offset
        is specified as characters, not bytes.  The offset is zero-based,
        so inserting at offset zero prepends the data.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::replaceData">replaceData</a></h2>

<table summary="Function 'Dom::CharacterDataRef::replaceData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>replaceData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Replace part of node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;replaceData(&nbsp;ub4&nbsp;offset,&nbsp;ub4&nbsp;count,&nbsp;oratext*&nbsp;data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CharacterDataRef::replaceData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  character offset from which to start replacing</td></tr>
<tr><td scope=row><tt>count</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  number of characters to replace</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  replacement substring [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        </tr>
<tr><th scope=row><i>Description</i>
<td>        Replaces a range of characters in a CharacterData node's data
	with a new string. The offset is zero-based, so offset zero
	refers to the start of the data.  The replacement data must be
	in the data encoding.  It will not be verified, converted, or
	checked. The offset and count are both in characters, not bytes.
	If the sum of offset and count exceeds length, then all
	characters to the end of the data are replaced.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::setData">setData</a></h2>

<table summary="Function 'Dom::CharacterDataRef::setData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setData(&nbsp;oratext*&nbsp;data)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CharacterDataRef::setData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new node's data</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets data for a CharacterData node (type text, comment or CDATA),
        replacing the old data. The new data is not verified, converted,
	or checked -- it should be in the data encoding.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CharacterDataRef::substringData">substringData</a></h2>

<table summary="Function 'Dom::CharacterDataRef::substringData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>substringData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CharacterDataRef">CharacterDataRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get substring of node's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;substringData(&nbsp;ub4&nbsp;offset,&nbsp;ub4&nbsp;count)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CharacterDataRef::substringData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> start offset of substring to extract</td></tr>
<tr><td scope=row><tt>count</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> number of characters to extract</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> specified substring</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a range of character data from a CharacterData node
	(type text, comment or CDATA). Since the data is in the data
	encoding, offset and count are in characters, not bytes.  The
	beginning of the string is offset 0.  If the sum of offset and
	count exceeds the length, then all characters to the end of the
	data are returned. The substring is permanently allocated in the
	context managed memory and should be explicitly deallocated by
	freeString().<p>
</tr>
</table>

<h2 align=center><a name="Dom::CommentRef::CommentRef">CommentRef</a></h2>

<table summary="Function 'Dom::CommentRef::CommentRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>CommentRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CommentRef">CommentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;CommentRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CommentRef::CommentRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> comment node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(CommentRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given comment node after a call to createComment.<p>
</tr>
</table>

<h2 align=center><a name="Dom::CommentRef::CommentRef_1">CommentRef</a></h2>

<table summary="Function 'Dom::CommentRef::CommentRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>CommentRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#CommentRef">CommentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;CommentRef(&nbsp;const&nbsp;CommentRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::CommentRef::CommentRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(CommentRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMException::getCode">getCode</a></h2>

<table summary="Function 'Dom::DOMException::getCode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getCode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMException">DOMException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get Oracle XML error code embedded in the exception </tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;//&nbsp;virtual&nbsp;unsigned&nbsp;getCode()&nbsp;const&nbsp;=&nbsp;0;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(unsigned)</b></tt> numeric error code (0 on success)</tr>
<tr><th scope=row><i>Description</i>
<td>        Virtual member function inherited from XMLException<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMException::getDOMCode">getDOMCode</a></h2>

<table summary="Function 'Dom::DOMException::getDOMCode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getDOMCode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMException">DOMException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DOM exception code embedded in the exception </tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;virtual&nbsp;DOMExceptionCode&nbsp;getDOMCode()&nbsp;const&nbsp;=&nbsp;0;<br>};</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMExceptionCode)</b></tt> exception code</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a virtual member function that defines a prototype
	for implementation defined member functions returning DOM
	exception codes, defined in DOMExceptionCode, of the
	exceptional situations during execution<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMException::getMesLang">getMesLang</a></h2>

<table summary="Function 'Dom::DOMException::getMesLang' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getMesLang</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMException">DOMException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get current language (encoding) of error messages</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;//&nbsp;virtual&nbsp;oratext*&nbsp;getMesLang()&nbsp;const&nbsp;=&nbsp;0;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> Current language (encoding) of error messages</tr>
<tr><th scope=row><i>Description</i>
<td>        Virtual member function inherited from XMLException<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMException::getMessage">getMessage</a></h2>

<table summary="Function 'Dom::DOMException::getMessage' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getMessage</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMException">DOMException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get Oracle XML error message</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;//&nbsp;virtual&nbsp;oratext*&nbsp;getMessage()&nbsp;const&nbsp;=&nbsp;0;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> Error message</tr>
<tr><th scope=row><i>Description</i>
<td>        Virtual member function inherited from XMLException<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::DOMImplRef">DOMImplRef</a></h2>

<table summary="Function 'Dom::DOMImplRef::DOMImplRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DOMImplRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DOMImplRef(&nbsp;Context*&nbsp;ctx_ptr,&nbsp;DOMImplementation<&nbsp;Node>*&nbsp;impl_ptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplRef::DOMImplRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>ctx_ptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> context pointer</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMImplRef)</b></tt> reference to the implementation object</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates reference object to DOMImplementation object in a given
	context. Returns reference to the implementation object.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::DOMImplRef_1">DOMImplRef</a></h2>

<table summary="Function 'Dom::DOMImplRef::DOMImplRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DOMImplRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DOMImplRef(&nbsp;const&nbsp;DOMImplRef<&nbsp;Context,&nbsp;Node>&&nbsp;iref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplRef::DOMImplRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>iref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMImplRef)</b></tt> new reference to the implementation object</tr>
<tr><th scope=row><i>Description</i>
<td>        It is needed to create other references to the implementation
	object; deletion flags are not copied<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::DOMImplRef_2">DOMImplRef</a></h2>

<table summary="Function 'Dom::DOMImplRef::DOMImplRef_2' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DOMImplRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DOMImplRef(&nbsp;const&nbsp;DOMImplRef<&nbsp;Context,&nbsp;Node>&&nbsp;iref,<br>		&nbsp;&nbsp;Context*&nbsp;ctx_ptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplRef::DOMImplRef_2' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>iref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
<tr><td scope=row><tt>ctx_ptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> different context</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMImplRef)</b></tt> new reference to the implementation object</tr>
<tr><th scope=row><i>Description</i>
<td>        It is needed to create references to the implementation
	object in a different context; deletion flags are not copied<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::createDocument">createDocument</a></h2>

<table summary="Function 'Dom::DOMImplRef::createDocument' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createDocument</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create document reference</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentRef<&nbsp;Node>*&nbsp;createDocument(&nbsp;oratext*&nbsp;namespaceURI,<br>	&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;qualifiedName,&nbsp;DocumentTypeRef<&nbsp;Node>&&nbsp;doctype)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplRef::createDocument' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  namespace URI of root element to create</td></tr>
<tr><td scope=row><tt>qualifiedName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  QName of root element</td></tr>
<tr><td scope=row><tt>doctype</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  associated DTD node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentRef< Node>*)</b></tt> document reference</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates document reference<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::createDocumentType">createDocumentType</a></h2>

<table summary="Function 'Dom::DOMImplRef::createDocumentType' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createDocumentType</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create DTD reference</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentTypeRef<&nbsp;Node>*&nbsp;createDocumentType(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;qualifiedName,&nbsp;oratext*&nbsp;publicId,<br>			&nbsp;&nbsp;&nbsp;oratext*&nbsp;systemId)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplRef::createDocumentType' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>qualifiedName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  qualified name</td></tr>
<tr><td scope=row><tt>publicId</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  external subset public identifier</td></tr>
<tr><td scope=row><tt>systemId</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td>  external subset system identifier</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentTypeRef< Node>*)</b></tt> DTD reference</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates DTD reference<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::getImplementation">getImplementation</a></h2>

<table summary="Function 'Dom::DOMImplRef::getImplementation' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getImplementation</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DOMImplementation object associated with the document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DOMImplementation<&nbsp;Node>*&nbsp;getImplementation()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMImplementation)</b></tt> DOMImplementation reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns DOMImplementation object that was used to create
	this document. When the DOMImplementation object is
	destructed, all document trees associated with it are
	also destructed.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::getNoMod">getNoMod</a></h2>

<table summary="Function 'Dom::DOMImplRef::getNoMod' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNoMod</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the 'no modification allowed' flag value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;getNoMod()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        TRUE if flag's value is TRUE, FALSE otherwise</tr>
<tr><th scope=row><i>Description</i>
<td>        It is an Oracle extension<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::hasFeature">hasFeature</a></h2>

<table summary="Function 'Dom::DOMImplRef::hasFeature' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>hasFeature</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Determine if DOM feature is implemented</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;hasFeature(&nbsp;oratext*&nbsp;feature,&nbsp;oratext*&nbsp;version);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplRef::hasFeature' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>feature</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> package name of the feature to test.</td></tr>
<tr><td scope=row><tt>version</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> version # of the package name to test.</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> is feature implemented?</tr>
<tr><th scope=row><i>Description</i>
<td>        Determine if a DOM feature is implemented.  Returns TRUE if the
        feature is implemented in the specified version, FALSE otherwise.<p>
        In level 1, the legal values for package are 'HTML' and 'XML'
        (case-insensitive), and the version is the string "1.0".  If the
        version is not specified, supporting any version of the feature
        will cause the method to return true.<p>
	DOM 1.0 features are "XML" and "HTML".<p>
	DOM 2.0 features are "Core", "XML", "HTML", "Views",
	"StyleSheets", "CSS", "CSS2", "Events", "UIEvents", "MouseEvents",
	"MutationEvents", "HTMLEvents", "Range", "Traversal"<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::setContext">setContext</a></h2>

<table summary="Function 'Dom::DOMImplRef::setContext' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setContext</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set another context to a node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setContext(&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref,&nbsp;Context*&nbsp;ctx_ptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplRef::setContext' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node reference</td></tr>
<tr><td scope=row><tt>ctx_ptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> different context</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        It is needed to create node references in a different context<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplRef::~DOMImplRef">~DOMImplRef</a></h2>

<table summary="Function 'Dom::DOMImplRef::~DOMImplRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>~DOMImplRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplRef">DOMImplRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Public default destructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;~DOMImplRef();&nbsp;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        This is the default destructor. It cleans the reference to
	the implementation object. It is usually
	called by the environment. But it can be called by the user
	directly if necessary.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplementation::DOMImplementation">DOMImplementation</a></h2>

<table summary="Function 'Dom::DOMImplementation::DOMImplementation' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DOMImplementation</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplementation">DOMImplementation</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DOMImplementation(&nbsp;boolean&nbsp;no_mod);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DOMImplementation::DOMImplementation' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>no_mod</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> value of the 'no modifications allowed' flag</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMImplementation)</b></tt> implementation object</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates DOMImplementation object. Sets the
	'no modifications allowed' flag to the parameter value.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplementation::getNoMod">getNoMod</a></h2>

<table summary="Function 'Dom::DOMImplementation::getNoMod' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNoMod</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplementation">DOMImplementation</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the 'no modification allowed' flag value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;getNoMod()&nbsp;const;<br>};</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        TRUE if flag's value is TRUE, FALSE otherwise</tr>
<tr><th scope=row><i>Description</i>
<td>        It is an Oracle extension<p>
</tr>
</table>

<h2 align=center><a name="Dom::DOMImplementation::~DOMImplementation">~DOMImplementation</a></h2>

<table summary="Function 'Dom::DOMImplementation::~DOMImplementation' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>~DOMImplementation</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DOMImplementation">DOMImplementation</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Public default destructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;~DOMImplementation();&nbsp;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        This is the default destructor. It removes all DOM trees
	associated with this object.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentFragmentRef::DocumentFragmentRef">DocumentFragmentRef</a></h2>

<table summary="Function 'Dom::DocumentFragmentRef::DocumentFragmentRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentFragmentRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentFragmentRef">DocumentFragmentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentFragmentRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,<br>			&nbsp;&nbsp;&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentFragmentRef::DocumentFragmentRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> document fragment node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentFragmentRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references to a given
	fragment node after a call to createDocumentFragment.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentFragmentRef::DocumentFragmentRef_1">DocumentFragmentRef</a></h2>

<table summary="Function 'Dom::DocumentFragmentRef::DocumentFragmentRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentFragmentRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentFragmentRef">DocumentFragmentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentFragmentRef(&nbsp;const&nbsp;DocumentFragmentRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentFragmentRef::DocumentFragmentRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentFragmentRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRange::DocumentRange">DocumentRange</a></h2>

<table summary="Function 'Dom::DocumentRange::DocumentRange' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentRange</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRange">DocumentRange</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentRange();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentRange)</b></tt> new factory object</tr>
<tr><th scope=row><i>Description</i>
<td>        Constructs the factory<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRange::createRange">createRange</a></h2>

<table summary="Function 'Dom::DocumentRange::createRange' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createRange</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRange">DocumentRange</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create new range object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Range<&nbsp;Node>*&nbsp;createRange(&nbsp;DocumentRef<&nbsp;Node>&&nbsp;doc);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRange::createRange' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>doc</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to a document node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Range*)</b></tt> Pointer to new range</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRange::destroyRange">destroyRange</a></h2>

<table summary="Function 'Dom::DocumentRange::destroyRange' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>destroyRange</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRange">DocumentRange</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Destroy range object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;destroyRange(&nbsp;Range<&nbsp;Node>*&nbsp;range)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRange::destroyRange' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>range</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> range to be destroyed</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRange::~DocumentRange">~DocumentRange</a></h2>

<table summary="Function 'Dom::DocumentRange::~DocumentRange' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>~DocumentRange</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRange">DocumentRange</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Default destructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;~DocumentRange();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::DocumentRef">DocumentRef</a></h2>

<table summary="Function 'Dom::DocumentRef::DocumentRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::DocumentRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the object to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> document node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a onstructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::DocumentRef_1">DocumentRef</a></h2>

<table summary="Function 'Dom::DocumentRef::DocumentRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentRef(&nbsp;const&nbsp;DocumentRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::DocumentRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createAttribute">createAttribute</a></h2>

<table summary="Function 'Dom::DocumentRef::createAttribute' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createAttribute</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an attribute node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createAttribute(&nbsp;oratext*&nbsp;name)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createAttribute' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New attribute node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an attribute node with the given name. This is the
	non-namespace aware function. The new attribute will have NULL
	namespace URI and prefix, and its local name will be the same as
	its name, even if the name specified is a QName. The new node is
	an orphan with no parent. The name is NOT copied, its pointer is
	just stored. The user is responsible for persistence and freeing
	of that data.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createAttributeNS">createAttributeNS</a></h2>

<table summary="Function 'Dom::DocumentRef::createAttributeNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createAttributeNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an attribute node with namespace information</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createAttributeNS(&nbsp;oratext*&nbsp;namespaceURI,<br>			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;qualifiedName)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createAttributeNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
<tr><td scope=row><tt>qualifiedName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New attribute node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an attribute node with the given namespace URI and QName.
	The new node is an orphan with no parent. The URI and QName
	are NOT copied, their pointers are just stored.  The user is
	responsible for persistence and freeing of that data.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createCDATASection">createCDATASection</a></h2>

<table summary="Function 'Dom::DocumentRef::createCDATASection' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createCDATASection</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create a CDATA node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createCDATASection(&nbsp;oratext*&nbsp;data)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createCDATASection' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> data for new CDATA node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New CDATA node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a CDATA section node with the given initial data (which
        should be in the data encoding).  A CDATA section is considered
        verbatim and is never parsed; it will not be joined with adjacent
        text nodes by the normalize operation.  The initial data may be
        NULL, if provided; it is not verified, converted, or checked.
	The name of a CDATA node is always "#cdata-section". The new node
	is an orphan with no parent. The CDATA is NOT copied, its pointer
	is just stored.  The user is responsible for persistence and
	freeing of that data.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createComment">createComment</a></h2>

<table summary="Function 'Dom::DocumentRef::createComment' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createComment</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create a comment node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createComment(&nbsp;oratext*&nbsp;data)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createComment' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> data for new comment node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New comment node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a comment node with the given initial data (which must
	be in the data encoding).  The data may be NULL, if provided;
	it is not verified, converted, or checked. The name of the comment
	node is always "#comment". The new node is an orphan with no
	parent. The comment data is NOT copied, its pointer is just
	stored.  The user is responsible for persistence and freeing
	of that data.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createDocumentFragment">createDocumentFragment</a></h2>

<table summary="Function 'Dom::DocumentRef::createDocumentFragment' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createDocumentFragment</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create a document fragment</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createDocumentFragment()<br>	&nbsp;&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> new document fragment node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an empty Document Fragment node.  A document fragment
	is treated specially when it is inserted into a DOM tree:
	the children of the fragment are inserted in order instead of
	the fragment node itself.  After insertion, the fragment node
	will still exist, but have no children. The name of a fragment
	node is always "#document-fragment".<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createElement">createElement</a></h2>

<table summary="Function 'Dom::DocumentRef::createElement' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createElement</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an element node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createElement(&nbsp;oratext*&nbsp;tagname)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createElement' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>tagname</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> tag name</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New element node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an element node with the given tag name (which should
	be in the data encoding). The new node is an orphan with no
	parent. The tagname is NOT copied, its pointer is just stored.
	The user is responsible for persistence and freeing of that data.<p>
	Note that the tag name of an element is CASE SENSITIVE.  This
	is the non-namespace aware function: the new node will have
	NULL namespace URI and prefix, and its local name will be the
	same as its tag name, even if the tag name specified is a QName.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createElementNS">createElementNS</a></h2>

<table summary="Function 'Dom::DocumentRef::createElementNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createElementNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an element node with namespace information</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createElementNS(&nbsp;oratext*&nbsp;namespaceURI,<br>			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;qualifiedName)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createElementNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
<tr><td scope=row><tt>qualifiedName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New element node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an element with the given namespace URI and QName.  
        The new node is an orphan with no parent. The URI and QName
	are NOT copied, their pointers are just stored. The user is
	responsible for persistence and freeing of that data.<p>
	Note that element names are CASE SENSITIVE, and the QName is
	required though the URI may be NULL.  The QName will be split
	into prefix and local parts. The tagName will be the full
	QName.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createEntityReference">createEntityReference</a></h2>

<table summary="Function 'Dom::DocumentRef::createEntityReference' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createEntityReference</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create an entity reference node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createEntityReference(&nbsp;oratext*&nbsp;name)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createEntityReference' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New entity reference node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates an entity reference node; the name (which should be in
	the data encoding) is the name of the entity to be referenced.
	The named entity does not have to exist. The name is not verified,
	converted, or checked. The new node is an orphan with no parent.
	The entity reference name is NOT copied; its pointer is just
	stored. The user is responsible for persistence and freeing of
	that data.<p>
	Note that entity reference nodes are never generated by the
	parser; instead, entity references are expanded as encountered.
	On output, an entity reference node will turn into a "&amp;name;"
	style reference.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createProcessingInstruction">createProcessingInstruction</a></h2>

<table summary="Function 'Dom::DocumentRef::createProcessingInstruction' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createProcessingInstruction</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create a processing instruction node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createProcessingInstruction(&nbsp;oratext*&nbsp;target,&nbsp;oratext*&nbsp;data)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createProcessingInstruction' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>target</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> target</td></tr>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> data for new PI node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New PI node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a processing instruction node with the given target and
        data (which should be in the data encoding). The data may be
	NULL, but the target is required and cannot be changed.  The
	target and data are not verified, converted, or checked. The
	name of the node is the same as the target. The new node is an
	orphan with no parent. The target and data are NOT copied;
	their pointers are just stored.  The user is responsible for
	persistence and freeing of that data.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::createTextNode">createTextNode</a></h2>

<table summary="Function 'Dom::DocumentRef::createTextNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createTextNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create a text node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;createTextNode(&nbsp;oratext*&nbsp;data)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::createTextNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> data for new text node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> new text node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a text node with the given initial data (which must be
        non-NULL and in the data encoding).  The data may be NULL; if
        provided, it is not verified, converted, checked, or parsed
        (entities will not be expanded). The name of the node is always
	"#text". The new node is an orphan with no parent. The text data
	is NOT copied, its pointer is just stored.  The user is
	responsible for persistence and freeing of that data.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::getDoctype">getDoctype</a></h2>

<table summary="Function 'Dom::DocumentRef::getDoctype' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getDoctype</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD (Document Type) associated with the document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getDoctype()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> DTD node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the DTD node associated with this document.
	After this call, a DocumentTypeRef object needs to be created
	with an appropriate constructor in order to call its member
	functions. The DTD tree cannot be edited.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::getDocumentElement">getDocumentElement</a></h2>

<table summary="Function 'Dom::DocumentRef::getDocumentElement' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getDocumentElement</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get top-level element of this document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getDocumentElement()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> Root element</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the root element (node) of the DOM tree.
        Each document has only one uppermost Element node, called
        the root element. If there is no root element, NULL is
	returned. This can happen when the document tree is
	being constructed.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::getElementById">getElementById</a></h2>

<table summary="Function 'Dom::DocumentRef::getElementById' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getElementById</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get an element given its ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getElementById(&nbsp;oratext*&nbsp;elementId);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::getElementById' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>elementId</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt>Element node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the element node which has the given ID. Throws
	NOT_FOUND_ERR if no element is found. The given ID should be
	in the data encoding or it might not match.<p>
	Note that attributes named "ID" are not automatically of type ID;
	ID attributes (which can have any name) must be declared as type
	ID in the DTD or XML schema associated with the document.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::getElementsByTagName">getElementsByTagName</a></h2>

<table summary="Function 'Dom::DocumentRef::getElementsByTagName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getElementsByTagName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get elements in the document by tag name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeList<&nbsp;Node>*&nbsp;getElementsByTagName(&nbsp;oratext*&nbsp;tagname)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::getElementsByTagName' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>tagname</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> tag name</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeList< Node>*)</b></tt> List of nodes</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of all elements in the document with a given tag
	name, in document order (i.e. the order in which they would be
	encountered in a preorder traversal of the tree). The list should
	be freed by the user when it is no longer needed. The list is NOT
	live, it is a snapshot.  That is, if a new node which matched the
	tag name were added to the DOM after the list was returned, the
	list would not automatically be updated to include the node.<p>
        The special name "*" matches all tag names; a NULL name matches
        nothing.  Note that tag names are CASE SENSITIVE, and should be
	in the data encoding or a mismatch might occur.<p>
        This function is not namespace aware; the full tag names are
	compared. If two QNames with two different prefixes both of
	which map to the same URI are compared, the comparison will fail.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::getElementsByTagNameNS">getElementsByTagNameNS</a></h2>

<table summary="Function 'Dom::DocumentRef::getElementsByTagNameNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getElementsByTagNameNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get elements in the document by tag name (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeList<&nbsp;Node>*&nbsp;getElementsByTagNameNS(&nbsp;oratext*&nbsp;namespaceURI,<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;localName);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::getElementsByTagNameNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
<tr><td scope=row><tt>localName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeList< Node>*)</b></tt> List of nodes</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of all elements in the document with a given
	namespace URI and local name, in document order (i.e. the order
	in which they would be encountered in a preorder traversal of the
	tree). The list should be freed by the user when it is no longer
	needed. The list is NOT	live, it is a snapshot.  That is, if a new
	node which matches the URI and local name were added to the DOM
	after the list was returned, the list would not automatically be
	updated to include the node.<p>
        The URI and local name should be in the data encoding. The special
	name "*" matches all local names; a NULL local name matches
        nothing. Namespace URIs must always match, however, no wildcard is
        allowed.  Note that comparisons are CASE SENSITIVE.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::getImplementation">getImplementation</a></h2>

<table summary="Function 'Dom::DocumentRef::getImplementation' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getImplementation</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DOMImplementation object associated with the document</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DOMImplementation<&nbsp;Node>*&nbsp;getImplementation()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMImplementation)</b></tt> DOMImplementation reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns DOMImplementation object that was used to create
	this document. When the DOMImplementation object is
	destructed, all document trees associated with it are
	also destructed.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentRef::importNode">importNode</a></h2>

<table summary="Function 'Dom::DocumentRef::importNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>importNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentRef">DocumentRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Import a node from another DOM</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;importNode(&nbsp;NodeRef<&nbsp;Node>&&nbsp;importedNode,<br>			boolean&nbsp;deep)&nbsp;const<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentRef::importNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>importedNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
<tr><td scope=row><tt>deep</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td></td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> New imported node</tr>
<tr><th scope=row><i>Description</i>
<td>        Imports a node from one Document to another.  The new node is an
        orphan and has no parent. The original node is not modified in
	any way or removed from its document; instead, a new node is
	created with copies of all the original node's QName, prefix,
	namespace URI, and local name.<p>
	The deep controls whether the children of the node are
	recursively imported.  If FALSE, only the node itself is imported,
	and it will have no children.  If TRUE, all descendents of the
	node will be imported as well, and an entire new subtree created.
	Elements will have only their specified attributes imported;
	non-specified (default) attributes are omitted.  New default
	attributes (for the destination document) are then added.
	Document and DocumentType nodes cannot be imported.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTraversal::DocumentTraversal">DocumentTraversal</a></h2>

<table summary="Function 'Dom::DocumentTraversal::DocumentTraversal' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentTraversal</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTraversal">DocumentTraversal</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentTraversal();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentTraversal)</b></tt> new factory object</tr>
<tr><th scope=row><i>Description</i>
<td>        Constructs the factory<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTraversal::createNodeIterator">createNodeIterator</a></h2>

<table summary="Function 'Dom::DocumentTraversal::createNodeIterator' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createNodeIterator</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTraversal">DocumentTraversal</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create new iterator object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeIterator<&nbsp;Node>*&nbsp;createNodeIterator(&nbsp;NodeRef<&nbsp;Node>&&nbsp;root,<br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WhatToShowCode&nbsp;whatToShow,<br>				&nbsp;&nbsp;&nbsp;boolean&nbsp;entityReferenceExpansion)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentTraversal::createNodeIterator' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>root</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> root of subtree to iterate on</td></tr>
<tr><td scope=row><tt>whatToShow</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node types filter</td></tr>
<tr><td scope=row><tt>filter</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> user defined node filter</td></tr>
<tr><td scope=row><tt>entityReferenceExpansion</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> expand entity references if TRUE</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeIterator*)</b></tt> Pointer to new iterator</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTraversal::createTreeWalker">createTreeWalker</a></h2>

<table summary="Function 'Dom::DocumentTraversal::createTreeWalker' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>createTreeWalker</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTraversal">DocumentTraversal</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Create new tree walker object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;TreeWalker<&nbsp;Node>*&nbsp;createTreeWalker(&nbsp;NodeRef<&nbsp;Node>&&nbsp;root,<br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WhatToShowCode&nbsp;whatToShow,<br>				&nbsp;&nbsp;boolean&nbsp;entityReferenceExpansion)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentTraversal::createTreeWalker' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>root</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> root of subtree to traverse</td></tr>
<tr><td scope=row><tt>whatToShow</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node types filter</td></tr>
<tr><td scope=row><tt>filter</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> user defined node filter</td></tr>
<tr><td scope=row><tt>entityReferenceExpansion</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> expand entity references if TRUE</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(TreeWalker*)</b></tt> Pointer to new tree walker</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTraversal::destroyNodeIterator">destroyNodeIterator</a></h2>

<table summary="Function 'Dom::DocumentTraversal::destroyNodeIterator' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>destroyNodeIterator</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTraversal">DocumentTraversal</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Destroy node iterator object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;destroyNodeIterator(&nbsp;NodeIterator<&nbsp;Node>*&nbsp;iter)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentTraversal::destroyNodeIterator' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>iter</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> iterator to be destroyed</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTraversal::destroyTreeWalker">destroyTreeWalker</a></h2>

<table summary="Function 'Dom::DocumentTraversal::destroyTreeWalker' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>destroyTreeWalker</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTraversal">DocumentTraversal</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Destroy tree walker object</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;destroyTreeWalker(&nbsp;TreeWalker<&nbsp;Node>*&nbsp;walker)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentTraversal::destroyTreeWalker' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>walker</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> tree walker to be destroyed</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTraversal::~DocumentTraversal">~DocumentTraversal</a></h2>

<table summary="Function 'Dom::DocumentTraversal::~DocumentTraversal' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>~DocumentTraversal</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTraversal">DocumentTraversal</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Default destructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;~DocumentTraversal();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::DocumentTypeRef">DocumentTypeRef</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::DocumentTypeRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentTypeRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentTypeRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentTypeRef::DocumentTypeRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the object to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> document type node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentTypeRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::DocumentTypeRef_1">DocumentTypeRef</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::DocumentTypeRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>DocumentTypeRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DocumentTypeRef(&nbsp;const&nbsp;DocumentTypeRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentTypeRef::DocumentTypeRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DocumentTypeRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::getEntities">getEntities</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::getEntities' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getEntities</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's entities</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NamedNodeMap<&nbsp;Node>*&nbsp;getEntities()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NamedNodeMap< Node>*)</b></tt> map containing entities</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a named node map of general entities defined by the DTD.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::getInternalSubset">getInternalSubset</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::getInternalSubset' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getInternalSubset</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's internal subset</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getInternalSubset(&nbsp;oratext*&nbsp;name);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::DocumentTypeRef::getInternalSubset' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name of the element</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(xmlnode*)</b></tt> content model subtree</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the content model for an element.  If there is no DTD,
        returns NULL.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::getName">getName</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::getName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get name of DTD</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getName()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> name of DTD</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns DTD's name (specified immediately after the <tt>DOCTYPE</tt>
        keyword)<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::getNotations">getNotations</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::getNotations' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNotations</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's notations</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NamedNodeMap<&nbsp;Node>*&nbsp;getNotations()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NamedNodeMap< Node>*)</b></tt> map containing notations</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a named node map of notations declared by the DTD.<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::getPublicId">getPublicId</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::getPublicId' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getPublicId</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's public ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getPublicId()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> DTD's public identifier</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns DTD's public identifier<p>
</tr>
</table>

<h2 align=center><a name="Dom::DocumentTypeRef::getSystemId">getSystemId</a></h2>

<table summary="Function 'Dom::DocumentTypeRef::getSystemId' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getSystemId</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#DocumentTypeRef">DocumentTypeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get DTD's system ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getSystemId()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> DTD's system identifier</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns DTD's system identifier<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::ElementRef">ElementRef</a></h2>

<table summary="Function 'Dom::ElementRef::ElementRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>ElementRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;ElementRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::ElementRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> element node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ElementRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given element node after a call to createElement.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::ElementRef_1">ElementRef</a></h2>

<table summary="Function 'Dom::ElementRef::ElementRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>ElementRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;ElementRef(&nbsp;const&nbsp;ElementRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::ElementRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ElementRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::getAttribute">getAttribute</a></h2>

<table summary="Function 'Dom::ElementRef::getAttribute' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getAttribute</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get attribute's value given its name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getAttribute(&nbsp;oratext*&nbsp;name)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::getAttribute' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name (in data encoding)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> named attribute's value (in data encoding)</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the value of an element's attribute (specified by name).
        Note that an attribute may have the empty string as its value,
        but cannot be NULL.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::getAttributeNS">getAttributeNS</a></h2>

<table summary="Function 'Dom::ElementRef::getAttributeNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getAttributeNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get attribute's value given its URI and localname</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getAttributeNS(&nbsp;oratext*&nbsp;namespaceURI,<br>			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;localName);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::getAttributeNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI (data encoding)</td></tr>
<tr><td scope=row><tt>localName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's local name (data encoding)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> named attribute's value (in data encoding)</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the value of an element's attribute (specified by URI and
        localname).  Note that an attribute may have the empty string as
        its value, but cannot be NULL.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::getAttributeNode">getAttributeNode</a></h2>

<table summary="Function 'Dom::ElementRef::getAttributeNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getAttributeNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the attribute node given its name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getAttributeNode(&nbsp;oratext*&nbsp;name)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::getAttributeNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name (data encoding)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the attribute node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the attribute node given its name.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::getElementsByTagName">getElementsByTagName</a></h2>

<table summary="Function 'Dom::ElementRef::getElementsByTagName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getElementsByTagName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get elements with given tag name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeList<&nbsp;Node>*&nbsp;getElementsByTagName(&nbsp;oratext*&nbsp;name);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::getElementsByTagName' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> tag name to match (data encoding; "*" for any tag)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeList< Node>*)</b></tt> the list of elements</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a list of all elements with a given tag name, in the
	order in which they would be encountered in a preorder traversal
	of the subtree. The tag name should be in the data encoding.
	The special name <tt>"*"</tt> matches all tag names; a NULL name matches
	nothing.  Tag names are CASE SENSITIVE.  This function is not
	namespace aware; the full tag names are compared. The returned
	list should be freed by the user.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::getTagName">getTagName</a></h2>

<table summary="Function 'Dom::ElementRef::getTagName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getTagName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get element's tag name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getTagName()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> element's name [<i>in data encoding</i>]</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the tag name of an element node which is supposed
	to have the same value as the node name from the node
	interface<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::hasAttribute">hasAttribute</a></h2>

<table summary="Function 'Dom::ElementRef::hasAttribute' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>hasAttribute</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Check if named attribute exist</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;hasAttribute(&nbsp;oratext*&nbsp;name);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::hasAttribute' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name (data encoding)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if element has attribute with given name</tr>
<tr><th scope=row><i>Description</i>
<td>        Determines if an element has a attribute with the given name<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::hasAttributeNS">hasAttributeNS</a></h2>

<table summary="Function 'Dom::ElementRef::hasAttributeNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>hasAttributeNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Check if named attribute exist (namespace aware version)</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;hasAttributeNS(&nbsp;oratext*&nbsp;namespaceURI,&nbsp;oratext*&nbsp;localName);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::hasAttributeNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI (data encoding)</td></tr>
<tr><td scope=row><tt>localName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's local name (data encoding)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if element has such attribute</tr>
<tr><th scope=row><i>Description</i>
<td>        Determines if an element has a attribute with the given URI
	and local name<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::removeAttribute">removeAttribute</a></h2>

<table summary="Function 'Dom::ElementRef::removeAttribute' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>removeAttribute</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove attribute with specified name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;removeAttribute(&nbsp;oratext*&nbsp;name)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::removeAttribute' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name [<i>data encoding</i>]</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Removes an attribute specified by name. The attribute is removed
	from the element's list of attributes, but the attribute node
	itself is not destroyed.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::removeAttributeNS">removeAttributeNS</a></h2>

<table summary="Function 'Dom::ElementRef::removeAttributeNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>removeAttributeNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove attribute with specified URI and local name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;removeAttributeNS(&nbsp;oratext*&nbsp;namespaceURI,&nbsp;oratext*&nbsp;localName)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::removeAttributeNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI</td></tr>
<tr><td scope=row><tt>localName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's local name</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Removes an attribute specified by URI and local name. The
	attribute is removed from the element's list of attributes, but
	the attribute node itself is not destroyed.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::removeAttributeNode">removeAttributeNode</a></h2>

<table summary="Function 'Dom::ElementRef::removeAttributeNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>removeAttributeNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove attribute node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;removeAttributeNode(&nbsp;AttrRef<&nbsp;Node>&&nbsp;oldAttr)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::removeAttributeNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>oldAttr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node to remove</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the attribute node (old) or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Removes an attribute from an element. Returns a pointer to
	the removed attribute or NULL<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::setAttribute">setAttribute</a></h2>

<table summary="Function 'Dom::ElementRef::setAttribute' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setAttribute</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set new attribute for this element and /or new value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setAttribute(&nbsp;oratext*&nbsp;name,&nbsp;oratext*&nbsp;value)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::setAttribute' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's name (data encoding)</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's value (data encoding)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a new attribute for an element with the given name and
	value (which should be in the data encoding). If the named attribute
	already exists, its value is simply replaced.  The name and value
	are not verified, converted, or checked. The value is not parsed,
	so entity references will not be expanded.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::setAttributeNS">setAttributeNS</a></h2>

<table summary="Function 'Dom::ElementRef::setAttributeNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setAttributeNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set new attribute for the element and /or new value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setAttributeNS(&nbsp;oratext*&nbsp;namespaceURI,<br>			&nbsp;&nbsp;&nbsp;oratext*&nbsp;qualifiedName,&nbsp;oratext*&nbsp;value)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::setAttributeNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's namespace URI (data encoding)</td></tr>
<tr><td scope=row><tt>qualifiedName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's qualified name (data encoding)</td></tr>
<tr><td scope=row><tt>value</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute's value (data encoding)</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Creates a new attribute for an element with the given URI,
	localname and value (which should be in the data encoding).
	If the named attribute already exists, its value is simply
	replaced.  The name and value are not verified, converted, or
	checked. The value is not parsed, so entity references will not
	be expanded.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ElementRef::setAttributeNode">setAttributeNode</a></h2>

<table summary="Function 'Dom::ElementRef::setAttributeNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setAttributeNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ElementRef">ElementRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set attribute node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;setAttributeNode(&nbsp;AttrRef<&nbsp;Node>&&nbsp;newAttr)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ElementRef::setAttributeNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newAttr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> attribute node to add</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the attribute node (old or new)</tr>
<tr><th scope=row><i>Description</i>
<td>        Adds a new attribute to an element.  If an attribute with the
	given name already exists, it is replaced and a pointer to the
	old attribute returned. If the attribute is new, it is added to
	the element's list and a pointer to the new attribute is
	returned.<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityRef::EntityRef">EntityRef</a></h2>

<table summary="Function 'Dom::EntityRef::EntityRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>EntityRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityRef">EntityRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;EntityRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::EntityRef::EntityRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> entity node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(EntityRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given entity node after a call to createEntity.<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityRef::EntityRef_1">EntityRef</a></h2>

<table summary="Function 'Dom::EntityRef::EntityRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>EntityRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityRef">EntityRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;EntityRef(&nbsp;const&nbsp;EntityRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::EntityRef::EntityRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(EntityRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityRef::getNotationName">getNotationName</a></h2>

<table summary="Function 'Dom::EntityRef::getNotationName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNotationName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityRef">EntityRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's notation</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getNotationName()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> entity's notation</tr>
<tr><th scope=row><i>Description</i>
<td>        For unparsed entities, returns the name of its notation (in the
	data encoding).  For parsed entities and other node types,
	returns NULL.<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityRef::getPublicId">getPublicId</a></h2>

<table summary="Function 'Dom::EntityRef::getPublicId' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getPublicId</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityRef">EntityRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's public ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getPublicId()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> entity's public identifier</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an entity's public identifier (in the data encoding).<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityRef::getSystemId">getSystemId</a></h2>

<table summary="Function 'Dom::EntityRef::getSystemId' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getSystemId</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityRef">EntityRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's system ID</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getSystemId()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> entity's system identifier</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns an entity's system identifier (in the data encoding).<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityRef::getType">getType</a></h2>

<table summary="Function 'Dom::EntityRef::getType' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getType</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityRef">EntityRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get entity's type</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;getType()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE for general entity, FALSE for parameter entity</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a boolean for an entity describing whether it is general
        (TRUE) or parameter (FALSE).<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityReferenceRef::EntityReferenceRef">EntityReferenceRef</a></h2>

<table summary="Function 'Dom::EntityReferenceRef::EntityReferenceRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>EntityReferenceRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityReferenceRef">EntityReferenceRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;EntityReferenceRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::EntityReferenceRef::EntityReferenceRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> entity reference node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(EntityReferenceRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references to a given
	entity reference node after a call to createEntityReference.<p>
</tr>
</table>

<h2 align=center><a name="Dom::EntityReferenceRef::EntityReferenceRef_1">EntityReferenceRef</a></h2>

<table summary="Function 'Dom::EntityReferenceRef::EntityReferenceRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>EntityReferenceRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#EntityReferenceRef">EntityReferenceRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;EntityReferenceRef(&nbsp;const&nbsp;EntityReferenceRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::EntityReferenceRef::EntityReferenceRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(EntityReferenceRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::NamedNodeMapRef">NamedNodeMapRef</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::NamedNodeMapRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NamedNodeMapRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NamedNodeMapRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,<br>		&nbsp;&nbsp;&nbsp;NamedNodeMap<&nbsp;Node>*&nbsp;mptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::NamedNodeMapRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to provide the context</td></tr>
<tr><td scope=row><tt>mptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node map to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NamedNodeMapRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references to a given
	NamedNodeMap node.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::NamedNodeMapRef_1">NamedNodeMapRef</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::NamedNodeMapRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NamedNodeMapRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NamedNodeMapRef(&nbsp;const&nbsp;NamedNodeMapRef<&nbsp;Node>&&nbsp;mref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::NamedNodeMapRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>mref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NamedNodeMapRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::getLength">getLength</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::getLength' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getLength</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get map's length</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;ub4&nbsp;getLength()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> map's length</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::getNamedItem">getNamedItem</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::getNamedItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNamedItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get item given its name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getNamedItem(&nbsp;oratext*&nbsp;name)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::getNamedItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> item's name</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::getNamedItemNS">getNamedItemNS</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::getNamedItemNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNamedItemNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get item given its namespace URI and local name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getNamedItemNS(&nbsp;oratext*&nbsp;namespaceURI,<br>			&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;localName)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::getNamedItemNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> namespace URI of the item</td></tr>
<tr><td scope=row><tt>localName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> local name of th item</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::item">item</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::item' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>item</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get item given its index</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;item(&nbsp;ub4&nbsp;index)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::item' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>index</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> item's index</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::removeNamedItem">removeNamedItem</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::removeNamedItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>removeNamedItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove an item given its name</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;removeNamedItem(&nbsp;oratext*&nbsp;name)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::removeNamedItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>name</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> name of the item to be removed</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the removed item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::removeNamedItemNS">removeNamedItemNS</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::removeNamedItemNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>removeNamedItemNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove the item from the map</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;removeNamedItemNS(&nbsp;oratext*&nbsp;namespaceURI,<br>			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oratext*&nbsp;localName)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::removeNamedItemNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>namespaceURI</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> namespace URI of the item</td></tr>
<tr><td scope=row><tt>localName</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> local name of the item</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the removed item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::setNamedItem">setNamedItem</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::setNamedItem' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setNamedItem</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Add new item to the map</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;setNamedItem(&nbsp;NodeRef<&nbsp;Node>&&nbsp;newItem)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::setNamedItem' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newItem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> item to add to the map</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to new item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NamedNodeMapRef::setNamedItemNS">setNamedItemNS</a></h2>

<table summary="Function 'Dom::NamedNodeMapRef::setNamedItemNS' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setNamedItemNS</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NamedNodeMapRef">NamedNodeMapRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set named item to the map</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;setNamedItemNS(&nbsp;NodeRef<&nbsp;Node>&&nbsp;newItem)<br>	throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NamedNodeMapRef::setNamedItemNS' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newItem</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> item to be set to the map</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeFilter::acceptNode">acceptNode</a></h2>

<table summary="Function 'Dom::NodeFilter::acceptNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>acceptNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeFilter">NodeFilter</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Execute it for a given node and use its return value</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>template<&nbsp;typename&nbsp;Node>&nbsp;AcceptNodeCode&nbsp;AcceptNode(<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeFilter::acceptNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the node to be evaluated</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(AcceptNodeCode)</b></tt> result returned by the filter function</tr>
<tr><th scope=row><i>Description</i>
<td>        This function is used as a test by NodeIterator and
	TreeWalker<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeIterator::adjustCtx">adjustCtx</a></h2>

<table summary="Function 'Dom::NodeIterator::adjustCtx' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>adjustCtx</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeIterator">NodeIterator</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Attach this iterator to the another context</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;adjustCtx(&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeIterator::adjustCtx' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> given node reference</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Attaches this iterator to the context associated with
	a given node reference<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeIterator::detach">detach</a></h2>

<table summary="Function 'Dom::NodeIterator::detach' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>detach</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeIterator">NodeIterator</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>invalidate the iterator</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;detach();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeIterator::nextNode">nextNode</a></h2>

<table summary="Function 'Dom::NodeIterator::nextNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>nextNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeIterator">NodeIterator</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Go to the next node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;nextNode()&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the next node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeIterator::previousNode">previousNode</a></h2>

<table summary="Function 'Dom::NodeIterator::previousNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>previousNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeIterator">NodeIterator</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Go to the previous node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;previousNode()&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the previous node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeListRef::NodeListRef">NodeListRef</a></h2>

<table summary="Function 'Dom::NodeListRef::NodeListRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NodeListRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeListRef">NodeListRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeListRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,<br>		&nbsp;&nbsp;&nbsp;NodeList<&nbsp;Node>*&nbsp;lptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeListRef::NodeListRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to provide the context</td></tr>
<tr><td scope=row><tt>lptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node list node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeListRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references to a given
	NodeList node.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeListRef::NodeListRef_1">NodeListRef</a></h2>

<table summary="Function 'Dom::NodeListRef::NodeListRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NodeListRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeListRef">NodeListRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeListRef(&nbsp;const&nbsp;NodeListRef<&nbsp;Node>&&nbsp;lref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeListRef::NodeListRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>lref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeListRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeListRef::getLength">getLength</a></h2>

<table summary="Function 'Dom::NodeListRef::getLength' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getLength</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeListRef">NodeListRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get list's length</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;ub4&nbsp;getLength()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ub4)</b></tt> list's length</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeListRef::item">item</a></h2>

<table summary="Function 'Dom::NodeListRef::item' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>item</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeListRef">NodeListRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get item given its index</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;item(&nbsp;ub4&nbsp;index)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeListRef::item' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>index</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> index of the item</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the item</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::NodeRef">NodeRef</a></h2>

<table summary="Function 'Dom::NodeRef::NodeRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NodeRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::NodeRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the node reference object</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given node when at least one reference to this node or
	another node is already available. The node deletion flag is
	not copied and is set to FALSE.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::NodeRef_1">NodeRef</a></h2>

<table summary="Function 'Dom::NodeRef::NodeRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NodeRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::NodeRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This copy constructor is used to create additional references
	to the node when at least one reference is already available.
	The node deletion flag is not copied and is set to FALSE.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::appendChild">appendChild</a></h2>

<table summary="Function 'Dom::NodeRef::appendChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>appendChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Append new child to node's list of children</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;appendChild(&nbsp;NodeRef&&nbsp;newChild)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::appendChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the node to add</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the node appended</tr>
<tr><th scope=row><i>Description</i>
<td>        Appends the node to the end of this node's list of children and
        returns the new node.  If newChild is a DocumentFragment, all of
        its children are appended in original order; the
	DocumentFragment node itself is not. If newChild is already in
	the DOM tree, it is first removed from its current position.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::cloneNode">cloneNode</a></h2>

<table summary="Function 'Dom::NodeRef::cloneNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>cloneNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Clone this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;cloneNode(&nbsp;boolean&nbsp;deep);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::cloneNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>deep</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> indicates if children should be recursively cloned</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> duplicate (cloned) node</tr>
<tr><th scope=row><i>Description</i>
<td>        Creates and returns a duplicate of this node. The duplicate
	node has no parent.  Cloning an Element copies all attributes
	and their values, including those generated by the XML
	processor to represent defaulted attributes, but it does not
	copy any text it contains unless it is a deep clone, since the
	text is contained in a child Text node.  Cloning any other type
	of node simply returns a copy of the node. If deep is TRUE, all
	children of the node are recursively cloned, and the cloned
	node will have cloned children; a non-deep clone will have no
	children. If the cloned node is not inserted into another tree
	or fragment, it probably should be marked, through its
	reference, for deletion (by the user).<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getAttributes">getAttributes</a></h2>

<table summary="Function 'Dom::NodeRef::getAttributes' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getAttributes</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get attributes of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NamedNodeMap<&nbsp;Node>*&nbsp;getAttributes()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NamedNodeMap*)</b></tt> NamedNodeMap of attributes</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns NamedNodeMap of attributes of this
	node, or NULL if it has no attributes. Only element nodes
	can have attribute nodes. For other node kinds, NULL is
	always returned. In the current implementation, the node map
	of child nodes is live; all changes in the original node are
	reflected immediately. Because of this, side effects can be
	present for some DOM tree manipulation styles, in particular,
	in multi-threaded environments.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getChildNodes">getChildNodes</a></h2>

<table summary="Function 'Dom::NodeRef::getChildNodes' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getChildNodes</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get children of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NodeList<&nbsp;Node>*&nbsp;getChildNodes()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NodeList*)</b></tt> the list of child nodes</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the list of child nodes, or NULL
	if this node has no children. Only Element, Document, DTD,
	and DocumentFragment nodes may have children; all other types
	will return NULL. In the current implementation, the list of
	child nodes is live; all changes in the original node are
	reflected immediately. Because of this, side effects can be
	present for some DOM tree manipulation styles, in particular,
	in multi-threaded environments.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getFirstChild">getFirstChild</a></h2>

<table summary="Function 'Dom::NodeRef::getFirstChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getFirstChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the first child node of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getFirstChild()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the first child node, or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the first child node, or NULL, if this 
	node has no children<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getLastChild">getLastChild</a></h2>

<table summary="Function 'Dom::NodeRef::getLastChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getLastChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the last child node of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getLastChild()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the last child node, or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the last child node, or NULL, if this 
	node has no children<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getLocalName">getLocalName</a></h2>

<table summary="Function 'Dom::NodeRef::getLocalName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getLocalName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get local name of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getLocalName()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> local name of this node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns local name (local part of the qualified name) of this
	node (in the data encoding) as a NULL-terminated string.  If
	this node's name is not fully qualified (has no prefix), then
	the local name is the same as the name.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getNamespaceURI">getNamespaceURI</a></h2>

<table summary="Function 'Dom::NodeRef::getNamespaceURI' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNamespaceURI</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get namespace URI of this node as a NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getNamespaceURI()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> namespace URI of this node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the namespace URI of this node (in the data encoding)
	as a NULL-terminated string.  If the node's name is not
	qualified (does not contain a namespace prefix), it will have
	the default namespace in effect when the node was created
	(which may be NULL).<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getNextSibling">getNextSibling</a></h2>

<table summary="Function 'Dom::NodeRef::getNextSibling' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNextSibling</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the next sibling node of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getNextSibling()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the next sibling node, or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the next sibling node, or NULL,
	if this node has no next sibling<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getNoMod">getNoMod</a></h2>

<table summary="Function 'Dom::NodeRef::getNoMod' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNoMod</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Tests if no modifications are allowed for this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;getNoMod()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if no modifications are allowed</tr>
<tr><th scope=row><i>Description</i>
<td>        Tests if no modifications are allowed for this node and the
	DOM tree it belongs to. This member function is Oracle
	extension.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getNodeName">getNodeName</a></h2>

<table summary="Function 'Dom::NodeRef::getNodeName' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNodeName</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node's name as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getNodeName()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> name of node in data encoding</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the (fully-qualified) name of the node (in the data
	encoding) as a NULL-terminated string, for example "bar\0"
	or "foo:bar\0". Some node kinds have fixed names: "#text",
	"#cdata-section", "#comment", "#document", "#document-fragment".
	The name of a node cannot changed once it is created.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getNodeType">getNodeType</a></h2>

<table summary="Function 'Dom::NodeRef::getNodeType' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNodeType</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>get DOMNodeType of the node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;DOMNodeType&nbsp;getNodeType()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(DOMNodeType)</b></tt> of the node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns DOMNodeType of the node<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getNodeValue">getNodeValue</a></h2>

<table summary="Function 'Dom::NodeRef::getNodeValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getNodeValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get node's value as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getNodeValue()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> value of node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the "value" (associated character data) for a node as a
        NULL-terminated string.  Character and general entities will have
        been replaced.  Only Attr, CDATA, Comment, PI and Text nodes have
        values, all other node types have NULL value.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getOwnerDocument">getOwnerDocument</a></h2>

<table summary="Function 'Dom::NodeRef::getOwnerDocument' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getOwnerDocument</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the owner document of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getOwnerDocument()&nbsp;const&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the owning document node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the document node associated with this node.  It is
	assumed that the document node type is derived from the node
	type. Each node may belong to only one document, or may not
	be associated with any document at all, e.g. immediately after
	it was created on user's request. The "owning" document [node]
	is returned, or the WRONG_DOCUMENT_ERR exception is thrown.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getParentNode">getParentNode</a></h2>

<table summary="Function 'Dom::NodeRef::getParentNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getParentNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get parent node of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getParentNode()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the parent node, or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the parent node, or NULL, if this 
	node has no parent<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getPrefix">getPrefix</a></h2>

<table summary="Function 'Dom::NodeRef::getPrefix' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getPrefix</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get namespace prefix of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getPrefix()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> namespace prefix of this node</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the namespace prefix of this node (in the data encoding)
	(as a NULL-terminated string). If this node's name is not fully
	qualified (has no prefix), NULL is returned.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::getPreviousSibling">getPreviousSibling</a></h2>

<table summary="Function 'Dom::NodeRef::getPreviousSibling' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getPreviousSibling</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the previous sibling node of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getPreviousSibling()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the previous sibling node, or NULL</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the previous sibling node, or NULL,
	if this node has no previous siblings<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::hasAttributes">hasAttributes</a></h2>

<table summary="Function 'Dom::NodeRef::hasAttributes' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>hasAttributes</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Tests if this node has attributes</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;hasAttributes()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE is this node is an element and has attributes</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns TRUE if this node has attributes, if it is an element.
	Otherwise, it returns FALSE. Note that for nodes that are not
	elements, it always returns FALSE.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::hasChildNodes">hasChildNodes</a></h2>

<table summary="Function 'Dom::NodeRef::hasChildNodes' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>hasChildNodes</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Test if this node has children</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;hasChildNodes()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if this node has any children</tr>
<tr><th scope=row><i>Description</i>
<td>        Tests if this node has children.  Only Element, Document,
	DTD, and DocumentFragment nodes may have children.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::insertBefore">insertBefore</a></h2>

<table summary="Function 'Dom::NodeRef::insertBefore' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>insertBefore</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Insert new child into node's list of children</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;insertBefore(&nbsp;NodeRef&&nbsp;newChild,&nbsp;NodeRef&&nbsp;refChild)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::insertBefore' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the node to insert</td></tr>
<tr><td scope=row><tt>refChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the node to insert before</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the node being inserted</tr>
<tr><th scope=row><i>Description</i>
<td>        Inserts the node newChild before the existing child node
	refChild in this node.  refChild must be a child of this
        node.  If newChild is a DocumentFragment, all of its children
        are inserted (in the same order) before refChild; the
	DocumentFragment node itself is not.  If newChild is already in
	the DOM tree, it is first removed from its current position.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::isSupported">isSupported</a></h2>

<table summary="Function 'Dom::NodeRef::isSupported' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>isSupported</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Tests if specified feature is supported by the implementation</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;isSupported(&nbsp;oratext*&nbsp;feature,&nbsp;oratext*&nbsp;version)&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::isSupported' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>feature</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> package name of the feature to test</td></tr>
<tr><td scope=row><tt>version</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> version # of the package name to test</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE is specified feature is supported</tr>
<tr><th scope=row><i>Description</i>
<td>        Tests if the feature, specified by the arguments, is supported
	by the DOM implementation of this node.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::markToDelete">markToDelete</a></h2>

<table summary="Function 'Dom::NodeRef::markToDelete' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>markToDelete</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Sets the mark to delete the referenced node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;markToDelete();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the mark indicating that the referenced node should be
	deleted at the time when destructor of this reference is called.
	All other references to the node become invalid. This behavior
	is inherited by all other reference classes. This member
	function is Oracle extension.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::normalize">normalize</a></h2>

<table summary="Function 'Dom::NodeRef::normalize' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>normalize</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Merge adjacent text nodes</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;normalize();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        "Normalizes" the subtree rooted at an element, i.e. merges
	adjacent Text nodes children of elements.  Note that adjacent
	Text nodes will never be created during a normal parse, only
	after manipulation of the document with DOM calls.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::removeChild">removeChild</a></h2>

<table summary="Function 'Dom::NodeRef::removeChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>removeChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Remove an existing child node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;removeChild(&nbsp;NodeRef&&nbsp;oldChild)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::removeChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>oldChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the node to be removed</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> node removed</tr>
<tr><th scope=row><i>Description</i>
<td>        Removes the node from this node's list of children and returns
	it. The node is orphaned; its parent will be NULL after removal.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::replaceChild">replaceChild</a></h2>

<table summary="Function 'Dom::NodeRef::replaceChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>replaceChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Replace an existing child of a node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;replaceChild(&nbsp;NodeRef&&nbsp;newChild,&nbsp;NodeRef&&nbsp;oldChild)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::replaceChild' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to new node being substituted</td></tr>
<tr><td scope=row><tt>oldChild</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the node to be substituted</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> the node replaced</tr>
<tr><th scope=row><i>Description</i>
<td>        Replaces the child node oldChild with the new node newChild in
        this node's children list, and returns oldChild (which is now
	orphaned, with a NULL parent).  If newChild is a DocumentFragment,
	all of its children are inserted in place of oldChild; the
	DocumentFragment node itself is not.  If newChild is already in
	the DOM tree, it is first removed from its current position.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::resetNode">resetNode</a></h2>

<table summary="Function 'Dom::NodeRef::resetNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>resetNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Reset NodeRef to reference another node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;resetNode(&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::resetNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt> </tr>
<tr><th scope=row><i>Description</i>
<td>        This function resets NodeRef to reference Node given
	as an argument<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::setNodeValue">setNodeValue</a></h2>

<table summary="Function 'Dom::NodeRef::setNodeValue' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setNodeValue</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set node's value as NULL-terminated string</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setNodeValue(&nbsp;oratext*&nbsp;data)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::setNodeValue' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node's new value</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt> </tr>
<tr><th scope=row><i>Description</i>
<td>        Sets a node's value (character data) as a NULL-terminated
	string. Does not allow setting the value to NULL.  Only Attr,
	CDATA, Comment, PI, and Text nodes have values. Trying to set
	the value of another kind of node is a no-op.  The new value
	must be in the data encoding! It is not verified, converted,
	or checked. The value is NOT copied, its pointer is just
	stored. The user is responsible for persistence and freeing of
	that data.<p>
	It throws the NO_MODIFICATION_ALLOWED_ERR exception, if no
	modifications are allowed, or UNDEFINED_ERR, with an
	appropriate Oracle XML error code (see xml.h), in the case of
	an implementation defined error.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::setPrefix">setPrefix</a></h2>

<table summary="Function 'Dom::NodeRef::setPrefix' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setPrefix</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set namespace prefix of this node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setPrefix(&nbsp;oratext*&nbsp;prefix)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NodeRef::setPrefix' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>prefix</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> new namespace prefix</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets the namespace prefix of this node (as NULL-terminated
	string). Does not verify the prefix is defined! And does not
	verify that the prefix is in the current data encoding. Just
	causes a new QName to be formed from the new prefix and the old
	local name.<p>
	It throws the NO_MODIFICATION_ALLOWED_ERR exception, if no
	modifications are allowed. Or it throws NAMESPACE_ERR if the
	namespaceURI of this node is null, or if the specified prefix
	is "xml" and the namespaceURI of this node is different from
	"http://www.w3.org/XML/1998/namespace", or if this node is an
	attribute and the specified prefix is "xmlns" and the
	namespaceURI of this node is different from
	"http://www.w3.org/2000/xmlns/". Note that the
	INVALID_CHARACTER_ERR exception is never thrown since it is
	not checked how the prefix is formed<p>
</tr>
</table>

<h2 align=center><a name="Dom::NodeRef::~NodeRef">~NodeRef</a></h2>

<table summary="Function 'Dom::NodeRef::~NodeRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>~NodeRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NodeRef">NodeRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Public default destructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;~NodeRef();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        This is the default destructor. It cleans the reference to
	the node and, if the node is marked for deletion, deletes
	the node. If the node was marked for deep deletion, the tree
	under the node is also deleted (deallocated). It is usually
	called by the environment. But it can be called by the user
	directly if necessary.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NotationRef::NotationRef">NotationRef</a></h2>

<table summary="Function 'Dom::NotationRef::NotationRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NotationRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NotationRef">NotationRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NotationRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NotationRef::NotationRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> notation node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NotationRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given notation node after a call to createNotation.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NotationRef::NotationRef_1">NotationRef</a></h2>

<table summary="Function 'Dom::NotationRef::NotationRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>NotationRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NotationRef">NotationRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;NotationRef(&nbsp;const&nbsp;NotationRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::NotationRef::NotationRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(NotationRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::NotationRef::getPublicId">getPublicId</a></h2>

<table summary="Function 'Dom::NotationRef::getPublicId' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getPublicId</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NotationRef">NotationRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get publicId</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getPublicId()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> publicId</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::NotationRef::getSystemId">getSystemId</a></h2>

<table summary="Function 'Dom::NotationRef::getSystemId' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getSystemId</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#NotationRef">NotationRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get systemId</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getSystemId()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> systemId</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::ProcessingInstructionRef::ProcessingInstructionRef">ProcessingInstructionRef</a></h2>

<table summary="Function 'Dom::ProcessingInstructionRef::ProcessingInstructionRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>ProcessingInstructionRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;ProcessingInstructionRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,<br>				Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ProcessingInstructionRef::ProcessingInstructionRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> PI node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ProcessingInstructionRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references to a given PI node
	after a call to createProcessingInstruction.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ProcessingInstructionRef::ProcessingInstructionRef_1">ProcessingInstructionRef</a></h2>

<table summary="Function 'Dom::ProcessingInstructionRef::ProcessingInstructionRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>ProcessingInstructionRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;ProcessingInstructionRef(<br>			&nbsp;const&nbsp;ProcessingInstructionRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ProcessingInstructionRef::ProcessingInstructionRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(ProcessingInstructionRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ProcessingInstructionRef::getData">getData</a></h2>

<table summary="Function 'Dom::ProcessingInstructionRef::getData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get processing instruction's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getData()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> processing instruction's data</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns the content (data) of a processing instruction (in the
	data encoding). The content is the part from the first
	non-whitespace character after the target until the ending "?&gt;".<p>
</tr>
</table>

<h2 align=center><a name="Dom::ProcessingInstructionRef::getTarget">getTarget</a></h2>

<table summary="Function 'Dom::ProcessingInstructionRef::getTarget' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getTarget</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get processing instruction's target</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;getTarget()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> processing instruction's target</tr>
<tr><th scope=row><i>Description</i>
<td>        Returns a processing instruction's target string. The target is
	the first token following the markup that begins the PI.  All PIs
	must have a target, though the data part is optional.<p>
</tr>
</table>

<h2 align=center><a name="Dom::ProcessingInstructionRef::setData">setData</a></h2>

<table summary="Function 'Dom::ProcessingInstructionRef::setData' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setData</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#ProcessingInstructionRef">ProcessingInstructionRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set processing instruction's data</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setData(&nbsp;oratext*&nbsp;data)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::ProcessingInstructionRef::setData' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>data</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> processing instruction's new data</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Sets processing instruction's data (content), which must be
        in the data encoding.  It is not permitted to set the data to
	NULL. The new data is not verified, converted, or checked.<p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::CompareBoundaryPoints">CompareBoundaryPoints</a></h2>

<table summary="Function 'Dom::Range::CompareBoundaryPoints' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>CompareBoundaryPoints</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;CompareHowCode&nbsp;compareBoundaryPoints(&nbsp;unsigned&nbsp;short&nbsp;how,<br>				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Range<&nbsp;Node>*&nbsp;sourceRange)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::CompareBoundaryPoints' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>how</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> how to compare</td></tr>
<tr><td scope=row><tt>sourceRange</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> range to compare with</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(CompareHowCode)</b></tt> result of comparison</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::cloneContent">cloneContent</a></h2>

<table summary="Function 'Dom::Range::cloneContent' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>cloneContent</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;cloneContents()&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> subtree cloned</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::cloneRange">cloneRange</a></h2>

<table summary="Function 'Dom::Range::cloneRange' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>cloneRange</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Range<&nbsp;Node>*&nbsp;cloneRange();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Range< Node>*)</b></tt> new cloned range</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::deleteContents">deleteContents</a></h2>

<table summary="Function 'Dom::Range::deleteContents' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>deleteContents</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;deleteContents()&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::detach">detach</a></h2>

<table summary="Function 'Dom::Range::detach' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>detach</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>invalidate the range</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;detach();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Invalidates the range. It is not recommended to use
	this method since it leaves the object in invalid state.
	The preferable way is to call the destructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::extractContent">extractContent</a></h2>

<table summary="Function 'Dom::Range::extractContent' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>extractContent</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;extractContents()&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> subtree extracted</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::getCollapsed">getCollapsed</a></h2>

<table summary="Function 'Dom::Range::getCollapsed' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getCollapsed</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Check if the range is collapsed</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;boolean&nbsp;getCollapsed()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(boolean)</b></tt> TRUE if the range is collapsed, FALSE otherwise</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::getCommonAncestorContainer">getCommonAncestorContainer</a></h2>

<table summary="Function 'Dom::Range::getCommonAncestorContainer' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getCommonAncestorContainer</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the deepest common ancestor node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getCommonAncestorContainer()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> common ancestor node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::getEndContainer">getEndContainer</a></h2>

<table summary="Function 'Dom::Range::getEndContainer' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getEndContainer</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get end container node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getEndContainer()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> end container node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::getEndOffset">getEndOffset</a></h2>

<table summary="Function 'Dom::Range::getEndOffset' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getEndOffset</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get offset of the end point</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;long&nbsp;getEndOffset()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(long)</b></tt> offset</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::getStartContainer">getStartContainer</a></h2>

<table summary="Function 'Dom::Range::getStartContainer' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getStartContainer</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get start container node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;getStartContainer()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> start container node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::getStartOffset">getStartOffset</a></h2>

<table summary="Function 'Dom::Range::getStartOffset' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getStartOffset</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get offset of the start point</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;long&nbsp;getStartOffset()&nbsp;const;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(long)</b></tt> offset</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::insertNode">insertNode</a></h2>

<table summary="Function 'Dom::Range::insertNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>insertNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;insertNode(&nbsp;NodeRef<&nbsp;Node>&&nbsp;newNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException,&nbsp;DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::insertNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> node to insert</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::select">select</a></h2>

<table summary="Function 'Dom::Range::select' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>select</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;selectNodeContent(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::select' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::selectNode">selectNode</a></h2>

<table summary="Function 'Dom::Range::selectNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>selectNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;selectNode(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::selectNode' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::setEnd">setEnd</a></h2>

<table summary="Function 'Dom::Range::setEnd' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setEnd</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set end point</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setEnd(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode,&nbsp;long&nbsp;offset)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException,&nbsp;DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::setEnd' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> end container</td></tr>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> end offset</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::setEndAfter">setEndAfter</a></h2>

<table summary="Function 'Dom::Range::setEndAfter' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setEndAfter</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setEndAfter(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException);<br>/*---------------------------------------------------------------------<br>NAME<br>&nbsp;&nbsp;&nbsp;&nbsp;collapse</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::setEndAfter' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::setEndBefore">setEndBefore</a></h2>

<table summary="Function 'Dom::Range::setEndBefore' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setEndBefore</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setEndBefore(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::setEndBefore' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::setStart">setStart</a></h2>

<table summary="Function 'Dom::Range::setStart' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setStart</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Set start point</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setStart(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode,&nbsp;long&nbsp;offset)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException,&nbsp;DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::setStart' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> start container</td></tr>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> start offset</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::setStartAfter">setStartAfter</a></h2>

<table summary="Function 'Dom::Range::setStartAfter' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setStartAfter</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setStartAfter(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::setStartAfter' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::setStartBefore">setStartBefore</a></h2>

<table summary="Function 'Dom::Range::setStartBefore' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>setStartBefore</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;setStartBefore(&nbsp;NodeRef<&nbsp;Node>&&nbsp;refNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::setStartBefore' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>refNode</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::surroundContent">surroundContent</a></h2>

<table summary="Function 'Dom::Range::surroundContent' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>surroundContent</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;surroundContents(&nbsp;NodeRef<&nbsp;Node>&&nbsp;newParent)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(RangeException,&nbsp;DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::Range::surroundContent' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>newParent</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> parent node</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::Range::toString">toString</a></h2>

<table summary="Function 'Dom::Range::toString' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>toString</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#Range">Range</a></tr>

<tr><th scope=row><i>Purpose</i>
<td></tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;oratext*&nbsp;toString();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> string representation of the range</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::RangeException::getCode">getCode</a></h2>

<table summary="Function 'Dom::RangeException::getCode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getCode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#RangeException">RangeException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get Oracle XML error code embedded in the exception </tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;//&nbsp;virtual&nbsp;unsigned&nbsp;getCode()&nbsp;const&nbsp;=&nbsp;0;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(unsigned)</b></tt> numeric error code (0 on success)</tr>
<tr><th scope=row><i>Description</i>
<td>        Virtual member function inherited from XMLException<p>
</tr>
</table>

<h2 align=center><a name="Dom::RangeException::getMesLang">getMesLang</a></h2>

<table summary="Function 'Dom::RangeException::getMesLang' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getMesLang</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#RangeException">RangeException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get current language (encoding) of error messages</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;//&nbsp;virtual&nbsp;oratext*&nbsp;getMesLang()&nbsp;const&nbsp;=&nbsp;0;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext*)</b></tt> Current language (encoding) of error messages</tr>
<tr><th scope=row><i>Description</i>
<td>        Virtual member function inherited from XMLException<p>
</tr>
</table>

<h2 align=center><a name="Dom::RangeException::getMessage">getMessage</a></h2>

<table summary="Function 'Dom::RangeException::getMessage' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getMessage</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#RangeException">RangeException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get Oracle XML error message</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;//&nbsp;virtual&nbsp;oratext*&nbsp;getMessage()&nbsp;const&nbsp;=&nbsp;0;</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(oratext *)</b></tt> Error message</tr>
<tr><th scope=row><i>Description</i>
<td>        Virtual member function inherited from XMLException<p>
</tr>
</table>

<h2 align=center><a name="Dom::RangeException::getRangeCode">getRangeCode</a></h2>

<table summary="Function 'Dom::RangeException::getRangeCode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>getRangeCode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#RangeException">RangeException</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get Range exception code embedded in the exception </tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;virtual&nbsp;RangeExceptionCode&nbsp;getRangeCode()&nbsp;const&nbsp;=&nbsp;0;<br>};</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(RangeExceptionCode)</b></tt> exception code</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a virtual member function that defines a prototype
	for implementation defined member functions returning Range
	exception codes, defined in RangeExceptionCode, of the
	exceptional situations during execution<p>
</tr>
</table>

<h2 align=center><a name="Dom::TextRef::TextRef">TextRef</a></h2>

<table summary="Function 'Dom::TextRef::TextRef' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>TextRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TextRef">TextRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;TextRef(&nbsp;const&nbsp;NodeRef<&nbsp;Node>&&nbsp;node_ref,&nbsp;Node*&nbsp;nptr);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::TextRef::TextRef' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>node_ref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to provide the context</td></tr>
<tr><td scope=row><tt>nptr</tt></td>
<td>&nbsp;<b>()</b>&nbsp;</td>
<td> text node to be referenced</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(TextRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This constructor is used to create references
	to a given text node after a call to createtext.<p>
</tr>
</table>

<h2 align=center><a name="Dom::TextRef::TextRef_1">TextRef</a></h2>

<table summary="Function 'Dom::TextRef::TextRef_1' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>TextRef</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TextRef">TextRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Copy constructor</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;TextRef(&nbsp;const&nbsp;TextRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::TextRef::TextRef_1' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> reference to the reference object to be copied</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(TextRef)</b></tt> Node reference object</tr>
<tr><th scope=row><i>Description</i>
<td>        This is a copy constructor.<p>
</tr>
</table>

<h2 align=center><a name="Dom::TextRef::splitText">splitText</a></h2>

<table summary="Function 'Dom::TextRef::splitText' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>splitText</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TextRef">TextRef</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Split text node into two</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;splitText(&nbsp;ub4&nbsp;offset)&nbsp;throw&nbsp;(DOMException);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::TextRef::splitText' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>offset</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> character offset at which to split</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> new node</tr>
<tr><th scope=row><i>Description</i>
<td>        Splits a single text node into two text nodes; the original data
        is split between them. The offset is zero-based, and is in
	characters, not bytes. The original node is retained, its data
	is just truncated.  A new text node is created which contains
	the remainder of the original data, and is inserted as the next
	sibling of the original.  The new text node is returned.<p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::adjustCtx">adjustCtx</a></h2>

<table summary="Function 'Dom::TreeWalker::adjustCtx' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>adjustCtx</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Attach this tree walker to the another context</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;void&nbsp;adjustCtx(&nbsp;NodeRef<&nbsp;Node>&&nbsp;nref);</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<table summary="Function 'Dom::TreeWalker::adjustCtx' arguments" cellspacing=0 cellpadding=0>
<tr><td scope=row><tt>nref</tt></td>
<td>&nbsp;<b>(IN)</b>&nbsp;</td>
<td> given node reference</td></tr>
</table>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(void)</b></tt></tr>
<tr><th scope=row><i>Description</i>
<td>        Attaches this tree walker to the context associated with
	a given node reference<p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::firstChild">firstChild</a></h2>

<table summary="Function 'Dom::TreeWalker::firstChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>firstChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the first child of the current node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;firstChild();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to first child node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::lastChild">lastChild</a></h2>

<table summary="Function 'Dom::TreeWalker::lastChild' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>lastChild</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the last child of the current node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;lastChild();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to last child node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::nextNode">nextNode</a></h2>

<table summary="Function 'Dom::TreeWalker::nextNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>nextNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the next node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;nextNode();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the next node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::nextSibling">nextSibling</a></h2>

<table summary="Function 'Dom::TreeWalker::nextSibling' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>nextSibling</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the next sibling node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;nextSibling();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the next sibling node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::parentNode">parentNode</a></h2>

<table summary="Function 'Dom::TreeWalker::parentNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>parentNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the parent of the current node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;parentNode();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the parent node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::previousNode">previousNode</a></h2>

<table summary="Function 'Dom::TreeWalker::previousNode' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>previousNode</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the previous node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;previousNode();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to te previous node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>

<h2 align=center><a name="Dom::TreeWalker::previousSibling">previousSibling</a></h2>

<table summary="Function 'Dom::TreeWalker::previousSibling' details" border cellpadding=2 cellspacing=1 bgcolor="#EEEEEE" width="100%">
<tr><th scope=row width="10%"><i>Name</i>
<td><tt><b>previousSibling</b></tt></tr>
<tr><th scope=row><i>Interface</i>
<td><a href="#TreeWalker">TreeWalker</a></tr>

<tr><th scope=row><i>Purpose</i>
<td>Get the previous sibling node</tr>
<tr><th scope=row><i>Prototype</i>
<td><tt><b>&nbsp;&nbsp;Node*&nbsp;previousSibling();</b></tt></tr>
<tr><th scope=row><i>Arguments</i><td>
<tt>void</tt>
</td></tr>
<tr><th scope=row><i>Returns</i>
<td>        <tt><b>(Node*)</b></tt> pointer to the previous sibling node</tr>
<tr><th scope=row><i>Description</i>
<td>        <p>
</tr>
</table>
</body>
</html>
